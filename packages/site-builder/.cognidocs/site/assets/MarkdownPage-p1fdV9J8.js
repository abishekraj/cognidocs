const __vite__mapDeps = (
  i,
  m = __vite__mapDeps,
  d = m.f ||
    (m.f = [
      'assets/dagre-6UL2VRFP-DnnxFcWZ.js',
      'assets/graph-DjehPYHm.js',
      'assets/_baseUniq-D4RoSXpb.js',
      'assets/layout-C57UE0LX.js',
      'assets/_basePickBy-B8l-XB8e.js',
      'assets/clone-GXC5ofYK.js',
      'assets/ui-vendor-uWBPbD_0.js',
      'assets/react-vendor-BI367zWJ.js',
      'assets/index-oaZTyD6l.js',
      'assets/index-C8kvMy05.css',
      'assets/graph-vendor-BuQDEdtN.js',
      'assets/markdown-vendor-DSh4w1Df.js',
      'assets/cose-bilkent-S5V4N54A-D0_Goe5Y.js',
      'assets/cytoscape.esm-3uhDE42e.js',
      'assets/c4Diagram-YG6GDRKO-DPaNDk9m.js',
      'assets/chunk-TZMSLE5B-BiN50XVz.js',
      'assets/flowDiagram-NV44I4VS-CAsIbosh.js',
      'assets/chunk-FMBD7UC4-DUsZ0oDW.js',
      'assets/chunk-55IACEB6-BIPibI9z.js',
      'assets/chunk-QN33PNHL-C981hClY.js',
      'assets/channel-yyWHjzAk.js',
      'assets/erDiagram-Q2GNP2WA-C1DitjC6.js',
      'assets/gitGraphDiagram-NY62KEGX-lP50St_b.js',
      'assets/chunk-4BX2VUAB-DyVaAKXC.js',
      'assets/chunk-QZHKN3VN-BED85bG_.js',
      'assets/treemap-KMMF4GRG-gY4DcCqE.js',
      'assets/ganttDiagram-JELNMOA3-BYzjaFvD.js',
      'assets/infoDiagram-WHAUD3N6-CefxpB2b.js',
      'assets/pieDiagram-ADFJNKIX-242Nj-Xj.js',
      'assets/quadrantDiagram-AYHSOK5B-D3JtUApC.js',
      'assets/xychartDiagram-PRI3JC2R-c2uxP9ZU.js',
      'assets/requirementDiagram-UZGBJVZJ-guiN45tV.js',
      'assets/sequenceDiagram-WL72ISMW-hXFpyQEg.js',
      'assets/classDiagram-2ON5EDUG-CB9dv5mA.js',
      'assets/chunk-B4BG7PRW-B9fjNP4s.js',
      'assets/classDiagram-v2-WZHVMYZB-CB9dv5mA.js',
      'assets/stateDiagram-FKZM4ZOC-D0MynZ2i.js',
      'assets/chunk-DI55MBZ5-97fHYlY4.js',
      'assets/stateDiagram-v2-4FDKWEC3-CPSN-VYh.js',
      'assets/journeyDiagram-XKPGCS4Q-jxYV86WG.js',
      'assets/timeline-definition-IT6M3QCI-BS2lZn0_.js',
      'assets/mindmap-definition-VGOIOE7T-CyMgk9Ca.js',
      'assets/kanban-definition-3W4ZIXB7-BAvfGnhN.js',
      'assets/sankeyDiagram-TZEHDZUN-CYgebI4c.js',
      'assets/diagram-S2PKOQOG-Vh_aATIf.js',
      'assets/diagram-QEK2KX5R-yi2SO2dh.js',
      'assets/blockDiagram-VD42YOAC-BL-PoLRm.js',
      'assets/architectureDiagram-VXUJARFQ-BNglibIs.js',
      'assets/diagram-PSM6KHXK-B1Y5e2Qd.js',
    ])
) => i.map((i) => d[i]);
var e,
  t,
  r,
  n,
  i,
  a,
  o,
  s,
  l,
  c,
  h = Object.defineProperty,
  d = (e, t, r) =>
    ((e, t, r) =>
      t in e ? h(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r))(
      e,
      'symbol' != typeof t ? t + '' : t,
      r
    );
import {
  j as u,
  g as p,
  i as g,
  k as f,
  e as m,
  ah as b,
  ai as y,
  aj as x,
} from './ui-vendor-uWBPbD_0.js';
import { g as k, r as C, d as w } from './react-vendor-BI367zWJ.js';
import { _ as v, u as _ } from './index-oaZTyD6l.js';
import {
  s as S,
  H as E,
  I as D,
  J as A,
  K as T,
  L as F,
  M as B,
  N as M,
  O as N,
  P as L,
  Q as O,
  R as $,
  S as I,
  T as R,
  U as z,
  V as P,
  W as j,
  X as q,
  Y as W,
  Z as U,
  e as H,
  c as G,
} from './graph-vendor-BuQDEdtN.js';
import {
  d as V,
  c as Z,
  o as K,
  v as Y,
  m as X,
  f as Q,
  a as J,
  b as ee,
  e as te,
  u as re,
  g as ne,
  h as ie,
  i as ae,
  M as oe,
  r as se,
} from './markdown-vendor-DSh4w1Df.js';
const le = [
    'AElig',
    'AMP',
    'Aacute',
    'Acirc',
    'Agrave',
    'Aring',
    'Atilde',
    'Auml',
    'COPY',
    'Ccedil',
    'ETH',
    'Eacute',
    'Ecirc',
    'Egrave',
    'Euml',
    'GT',
    'Iacute',
    'Icirc',
    'Igrave',
    'Iuml',
    'LT',
    'Ntilde',
    'Oacute',
    'Ocirc',
    'Ograve',
    'Oslash',
    'Otilde',
    'Ouml',
    'QUOT',
    'REG',
    'THORN',
    'Uacute',
    'Ucirc',
    'Ugrave',
    'Uuml',
    'Yacute',
    'aacute',
    'acirc',
    'acute',
    'aelig',
    'agrave',
    'amp',
    'aring',
    'atilde',
    'auml',
    'brvbar',
    'ccedil',
    'cedil',
    'cent',
    'copy',
    'curren',
    'deg',
    'divide',
    'eacute',
    'ecirc',
    'egrave',
    'eth',
    'euml',
    'frac12',
    'frac14',
    'frac34',
    'gt',
    'iacute',
    'icirc',
    'iexcl',
    'igrave',
    'iquest',
    'iuml',
    'laquo',
    'lt',
    'macr',
    'micro',
    'middot',
    'nbsp',
    'not',
    'ntilde',
    'oacute',
    'ocirc',
    'ograve',
    'ordf',
    'ordm',
    'oslash',
    'otilde',
    'ouml',
    'para',
    'plusmn',
    'pound',
    'quot',
    'raquo',
    'reg',
    'sect',
    'shy',
    'sup1',
    'sup2',
    'sup3',
    'szlig',
    'thorn',
    'times',
    'uacute',
    'ucirc',
    'ugrave',
    'uml',
    'uuml',
    'yacute',
    'yen',
    'yuml',
  ],
  ce = {
    0: '�',
    128: '€',
    130: '‚',
    131: 'ƒ',
    132: '„',
    133: '…',
    134: '†',
    135: '‡',
    136: 'ˆ',
    137: '‰',
    138: 'Š',
    139: '‹',
    140: 'Œ',
    142: 'Ž',
    145: '‘',
    146: '’',
    147: '“',
    148: '”',
    149: '•',
    150: '–',
    151: '—',
    152: '˜',
    153: '™',
    154: 'š',
    155: '›',
    156: 'œ',
    158: 'ž',
    159: 'Ÿ',
  };
function he(e) {
  const t = 'string' == typeof e ? e.charCodeAt(0) : e;
  return t >= 48 && t <= 57;
}
function de(e) {
  const t = 'string' == typeof e ? e.charCodeAt(0) : e;
  return (t >= 97 && t <= 102) || (t >= 65 && t <= 70) || (t >= 48 && t <= 57);
}
function ue(e) {
  return (
    (function (e) {
      const t = 'string' == typeof e ? e.charCodeAt(0) : e;
      return (t >= 97 && t <= 122) || (t >= 65 && t <= 90);
    })(e) || he(e)
  );
}
const pe = [
  '',
  'Named character references must be terminated by a semicolon',
  'Numeric character references must be terminated by a semicolon',
  'Named character references cannot be empty',
  'Numeric character references cannot be empty',
  'Named character references must be known',
  'Numeric character references cannot be disallowed',
  'Numeric character references cannot be outside the permissible Unicode range',
];
function ge(e, t) {
  const r = t || {},
    n = 'string' == typeof r.additional ? r.additional.charCodeAt(0) : r.additional,
    i = [];
  let a,
    o,
    s = 0,
    l = -1,
    c = '';
  r.position &&
    ('start' in r.position || 'indent' in r.position
      ? ((o = r.position.indent), (a = r.position.start))
      : (a = r.position));
  let h,
    d = (a ? a.line : 0) || 1,
    u = (a ? a.column : 0) || 1,
    p = g();
  for (s--; ++s <= e.length; )
    if ((10 === h && (u = (o ? o[l] : 0) || 1), (h = e.charCodeAt(s)), 38 === h)) {
      const t = e.charCodeAt(s + 1);
      if (
        9 === t ||
        10 === t ||
        12 === t ||
        32 === t ||
        38 === t ||
        60 === t ||
        Number.isNaN(t) ||
        (n && t === n)
      ) {
        ((c += String.fromCharCode(h)), u++);
        continue;
      }
      const a = s + 1;
      let o,
        l = a,
        d = a;
      if (35 === t) {
        d = ++l;
        const t = e.charCodeAt(d);
        88 === t || 120 === t ? ((o = 'hexadecimal'), (d = ++l)) : (o = 'decimal');
      } else o = 'named';
      let b = '',
        y = '',
        x = '';
      const k = 'named' === o ? ue : 'decimal' === o ? he : de;
      for (d--; ++d <= e.length; ) {
        const t = e.charCodeAt(d);
        if (!k(t)) break;
        ((x += String.fromCharCode(t)), 'named' === o && le.includes(x) && ((b = x), (y = V(x))));
      }
      let C = 59 === e.charCodeAt(d);
      if (C) {
        d++;
        const e = 'named' === o && V(x);
        e && ((b = x), (y = e));
      }
      let w = 1 + d - a,
        v = '';
      if (C || !1 !== r.nonTerminated)
        if (x)
          if ('named' === o) {
            if (C && !y) f(5, 1);
            else if ((b !== x && ((d = l + b.length), (w = 1 + d - l), (C = !1)), !C)) {
              const t = b ? 1 : 3;
              if (r.attribute) {
                const r = e.charCodeAt(d);
                61 === r ? (f(t, w), (y = '')) : ue(r) ? (y = '') : f(t, w);
              } else f(t, w);
            }
            v = y;
          } else {
            C || f(2, w);
            let e = Number.parseInt(x, 'hexadecimal' === o ? 16 : 10);
            if (fe(e)) (f(7, w), (v = String.fromCharCode(65533)));
            else if (e in ce) (f(6, w), (v = ce[e]));
            else {
              let t = '';
              (me(e) && f(6, w),
                e > 65535 &&
                  ((e -= 65536),
                  (t += String.fromCharCode((e >>> 10) | 55296)),
                  (e = 56320 | (1023 & e))),
                (v = t + String.fromCharCode(e)));
            }
          }
        else 'named' !== o && f(4, w);
      else;
      if (v) {
        (m(), (p = g()), (s = d - 1), (u += d - a + 1), i.push(v));
        const t = g();
        (t.offset++,
          r.reference &&
            r.reference.call(
              r.referenceContext || void 0,
              v,
              { start: p, end: t },
              e.slice(a - 1, d)
            ),
          (p = t));
      } else ((x = e.slice(a - 1, d)), (c += x), (u += x.length), (s = d - 1));
    } else
      (10 === h && (d++, l++, (u = 0)),
        Number.isNaN(h) ? m() : ((c += String.fromCharCode(h)), u++));
  return i.join('');
  function g() {
    return { line: d, column: u, offset: s + ((a ? a.offset : 0) || 0) };
  }
  function f(e, t) {
    let n;
    r.warning &&
      ((n = g()),
      (n.column += t),
      (n.offset += t),
      r.warning.call(r.warningContext || void 0, pe[e], n, e));
  }
  function m() {
    c &&
      (i.push(c),
      r.text && r.text.call(r.textContext || void 0, c, { start: p, end: g() }),
      (c = ''));
  }
}
function fe(e) {
  return (e >= 55296 && e <= 57343) || e > 1114111;
}
function me(e) {
  return (
    (e >= 1 && e <= 8) ||
    11 === e ||
    (e >= 13 && e <= 31) ||
    (e >= 127 && e <= 159) ||
    (e >= 64976 && e <= 65007) ||
    !(65535 & ~e) ||
    65534 == (65535 & e)
  );
}
const be = /["&'<>`]/g,
  ye = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  xe = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
  ke = /[|\\{}()[\]^$+*?.]/g,
  Ce = new WeakMap();
function we(e, t) {
  return (
    (e = e.replace(
      t.subset
        ? (function (e) {
            let t = Ce.get(e);
            t ||
              ((t = (function (e) {
                const t = [];
                let r = -1;
                for (; ++r < e.length; ) t.push(e[r].replace(ke, '\\$&'));
                return new RegExp('(?:' + t.join('|') + ')', 'g');
              })(e)),
              Ce.set(e, t));
            return t;
          })(t.subset)
        : be,
      r
    )),
    t.subset || t.escapeOnly
      ? e
      : e
          .replace(ye, function (e, r, n) {
            return t.format(
              1024 * (e.charCodeAt(0) - 55296) + e.charCodeAt(1) - 56320 + 65536,
              n.charCodeAt(r + 2),
              t
            );
          })
          .replace(xe, r)
  );
  function r(e, r, n) {
    return t.format(e.charCodeAt(0), n.charCodeAt(r + 1), t);
  }
}
function ve(e) {
  return '&#x' + e.toString(16).toUpperCase() + ';';
}
const _e = {}.hasOwnProperty,
  Se = {},
  Ee = /^[^\t\n\r "#'.<=>`}]+$/,
  De = /^[^\t\n\r "'<=>`}]+$/;
function Ae(e) {
  const t = Se;
  if ('"' !== t.quote && "'" !== t.quote && null != t.quote)
    throw new Error('Invalid quote `' + t.quote + '`, expected `\'` or `"`');
  return (
    (r.peek = We),
    {
      handlers: { containerDirective: r, leafDirective: r, textDirective: r },
      unsafe: [
        { character: '\r', inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel'] },
        { character: '\n', inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel'] },
        { before: '[^:]', character: ':', after: '[A-Za-z]', inConstruct: ['phrasing'] },
        { atBreak: !0, character: ':', after: ':' },
      ],
    }
  );
  function r(e, r, i, a) {
    const o = i.createTracker(a),
      s = (function (e) {
        let t = 0;
        'containerDirective' === e.type
          ? (Y(e, function (e, r) {
              if ('containerDirective' === e.type) {
                let e = r.length,
                  n = 0;
                for (; e--; ) 'containerDirective' === r[e].type && n++;
                n > t && (t = n);
              }
            }),
            (t += 3))
          : (t = 'leafDirective' === e.type ? 2 : 1);
        return ':'.repeat(t);
      })(e),
      l = i.enter(e.type);
    let c,
      h = o.move(s + (e.name || ''));
    if ('containerDirective' === e.type) {
      const t = (e.children || [])[0];
      c = Ue(t) ? t : void 0;
    } else c = e;
    if (c && c.children && c.children.length > 0) {
      const t = i.enter('label'),
        r = `${e.type}Label`,
        n = i.enter(r);
      ((h += o.move('[')),
        (h += o.move(i.containerPhrasing(c, { ...o.current(), before: h, after: ']' }))),
        (h += o.move(']')),
        n(),
        t());
    }
    if (
      ((h += o.move(
        (function (e, r) {
          const i = e.attributes || {},
            a = [];
          let o, s, l, c;
          for (c in i)
            if (_e.call(i, c) && void 0 !== i[c] && null !== i[c]) {
              const h = String(i[c]);
              if ('id' === c)
                l = !1 !== t.preferShortcut && Ee.test(h) ? '#' + h : n('id', h, e, r);
              else if ('class' === c) {
                const i = h.split(/[\t\n\r ]+/g),
                  a = [],
                  l = [];
                let c = -1;
                for (; ++c < i.length; )
                  (!1 !== t.preferShortcut && Ee.test(i[c]) ? l : a).push(i[c]);
                ((o = a.length > 0 ? n('class', a.join(' '), e, r) : ''),
                  (s = l.length > 0 ? '.' + l.join('.') : ''));
              } else a.push(n(c, h, e, r));
            }
          o && a.unshift(o);
          s && a.unshift(s);
          l && a.unshift(l);
          return a.length > 0 ? '{' + a.join(' ') + '}' : '';
        })(e, i)
      )),
      'containerDirective' === e.type)
    ) {
      let t = e;
      (Ue((e.children || [])[0]) && (t = Object.assign({}, e, { children: e.children.slice(1) })),
        t &&
          t.children &&
          t.children.length > 0 &&
          ((h += o.move('\n')), (h += o.move(i.containerFlow(t, o.current())))),
        (h += o.move('\n' + s)));
    }
    return (l(), h);
  }
  function n(e, r, n, i) {
    if (!1 !== t.collapseEmptyAttributes && !r) return e;
    if (t.preferUnquoted && De.test(r)) return e + '=' + r;
    const a = t.quote || i.options.quote || '"',
      o = '"' === a ? "'" : '"',
      s = t.quoteSmart && Z(r, a) > Z(r, o) ? o : a;
    return (
      e +
      '=' +
      s +
      (function (e, t) {
        return we(e, Object.assign({ format: ve }, t));
      })(r, { subset: 'textDirective' === n.type ? [s] : [s, '\n', '\r'] }) +
      s
    );
  }
}
function Te(e) {
  Me.call(this, 'containerDirective', e);
}
function Fe(e) {
  Me.call(this, 'leafDirective', e);
}
function Be(e) {
  Me.call(this, 'textDirective', e);
}
function Me(e, t) {
  this.enter({ type: e, name: '', attributes: {}, children: [] }, t);
}
function Ne(e) {
  const t = this.stack[this.stack.length - 1];
  (K('containerDirective' === t.type || 'leafDirective' === t.type || 'textDirective' === t.type),
    (t.name = this.sliceSerialize(e)));
}
function Le(e) {
  this.enter({ type: 'paragraph', data: { directiveLabel: !0 }, children: [] }, e);
}
function Oe(e) {
  this.exit(e);
}
function $e() {
  ((this.data.directiveAttributes = []), this.buffer());
}
function Ie(e) {
  this.data.directiveAttributes.push(['id', ge(this.sliceSerialize(e), { attribute: !0 })]);
}
function Re(e) {
  this.data.directiveAttributes.push(['class', ge(this.sliceSerialize(e), { attribute: !0 })]);
}
function ze(e) {
  const t = this.data.directiveAttributes;
  t[t.length - 1][1] = ge(this.sliceSerialize(e), { attribute: !0 });
}
function Pe(e) {
  this.data.directiveAttributes.push([this.sliceSerialize(e), '']);
}
function je() {
  const e = this.data.directiveAttributes,
    t = {};
  let r = -1;
  for (; ++r < e.length; ) {
    const n = e[r];
    'class' === n[0] && t.class ? (t.class += ' ' + n[1]) : (t[n[0]] = n[1]);
  }
  ((this.data.directiveAttributes = void 0), this.resume());
  const n = this.stack[this.stack.length - 1];
  (K('containerDirective' === n.type || 'leafDirective' === n.type || 'textDirective' === n.type),
    (n.attributes = t));
}
function qe(e) {
  this.exit(e);
}
function We() {
  return ':';
}
function Ue(e) {
  return Boolean(e && 'paragraph' === e.type && e.data && e.data.directiveLabel);
}
function He(e, t, r, n, i, a, o, s, l, c, h, d, u, p, g) {
  let f, m;
  return function (t) {
    return (e.enter(n), e.enter(i), e.consume(t), e.exit(i), b);
  };
  function b(t) {
    return 35 === t
      ? ((f = o), y(t))
      : 46 === t
        ? ((f = s), y(t))
        : g && X(t)
          ? Q(e, b, 'whitespace')(t)
          : !g && J(t)
            ? ee(e, b)(t)
            : null === t || te(t) || re(t) || (ne(t) && 45 !== t && 95 !== t)
              ? T(t)
              : (e.enter(a), e.enter(l), e.consume(t), C);
  }
  function y(t) {
    const r = f + 'Marker';
    return (e.enter(a), e.enter(f), e.enter(r), e.consume(t), e.exit(r), x);
  }
  function x(t) {
    if (
      null === t ||
      34 === t ||
      35 === t ||
      39 === t ||
      46 === t ||
      60 === t ||
      61 === t ||
      62 === t ||
      96 === t ||
      125 === t ||
      J(t)
    )
      return r(t);
    const n = f + 'Value';
    return (e.enter(n), e.consume(t), k);
  }
  function k(t) {
    if (null === t || 34 === t || 39 === t || 60 === t || 61 === t || 62 === t || 96 === t)
      return r(t);
    if (35 === t || 46 === t || 125 === t || J(t)) {
      const r = f + 'Value';
      return (e.exit(r), e.exit(f), e.exit(a), b(t));
    }
    return (e.consume(t), k);
  }
  function C(t) {
    return null === t || te(t) || re(t) || (ne(t) && 45 !== t && 46 !== t && 58 !== t && 95 !== t)
      ? (e.exit(l), g && X(t) ? Q(e, w, 'whitespace')(t) : !g && J(t) ? ee(e, w)(t) : w(t))
      : (e.consume(t), C);
  }
  function w(t) {
    return 61 === t ? (e.enter(c), e.consume(t), e.exit(c), v) : (e.exit(a), b(t));
  }
  function v(t) {
    return null === t || 60 === t || 61 === t || 62 === t || 96 === t || 125 === t || (g && te(t))
      ? r(t)
      : 34 === t || 39 === t
        ? (e.enter(h), e.enter(u), e.consume(t), e.exit(u), (m = t), S)
        : g && X(t)
          ? Q(e, v, 'whitespace')(t)
          : !g && J(t)
            ? ee(e, v)(t)
            : (e.enter(d), e.enter(p), e.consume(t), (m = void 0), _);
  }
  function _(t) {
    return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 62 === t || 96 === t
      ? r(t)
      : 125 === t || J(t)
        ? (e.exit(p), e.exit(d), e.exit(a), b(t))
        : (e.consume(t), _);
  }
  function S(t) {
    return t === m
      ? (e.enter(u), e.consume(t), e.exit(u), e.exit(h), e.exit(a), A)
      : (e.enter(d), E(t));
  }
  function E(t) {
    return t === m
      ? (e.exit(d), S(t))
      : null === t
        ? r(t)
        : te(t)
          ? g
            ? r(t)
            : ee(e, E)(t)
          : (e.enter(p), e.consume(t), D);
  }
  function D(t) {
    return t === m || null === t || te(t) ? (e.exit(p), E(t)) : (e.consume(t), D);
  }
  function A(e) {
    return 125 === e || J(e) ? b(e) : T(e);
  }
  function T(a) {
    return 125 === a ? (e.enter(i), e.consume(a), e.exit(i), e.exit(n), t) : r(a);
  }
}
function Ge(e, t, r, n, i, a, o) {
  let s,
    l = 0,
    c = 0;
  return function (t) {
    return (e.enter(n), e.enter(i), e.consume(t), e.exit(i), h);
  };
  function h(r) {
    return 93 === r ? (e.enter(i), e.consume(r), e.exit(i), e.exit(n), t) : (e.enter(a), d(r));
  }
  function d(t) {
    if (93 === t && !c) return g(t);
    const r = e.enter('chunkText', {
      _contentTypeTextTrailing: !0,
      contentType: 'text',
      previous: s,
    });
    return (s && (s.next = r), (s = r), u(t));
  }
  function u(t) {
    return null === t || l > 999 || (91 === t && ++c > 32)
      ? r(t)
      : 93 !== t || c--
        ? te(t)
          ? o
            ? r(t)
            : (e.consume(t), e.exit('chunkText'), d)
          : (e.consume(t), 92 === t ? p : u)
        : (e.exit('chunkText'), g(t));
  }
  function p(t) {
    return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, u) : u(t);
  }
  function g(r) {
    return (e.exit(a), e.enter(i), e.consume(r), e.exit(i), e.exit(n), t);
  }
}
function Ve(e, t, r, n) {
  const i = this;
  return function (t) {
    if (null === t || te(t) || ne(t) || re(t)) return r(t);
    return (e.enter(n), e.consume(t), a);
  };
  function a(o) {
    return null === o || te(o) || re(o) || (ne(o) && 45 !== o && 95 !== o)
      ? (e.exit(n), 45 === i.previous || 95 === i.previous ? r(o) : t(o))
      : (e.consume(o), a);
  }
}
const Ze = {
    tokenize: function (e, t, r) {
      const n = this,
        i = n.events[n.events.length - 1],
        a = i && 'linePrefix' === i[1].type ? i[2].sliceSerialize(i[1], !0).length : 0;
      let o,
        s = 0;
      return function (t) {
        return (
          e.enter('directiveContainer'),
          e.enter('directiveContainerFence'),
          e.enter('directiveContainerSequence'),
          l(t)
        );
      };
      function l(t) {
        return 58 === t
          ? (e.consume(t), s++, l)
          : s < 3
            ? r(t)
            : (e.exit('directiveContainerSequence'),
              Ve.call(n, e, c, r, 'directiveContainerName')(t));
      }
      function c(t) {
        return 91 === t ? e.attempt(Ke, h, h)(t) : h(t);
      }
      function h(t) {
        return 123 === t ? e.attempt(Ye, d, d)(t) : d(t);
      }
      function d(t) {
        return Q(e, u, 'whitespace')(t);
      }
      function u(i) {
        return (
          e.exit('directiveContainerFence'),
          null === i ? w(i) : te(i) ? (n.interrupt ? t(i) : e.attempt(Xe, p, w)(i)) : r(i)
        );
      }
      function p(t) {
        return null === t
          ? w(t)
          : te(t)
            ? e.check(Xe, y, w)(t)
            : (e.enter('directiveContainerContent'), g(t));
      }
      function g(t) {
        return e.attempt({ tokenize: v, partial: !0 }, C, a ? Q(e, f, 'linePrefix', a + 1) : f)(t);
      }
      function f(t) {
        return null === t ? C(t) : te(t) ? e.check(Xe, b, C)(t) : b(t);
      }
      function m(t) {
        if (null === t) {
          const r = e.exit('chunkDocument');
          return ((n.parser.lazy[r.start.line] = !1), C(t));
        }
        return te(t) ? e.check(Xe, x, k)(t) : (e.consume(t), m);
      }
      function b(t) {
        const r = e.enter('chunkDocument', { contentType: 'document', previous: o });
        return (o && (o.next = r), (o = r), m(t));
      }
      function y(t) {
        return (e.enter('directiveContainerContent'), g(t));
      }
      function x(t) {
        e.consume(t);
        const r = e.exit('chunkDocument');
        return ((n.parser.lazy[r.start.line] = !1), g);
      }
      function k(t) {
        const r = e.exit('chunkDocument');
        return ((n.parser.lazy[r.start.line] = !1), C(t));
      }
      function C(t) {
        return (e.exit('directiveContainerContent'), w(t));
      }
      function w(r) {
        return (e.exit('directiveContainer'), t(r));
      }
      function v(e, t, r) {
        let i = 0;
        return Q(
          e,
          function (t) {
            return (
              e.enter('directiveContainerFence'),
              e.enter('directiveContainerSequence'),
              a(t)
            );
          },
          'linePrefix',
          n.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
        );
        function a(t) {
          return 58 === t
            ? (e.consume(t), i++, a)
            : i < s
              ? r(t)
              : (e.exit('directiveContainerSequence'), Q(e, o, 'whitespace')(t));
        }
        function o(n) {
          return null === n || te(n) ? (e.exit('directiveContainerFence'), t(n)) : r(n);
        }
      }
    },
    concrete: !0,
  },
  Ke = {
    tokenize: function (e, t, r) {
      return Ge(
        e,
        t,
        r,
        'directiveContainerLabel',
        'directiveContainerLabelMarker',
        'directiveContainerLabelString',
        !0
      );
    },
    partial: !0,
  },
  Ye = {
    tokenize: function (e, t, r) {
      return He(
        e,
        t,
        r,
        'directiveContainerAttributes',
        'directiveContainerAttributesMarker',
        'directiveContainerAttribute',
        'directiveContainerAttributeId',
        'directiveContainerAttributeClass',
        'directiveContainerAttributeName',
        'directiveContainerAttributeInitializerMarker',
        'directiveContainerAttributeValueLiteral',
        'directiveContainerAttributeValue',
        'directiveContainerAttributeValueMarker',
        'directiveContainerAttributeValueData',
        !0
      );
    },
    partial: !0,
  },
  Xe = {
    tokenize: function (e, t, r) {
      const n = this;
      return function (t) {
        return (e.enter('lineEnding'), e.consume(t), e.exit('lineEnding'), i);
      };
      function i(e) {
        return n.parser.lazy[n.now().line] ? r(e) : t(e);
      }
    },
    partial: !0,
  };
const Qe = {
    tokenize: function (e, t, r) {
      const n = this;
      return function (t) {
        return (e.enter('directiveLeaf'), e.enter('directiveLeafSequence'), e.consume(t), i);
      };
      function i(t) {
        return 58 === t
          ? (e.consume(t),
            e.exit('directiveLeafSequence'),
            Ve.call(n, e, a, r, 'directiveLeafName'))
          : r(t);
      }
      function a(t) {
        return 91 === t ? e.attempt(Je, o, o)(t) : o(t);
      }
      function o(t) {
        return 123 === t ? e.attempt(et, s, s)(t) : s(t);
      }
      function s(t) {
        return Q(e, l, 'whitespace')(t);
      }
      function l(n) {
        return null === n || te(n) ? (e.exit('directiveLeaf'), t(n)) : r(n);
      }
    },
  },
  Je = {
    tokenize: function (e, t, r) {
      return Ge(
        e,
        t,
        r,
        'directiveLeafLabel',
        'directiveLeafLabelMarker',
        'directiveLeafLabelString',
        !0
      );
    },
    partial: !0,
  },
  et = {
    tokenize: function (e, t, r) {
      return He(
        e,
        t,
        r,
        'directiveLeafAttributes',
        'directiveLeafAttributesMarker',
        'directiveLeafAttribute',
        'directiveLeafAttributeId',
        'directiveLeafAttributeClass',
        'directiveLeafAttributeName',
        'directiveLeafAttributeInitializerMarker',
        'directiveLeafAttributeValueLiteral',
        'directiveLeafAttributeValue',
        'directiveLeafAttributeValueMarker',
        'directiveLeafAttributeValueData',
        !0
      );
    },
    partial: !0,
  };
const tt = {
    tokenize: function (e, t, r) {
      const n = this;
      return function (t) {
        return (
          e.enter('directiveText'),
          e.enter('directiveTextMarker'),
          e.consume(t),
          e.exit('directiveTextMarker'),
          Ve.call(n, e, i, r, 'directiveTextName')
        );
      };
      function i(t) {
        return 58 === t ? r(t) : 91 === t ? e.attempt(rt, a, a)(t) : a(t);
      }
      function a(t) {
        return 123 === t ? e.attempt(nt, o, o)(t) : o(t);
      }
      function o(r) {
        return (e.exit('directiveText'), t(r));
      }
    },
    previous: function (e) {
      return 58 !== e || 'characterEscape' === this.events[this.events.length - 1][1].type;
    },
  },
  rt = {
    tokenize: function (e, t, r) {
      return Ge(
        e,
        t,
        r,
        'directiveTextLabel',
        'directiveTextLabelMarker',
        'directiveTextLabelString'
      );
    },
    partial: !0,
  },
  nt = {
    tokenize: function (e, t, r) {
      return He(
        e,
        t,
        r,
        'directiveTextAttributes',
        'directiveTextAttributesMarker',
        'directiveTextAttribute',
        'directiveTextAttributeId',
        'directiveTextAttributeClass',
        'directiveTextAttributeName',
        'directiveTextAttributeInitializerMarker',
        'directiveTextAttributeValueLiteral',
        'directiveTextAttributeValue',
        'directiveTextAttributeValueMarker',
        'directiveTextAttributeValueData'
      );
    },
    partial: !0,
  };
function it() {
  const e = this.data(),
    t = e.micromarkExtensions || (e.micromarkExtensions = []),
    r = e.fromMarkdownExtensions || (e.fromMarkdownExtensions = []),
    n = e.toMarkdownExtensions || (e.toMarkdownExtensions = []);
  (t.push({ text: { 58: tt }, flow: { 58: [Ze, Qe] } }),
    r.push({
      canContainEols: ['textDirective'],
      enter: {
        directiveContainer: Te,
        directiveContainerAttributes: $e,
        directiveContainerLabel: Le,
        directiveLeaf: Fe,
        directiveLeafAttributes: $e,
        directiveText: Be,
        directiveTextAttributes: $e,
      },
      exit: {
        directiveContainer: qe,
        directiveContainerAttributeClassValue: Re,
        directiveContainerAttributeIdValue: Ie,
        directiveContainerAttributeName: Pe,
        directiveContainerAttributeValue: ze,
        directiveContainerAttributes: je,
        directiveContainerLabel: Oe,
        directiveContainerName: Ne,
        directiveLeaf: qe,
        directiveLeafAttributeClassValue: Re,
        directiveLeafAttributeIdValue: Ie,
        directiveLeafAttributeName: Pe,
        directiveLeafAttributeValue: ze,
        directiveLeafAttributes: je,
        directiveLeafName: Ne,
        directiveText: qe,
        directiveTextAttributeClassValue: Re,
        directiveTextAttributeIdValue: Ie,
        directiveTextAttributeName: Pe,
        directiveTextAttributeValue: ze,
        directiveTextAttributes: je,
        directiveTextName: Ne,
      },
    }),
    n.push(Ae()));
}
const at = function (e, t, r) {
    const n = ie(r);
    if (!e || !e.type || !e.children) throw new Error('Expected parent node');
    if ('number' == typeof t) {
      if (t < 0 || t === Number.POSITIVE_INFINITY)
        throw new Error('Expected positive finite number as index');
    } else if ((t = e.children.indexOf(t)) < 0) throw new Error('Expected child node or index');
    for (; ++t < e.children.length; ) if (n(e.children[t], t, e)) return e.children[t];
  },
  ot = function (e) {
    if (null == e) return lt;
    if ('string' == typeof e)
      return (function (e) {
        return st(t);
        function t(t) {
          return t.tagName === e;
        }
      })(e);
    if ('object' == typeof e)
      return (function (e) {
        const t = [];
        let r = -1;
        for (; ++r < e.length; ) t[r] = ot(e[r]);
        return st(n);
        function n(...e) {
          let r = -1;
          for (; ++r < t.length; ) if (t[r].apply(this, e)) return !0;
          return !1;
        }
      })(e);
    if ('function' == typeof e) return st(e);
    throw new Error('Expected function, string, or array as `test`');
  };
function st(e) {
  return function (t, r, n) {
    return Boolean(
      (function (e) {
        return null !== e && 'object' == typeof e && 'type' in e && 'tagName' in e;
      })(t) && e.call(this, t, 'number' == typeof r ? r : void 0, n || void 0)
    );
  };
}
function lt(e) {
  return Boolean(
    e &&
    'object' == typeof e &&
    'type' in e &&
    'element' === e.type &&
    'tagName' in e &&
    'string' == typeof e.tagName
  );
}
const ct = /\n/g,
  ht = /[\t ]+/g,
  dt = ot('br'),
  ut = ot(function (e) {
    return 'td' === e.tagName || 'th' === e.tagName;
  }),
  pt = ot('p'),
  gt = ot('tr'),
  ft = ot([
    'datalist',
    'head',
    'noembed',
    'noframes',
    'noscript',
    'rp',
    'script',
    'style',
    'template',
    'title',
    function (e) {
      return Boolean((e.properties || {}).hidden);
    },
    function (e) {
      return 'dialog' === e.tagName && !(e.properties || {}).open;
    },
  ]),
  mt = ot([
    'address',
    'article',
    'aside',
    'blockquote',
    'body',
    'caption',
    'center',
    'dd',
    'dialog',
    'dir',
    'dl',
    'dt',
    'div',
    'figure',
    'figcaption',
    'footer',
    'form,',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'hr',
    'html',
    'legend',
    'li',
    'listing',
    'main',
    'menu',
    'nav',
    'ol',
    'p',
    'plaintext',
    'pre',
    'section',
    'ul',
    'xmp',
  ]);
function bt(e, t, r) {
  return 'element' === e.type
    ? (function (e, t, r) {
        const n = kt(e, r),
          i = e.children || [];
        let a,
          o,
          s = -1,
          l = [];
        if (ft(e)) return l;
        dt(e) || (gt(e) && at(t, e, gt))
          ? (o = '\n')
          : pt(e)
            ? ((a = 2), (o = 2))
            : mt(e) && ((a = 1), (o = 1));
        for (; ++s < i.length; )
          l = l.concat(
            bt(i[s], e, {
              whitespace: n,
              breakBefore: s ? void 0 : a,
              breakAfter: s < i.length - 1 ? dt(i[s + 1]) : o,
            })
          );
        ut(e) && at(t, e, ut) && l.push('\t');
        a && l.unshift(a);
        o && l.push(o);
        return l;
      })(e, t, r)
    : 'text' === e.type
      ? 'normal' === r.whitespace
        ? yt(e, r)
        : (function (e) {
            return [String(e.value)];
          })(e)
      : [];
}
function yt(e, t) {
  const r = String(e.value),
    n = [],
    i = [];
  let a = 0;
  for (; a <= r.length; ) {
    ct.lastIndex = a;
    const e = ct.exec(r),
      i = e && 'index' in e ? e.index : r.length;
    (n.push(
      xt(
        r.slice(a, i).replace(/[\u061C\u200E\u200F\u202A-\u202E\u2066-\u2069]/g, ''),
        0 !== a || t.breakBefore,
        i !== r.length || t.breakAfter
      )
    ),
      (a = i + 1));
  }
  let o,
    s = -1;
  for (; ++s < n.length; )
    8203 === n[s].charCodeAt(n[s].length - 1) ||
    (s < n.length - 1 && 8203 === n[s + 1].charCodeAt(0))
      ? (i.push(n[s]), (o = void 0))
      : n[s]
        ? ('number' == typeof o && i.push(o), i.push(n[s]), (o = 0))
        : (0 !== s && s !== n.length - 1) || i.push(0);
  return i;
}
function xt(e, t, r) {
  const n = [];
  let i,
    a = 0;
  for (; a < e.length; ) {
    ht.lastIndex = a;
    const r = ht.exec(e);
    ((i = r ? r.index : e.length),
      a || i || !r || t || n.push(''),
      a !== i && n.push(e.slice(a, i)),
      (a = r ? i + r[0].length : i));
  }
  return (a === i || r || n.push(''), n.join(' '));
}
function kt(e, t) {
  if ('element' === e.type) {
    const r = e.properties || {};
    switch (e.tagName) {
      case 'listing':
      case 'plaintext':
      case 'xmp':
        return 'pre';
      case 'nobr':
        return 'nowrap';
      case 'pre':
        return r.wrap ? 'pre-wrap' : 'pre';
      case 'td':
      case 'th':
        return r.noWrap ? 'nowrap' : t.whitespace;
      case 'textarea':
        return 'pre-wrap';
    }
  }
  return t.whitespace;
}
const Ct = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'picture',
    'q',
    'quote',
    'samp',
    'section',
    'select',
    'source',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video',
    'defs',
    'g',
    'marker',
    'mask',
    'pattern',
    'svg',
    'switch',
    'symbol',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feFlood',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMorphology',
    'feOffset',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
    'linearGradient',
    'radialGradient',
    'stop',
    'circle',
    'ellipse',
    'image',
    'line',
    'path',
    'polygon',
    'polyline',
    'rect',
    'text',
    'use',
    'textPath',
    'tspan',
    'foreignObject',
    'clipPath',
  ],
  wt = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height',
  ]
    .sort()
    .reverse(),
  vt = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where',
  ]
    .sort()
    .reverse(),
  _t = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error',
  ]
    .sort()
    .reverse(),
  St = [
    'accent-color',
    'align-content',
    'align-items',
    'align-self',
    'alignment-baseline',
    'all',
    'anchor-name',
    'animation',
    'animation-composition',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-range',
    'animation-range-end',
    'animation-range-start',
    'animation-timeline',
    'animation-timing-function',
    'appearance',
    'aspect-ratio',
    'backdrop-filter',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-blend-mode',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-position-x',
    'background-position-y',
    'background-repeat',
    'background-size',
    'baseline-shift',
    'block-size',
    'border',
    'border-block',
    'border-block-color',
    'border-block-end',
    'border-block-end-color',
    'border-block-end-style',
    'border-block-end-width',
    'border-block-start',
    'border-block-start-color',
    'border-block-start-style',
    'border-block-start-width',
    'border-block-style',
    'border-block-width',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-end-end-radius',
    'border-end-start-radius',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-inline',
    'border-inline-color',
    'border-inline-end',
    'border-inline-end-color',
    'border-inline-end-style',
    'border-inline-end-width',
    'border-inline-start',
    'border-inline-start-color',
    'border-inline-start-style',
    'border-inline-start-width',
    'border-inline-style',
    'border-inline-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-start-end-radius',
    'border-start-start-radius',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-align',
    'box-decoration-break',
    'box-direction',
    'box-flex',
    'box-flex-group',
    'box-lines',
    'box-ordinal-group',
    'box-orient',
    'box-pack',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'caret-color',
    'clear',
    'clip',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'color-scheme',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'contain',
    'contain-intrinsic-block-size',
    'contain-intrinsic-height',
    'contain-intrinsic-inline-size',
    'contain-intrinsic-size',
    'contain-intrinsic-width',
    'container',
    'container-name',
    'container-type',
    'content',
    'content-visibility',
    'counter-increment',
    'counter-reset',
    'counter-set',
    'cue',
    'cue-after',
    'cue-before',
    'cursor',
    'cx',
    'cy',
    'direction',
    'display',
    'dominant-baseline',
    'empty-cells',
    'enable-background',
    'field-sizing',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'flood-color',
    'flood-opacity',
    'flow',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-optical-sizing',
    'font-palette',
    'font-size',
    'font-size-adjust',
    'font-smooth',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-synthesis',
    'font-synthesis-position',
    'font-synthesis-small-caps',
    'font-synthesis-style',
    'font-synthesis-weight',
    'font-variant',
    'font-variant-alternates',
    'font-variant-caps',
    'font-variant-east-asian',
    'font-variant-emoji',
    'font-variant-ligatures',
    'font-variant-numeric',
    'font-variant-position',
    'font-variation-settings',
    'font-weight',
    'forced-color-adjust',
    'gap',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'grid',
    'grid-area',
    'grid-auto-columns',
    'grid-auto-flow',
    'grid-auto-rows',
    'grid-column',
    'grid-column-end',
    'grid-column-start',
    'grid-gap',
    'grid-row',
    'grid-row-end',
    'grid-row-start',
    'grid-template',
    'grid-template-areas',
    'grid-template-columns',
    'grid-template-rows',
    'hanging-punctuation',
    'height',
    'hyphenate-character',
    'hyphenate-limit-chars',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'initial-letter',
    'initial-letter-align',
    'inline-size',
    'inset',
    'inset-area',
    'inset-block',
    'inset-block-end',
    'inset-block-start',
    'inset-inline',
    'inset-inline-end',
    'inset-inline-start',
    'isolation',
    'justify-content',
    'justify-items',
    'justify-self',
    'kerning',
    'left',
    'letter-spacing',
    'lighting-color',
    'line-break',
    'line-height',
    'line-height-step',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-block',
    'margin-block-end',
    'margin-block-start',
    'margin-bottom',
    'margin-inline',
    'margin-inline-end',
    'margin-inline-start',
    'margin-left',
    'margin-right',
    'margin-top',
    'margin-trim',
    'marker',
    'marker-end',
    'marker-mid',
    'marker-start',
    'marks',
    'mask',
    'mask-border',
    'mask-border-mode',
    'mask-border-outset',
    'mask-border-repeat',
    'mask-border-slice',
    'mask-border-source',
    'mask-border-width',
    'mask-clip',
    'mask-composite',
    'mask-image',
    'mask-mode',
    'mask-origin',
    'mask-position',
    'mask-repeat',
    'mask-size',
    'mask-type',
    'masonry-auto-flow',
    'math-depth',
    'math-shift',
    'math-style',
    'max-block-size',
    'max-height',
    'max-inline-size',
    'max-width',
    'min-block-size',
    'min-height',
    'min-inline-size',
    'min-width',
    'mix-blend-mode',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'offset',
    'offset-anchor',
    'offset-distance',
    'offset-path',
    'offset-position',
    'offset-rotate',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-anchor',
    'overflow-block',
    'overflow-clip-margin',
    'overflow-inline',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'overlay',
    'overscroll-behavior',
    'overscroll-behavior-block',
    'overscroll-behavior-inline',
    'overscroll-behavior-x',
    'overscroll-behavior-y',
    'padding',
    'padding-block',
    'padding-block-end',
    'padding-block-start',
    'padding-bottom',
    'padding-inline',
    'padding-inline-end',
    'padding-inline-start',
    'padding-left',
    'padding-right',
    'padding-top',
    'page',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'paint-order',
    'pause',
    'pause-after',
    'pause-before',
    'perspective',
    'perspective-origin',
    'place-content',
    'place-items',
    'place-self',
    'pointer-events',
    'position',
    'position-anchor',
    'position-visibility',
    'print-color-adjust',
    'quotes',
    'r',
    'resize',
    'rest',
    'rest-after',
    'rest-before',
    'right',
    'rotate',
    'row-gap',
    'ruby-align',
    'ruby-position',
    'scale',
    'scroll-behavior',
    'scroll-margin',
    'scroll-margin-block',
    'scroll-margin-block-end',
    'scroll-margin-block-start',
    'scroll-margin-bottom',
    'scroll-margin-inline',
    'scroll-margin-inline-end',
    'scroll-margin-inline-start',
    'scroll-margin-left',
    'scroll-margin-right',
    'scroll-margin-top',
    'scroll-padding',
    'scroll-padding-block',
    'scroll-padding-block-end',
    'scroll-padding-block-start',
    'scroll-padding-bottom',
    'scroll-padding-inline',
    'scroll-padding-inline-end',
    'scroll-padding-inline-start',
    'scroll-padding-left',
    'scroll-padding-right',
    'scroll-padding-top',
    'scroll-snap-align',
    'scroll-snap-stop',
    'scroll-snap-type',
    'scroll-timeline',
    'scroll-timeline-axis',
    'scroll-timeline-name',
    'scrollbar-color',
    'scrollbar-gutter',
    'scrollbar-width',
    'shape-image-threshold',
    'shape-margin',
    'shape-outside',
    'shape-rendering',
    'speak',
    'speak-as',
    'src',
    'stop-color',
    'stop-opacity',
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-all',
    'text-align-last',
    'text-anchor',
    'text-combine-upright',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-skip',
    'text-decoration-skip-ink',
    'text-decoration-style',
    'text-decoration-thickness',
    'text-emphasis',
    'text-emphasis-color',
    'text-emphasis-position',
    'text-emphasis-style',
    'text-indent',
    'text-justify',
    'text-orientation',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-size-adjust',
    'text-transform',
    'text-underline-offset',
    'text-underline-position',
    'text-wrap',
    'text-wrap-mode',
    'text-wrap-style',
    'timeline-scope',
    'top',
    'touch-action',
    'transform',
    'transform-box',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-behavior',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'translate',
    'unicode-bidi',
    'user-modify',
    'user-select',
    'vector-effect',
    'vertical-align',
    'view-timeline',
    'view-timeline-axis',
    'view-timeline-inset',
    'view-timeline-name',
    'view-transition-name',
    'visibility',
    'voice-balance',
    'voice-duration',
    'voice-family',
    'voice-pitch',
    'voice-range',
    'voice-rate',
    'voice-stress',
    'voice-volume',
    'white-space',
    'white-space-collapse',
    'widows',
    'width',
    'will-change',
    'word-break',
    'word-spacing',
    'word-wrap',
    'writing-mode',
    'x',
    'y',
    'z-index',
    'zoom',
  ]
    .sort()
    .reverse();
var Et = '[0-9](_*[0-9])*',
  Dt = `\\.(${Et})`,
  At = '[0-9a-fA-F](_*[0-9a-fA-F])*',
  Tt = {
    className: 'number',
    variants: [
      { begin: `(\\b(${Et})((${Dt})|\\.)?|(${Dt}))[eE][+-]?(${Et})[fFdD]?\\b` },
      { begin: `\\b(${Et})((${Dt})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${Dt})[fFdD]?\\b` },
      { begin: `\\b(${Et})[fFdD]\\b` },
      { begin: `\\b0[xX]((${At})\\.?|(${At})?\\.(${At}))[pP][+-]?(${Et})[fFdD]?\\b` },
      { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
      { begin: `\\b0[xX](${At})[lL]?\\b` },
      { begin: '\\b0(_*[0-7])*[lL]?\\b' },
      { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
    ],
    relevance: 0,
  };
function Ft(e, t, r) {
  return -1 === r ? '' : e.replace(t, (n) => Ft(e, t, r - 1));
}
const Bt = '[A-Za-z$_][0-9A-Za-z$_]*',
  Mt = [
    'as',
    'in',
    'of',
    'if',
    'for',
    'while',
    'finally',
    'var',
    'new',
    'function',
    'do',
    'return',
    'void',
    'else',
    'break',
    'catch',
    'instanceof',
    'with',
    'throw',
    'case',
    'default',
    'try',
    'switch',
    'continue',
    'typeof',
    'delete',
    'let',
    'yield',
    'const',
    'class',
    'debugger',
    'async',
    'await',
    'static',
    'import',
    'from',
    'export',
    'extends',
    'using',
  ],
  Nt = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'],
  Lt = [
    'Object',
    'Function',
    'Boolean',
    'Symbol',
    'Math',
    'Date',
    'Number',
    'BigInt',
    'String',
    'RegExp',
    'Array',
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Int32Array',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array',
    'Set',
    'Map',
    'WeakSet',
    'WeakMap',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'Atomics',
    'DataView',
    'JSON',
    'Promise',
    'Generator',
    'GeneratorFunction',
    'AsyncFunction',
    'Reflect',
    'Proxy',
    'Intl',
    'WebAssembly',
  ],
  Ot = [
    'Error',
    'EvalError',
    'InternalError',
    'RangeError',
    'ReferenceError',
    'SyntaxError',
    'TypeError',
    'URIError',
  ],
  $t = [
    'setInterval',
    'setTimeout',
    'clearInterval',
    'clearTimeout',
    'require',
    'exports',
    'eval',
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'escape',
    'unescape',
  ],
  It = [
    'arguments',
    'this',
    'super',
    'console',
    'window',
    'document',
    'localStorage',
    'sessionStorage',
    'module',
    'global',
  ],
  Rt = [].concat($t, Lt, Ot);
var zt = '[0-9](_*[0-9])*',
  Pt = `\\.(${zt})`,
  jt = '[0-9a-fA-F](_*[0-9a-fA-F])*',
  qt = {
    className: 'number',
    variants: [
      { begin: `(\\b(${zt})((${Pt})|\\.)?|(${Pt}))[eE][+-]?(${zt})[fFdD]?\\b` },
      { begin: `\\b(${zt})((${Pt})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
      { begin: `(${Pt})[fFdD]?\\b` },
      { begin: `\\b(${zt})[fFdD]\\b` },
      { begin: `\\b0[xX]((${jt})\\.?|(${jt})?\\.(${jt}))[pP][+-]?(${zt})[fFdD]?\\b` },
      { begin: '\\b(0|[1-9](_*[0-9])*)[lL]?\\b' },
      { begin: `\\b0[xX](${jt})[lL]?\\b` },
      { begin: '\\b0(_*[0-7])*[lL]?\\b' },
      { begin: '\\b0[bB][01](_*[01])*[lL]?\\b' },
    ],
    relevance: 0,
  };
const Wt = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'picture',
    'q',
    'quote',
    'samp',
    'section',
    'select',
    'source',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video',
    'defs',
    'g',
    'marker',
    'mask',
    'pattern',
    'svg',
    'switch',
    'symbol',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feFlood',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMorphology',
    'feOffset',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
    'linearGradient',
    'radialGradient',
    'stop',
    'circle',
    'ellipse',
    'image',
    'line',
    'path',
    'polygon',
    'polyline',
    'rect',
    'text',
    'use',
    'textPath',
    'tspan',
    'foreignObject',
    'clipPath',
  ],
  Ut = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height',
  ]
    .sort()
    .reverse(),
  Ht = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where',
  ]
    .sort()
    .reverse(),
  Gt = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error',
  ]
    .sort()
    .reverse(),
  Vt = [
    'accent-color',
    'align-content',
    'align-items',
    'align-self',
    'alignment-baseline',
    'all',
    'anchor-name',
    'animation',
    'animation-composition',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-range',
    'animation-range-end',
    'animation-range-start',
    'animation-timeline',
    'animation-timing-function',
    'appearance',
    'aspect-ratio',
    'backdrop-filter',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-blend-mode',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-position-x',
    'background-position-y',
    'background-repeat',
    'background-size',
    'baseline-shift',
    'block-size',
    'border',
    'border-block',
    'border-block-color',
    'border-block-end',
    'border-block-end-color',
    'border-block-end-style',
    'border-block-end-width',
    'border-block-start',
    'border-block-start-color',
    'border-block-start-style',
    'border-block-start-width',
    'border-block-style',
    'border-block-width',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-end-end-radius',
    'border-end-start-radius',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-inline',
    'border-inline-color',
    'border-inline-end',
    'border-inline-end-color',
    'border-inline-end-style',
    'border-inline-end-width',
    'border-inline-start',
    'border-inline-start-color',
    'border-inline-start-style',
    'border-inline-start-width',
    'border-inline-style',
    'border-inline-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-start-end-radius',
    'border-start-start-radius',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-align',
    'box-decoration-break',
    'box-direction',
    'box-flex',
    'box-flex-group',
    'box-lines',
    'box-ordinal-group',
    'box-orient',
    'box-pack',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'caret-color',
    'clear',
    'clip',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'color-scheme',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'contain',
    'contain-intrinsic-block-size',
    'contain-intrinsic-height',
    'contain-intrinsic-inline-size',
    'contain-intrinsic-size',
    'contain-intrinsic-width',
    'container',
    'container-name',
    'container-type',
    'content',
    'content-visibility',
    'counter-increment',
    'counter-reset',
    'counter-set',
    'cue',
    'cue-after',
    'cue-before',
    'cursor',
    'cx',
    'cy',
    'direction',
    'display',
    'dominant-baseline',
    'empty-cells',
    'enable-background',
    'field-sizing',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'flood-color',
    'flood-opacity',
    'flow',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-optical-sizing',
    'font-palette',
    'font-size',
    'font-size-adjust',
    'font-smooth',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-synthesis',
    'font-synthesis-position',
    'font-synthesis-small-caps',
    'font-synthesis-style',
    'font-synthesis-weight',
    'font-variant',
    'font-variant-alternates',
    'font-variant-caps',
    'font-variant-east-asian',
    'font-variant-emoji',
    'font-variant-ligatures',
    'font-variant-numeric',
    'font-variant-position',
    'font-variation-settings',
    'font-weight',
    'forced-color-adjust',
    'gap',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'grid',
    'grid-area',
    'grid-auto-columns',
    'grid-auto-flow',
    'grid-auto-rows',
    'grid-column',
    'grid-column-end',
    'grid-column-start',
    'grid-gap',
    'grid-row',
    'grid-row-end',
    'grid-row-start',
    'grid-template',
    'grid-template-areas',
    'grid-template-columns',
    'grid-template-rows',
    'hanging-punctuation',
    'height',
    'hyphenate-character',
    'hyphenate-limit-chars',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'initial-letter',
    'initial-letter-align',
    'inline-size',
    'inset',
    'inset-area',
    'inset-block',
    'inset-block-end',
    'inset-block-start',
    'inset-inline',
    'inset-inline-end',
    'inset-inline-start',
    'isolation',
    'justify-content',
    'justify-items',
    'justify-self',
    'kerning',
    'left',
    'letter-spacing',
    'lighting-color',
    'line-break',
    'line-height',
    'line-height-step',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-block',
    'margin-block-end',
    'margin-block-start',
    'margin-bottom',
    'margin-inline',
    'margin-inline-end',
    'margin-inline-start',
    'margin-left',
    'margin-right',
    'margin-top',
    'margin-trim',
    'marker',
    'marker-end',
    'marker-mid',
    'marker-start',
    'marks',
    'mask',
    'mask-border',
    'mask-border-mode',
    'mask-border-outset',
    'mask-border-repeat',
    'mask-border-slice',
    'mask-border-source',
    'mask-border-width',
    'mask-clip',
    'mask-composite',
    'mask-image',
    'mask-mode',
    'mask-origin',
    'mask-position',
    'mask-repeat',
    'mask-size',
    'mask-type',
    'masonry-auto-flow',
    'math-depth',
    'math-shift',
    'math-style',
    'max-block-size',
    'max-height',
    'max-inline-size',
    'max-width',
    'min-block-size',
    'min-height',
    'min-inline-size',
    'min-width',
    'mix-blend-mode',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'offset',
    'offset-anchor',
    'offset-distance',
    'offset-path',
    'offset-position',
    'offset-rotate',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-anchor',
    'overflow-block',
    'overflow-clip-margin',
    'overflow-inline',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'overlay',
    'overscroll-behavior',
    'overscroll-behavior-block',
    'overscroll-behavior-inline',
    'overscroll-behavior-x',
    'overscroll-behavior-y',
    'padding',
    'padding-block',
    'padding-block-end',
    'padding-block-start',
    'padding-bottom',
    'padding-inline',
    'padding-inline-end',
    'padding-inline-start',
    'padding-left',
    'padding-right',
    'padding-top',
    'page',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'paint-order',
    'pause',
    'pause-after',
    'pause-before',
    'perspective',
    'perspective-origin',
    'place-content',
    'place-items',
    'place-self',
    'pointer-events',
    'position',
    'position-anchor',
    'position-visibility',
    'print-color-adjust',
    'quotes',
    'r',
    'resize',
    'rest',
    'rest-after',
    'rest-before',
    'right',
    'rotate',
    'row-gap',
    'ruby-align',
    'ruby-position',
    'scale',
    'scroll-behavior',
    'scroll-margin',
    'scroll-margin-block',
    'scroll-margin-block-end',
    'scroll-margin-block-start',
    'scroll-margin-bottom',
    'scroll-margin-inline',
    'scroll-margin-inline-end',
    'scroll-margin-inline-start',
    'scroll-margin-left',
    'scroll-margin-right',
    'scroll-margin-top',
    'scroll-padding',
    'scroll-padding-block',
    'scroll-padding-block-end',
    'scroll-padding-block-start',
    'scroll-padding-bottom',
    'scroll-padding-inline',
    'scroll-padding-inline-end',
    'scroll-padding-inline-start',
    'scroll-padding-left',
    'scroll-padding-right',
    'scroll-padding-top',
    'scroll-snap-align',
    'scroll-snap-stop',
    'scroll-snap-type',
    'scroll-timeline',
    'scroll-timeline-axis',
    'scroll-timeline-name',
    'scrollbar-color',
    'scrollbar-gutter',
    'scrollbar-width',
    'shape-image-threshold',
    'shape-margin',
    'shape-outside',
    'shape-rendering',
    'speak',
    'speak-as',
    'src',
    'stop-color',
    'stop-opacity',
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-all',
    'text-align-last',
    'text-anchor',
    'text-combine-upright',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-skip',
    'text-decoration-skip-ink',
    'text-decoration-style',
    'text-decoration-thickness',
    'text-emphasis',
    'text-emphasis-color',
    'text-emphasis-position',
    'text-emphasis-style',
    'text-indent',
    'text-justify',
    'text-orientation',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-size-adjust',
    'text-transform',
    'text-underline-offset',
    'text-underline-position',
    'text-wrap',
    'text-wrap-mode',
    'text-wrap-style',
    'timeline-scope',
    'top',
    'touch-action',
    'transform',
    'transform-box',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-behavior',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'translate',
    'unicode-bidi',
    'user-modify',
    'user-select',
    'vector-effect',
    'vertical-align',
    'view-timeline',
    'view-timeline-axis',
    'view-timeline-inset',
    'view-timeline-name',
    'view-transition-name',
    'visibility',
    'voice-balance',
    'voice-duration',
    'voice-family',
    'voice-pitch',
    'voice-range',
    'voice-rate',
    'voice-stress',
    'voice-volume',
    'white-space',
    'white-space-collapse',
    'widows',
    'width',
    'will-change',
    'word-break',
    'word-spacing',
    'word-wrap',
    'writing-mode',
    'x',
    'y',
    'z-index',
    'zoom',
  ]
    .sort()
    .reverse(),
  Zt = Ht.concat(Gt).sort().reverse();
const Kt = [
    'a',
    'abbr',
    'address',
    'article',
    'aside',
    'audio',
    'b',
    'blockquote',
    'body',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'dd',
    'del',
    'details',
    'dfn',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'header',
    'hgroup',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'mark',
    'menu',
    'nav',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'picture',
    'q',
    'quote',
    'samp',
    'section',
    'select',
    'source',
    'span',
    'strong',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'ul',
    'var',
    'video',
    'defs',
    'g',
    'marker',
    'mask',
    'pattern',
    'svg',
    'switch',
    'symbol',
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feFlood',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMorphology',
    'feOffset',
    'feSpecularLighting',
    'feTile',
    'feTurbulence',
    'linearGradient',
    'radialGradient',
    'stop',
    'circle',
    'ellipse',
    'image',
    'line',
    'path',
    'polygon',
    'polyline',
    'rect',
    'text',
    'use',
    'textPath',
    'tspan',
    'foreignObject',
    'clipPath',
  ],
  Yt = [
    'any-hover',
    'any-pointer',
    'aspect-ratio',
    'color',
    'color-gamut',
    'color-index',
    'device-aspect-ratio',
    'device-height',
    'device-width',
    'display-mode',
    'forced-colors',
    'grid',
    'height',
    'hover',
    'inverted-colors',
    'monochrome',
    'orientation',
    'overflow-block',
    'overflow-inline',
    'pointer',
    'prefers-color-scheme',
    'prefers-contrast',
    'prefers-reduced-motion',
    'prefers-reduced-transparency',
    'resolution',
    'scan',
    'scripting',
    'update',
    'width',
    'min-width',
    'max-width',
    'min-height',
    'max-height',
  ]
    .sort()
    .reverse(),
  Xt = [
    'active',
    'any-link',
    'blank',
    'checked',
    'current',
    'default',
    'defined',
    'dir',
    'disabled',
    'drop',
    'empty',
    'enabled',
    'first',
    'first-child',
    'first-of-type',
    'fullscreen',
    'future',
    'focus',
    'focus-visible',
    'focus-within',
    'has',
    'host',
    'host-context',
    'hover',
    'indeterminate',
    'in-range',
    'invalid',
    'is',
    'lang',
    'last-child',
    'last-of-type',
    'left',
    'link',
    'local-link',
    'not',
    'nth-child',
    'nth-col',
    'nth-last-child',
    'nth-last-col',
    'nth-last-of-type',
    'nth-of-type',
    'only-child',
    'only-of-type',
    'optional',
    'out-of-range',
    'past',
    'placeholder-shown',
    'read-only',
    'read-write',
    'required',
    'right',
    'root',
    'scope',
    'target',
    'target-within',
    'user-invalid',
    'valid',
    'visited',
    'where',
  ]
    .sort()
    .reverse(),
  Qt = [
    'after',
    'backdrop',
    'before',
    'cue',
    'cue-region',
    'first-letter',
    'first-line',
    'grammar-error',
    'marker',
    'part',
    'placeholder',
    'selection',
    'slotted',
    'spelling-error',
  ]
    .sort()
    .reverse(),
  Jt = [
    'accent-color',
    'align-content',
    'align-items',
    'align-self',
    'alignment-baseline',
    'all',
    'anchor-name',
    'animation',
    'animation-composition',
    'animation-delay',
    'animation-direction',
    'animation-duration',
    'animation-fill-mode',
    'animation-iteration-count',
    'animation-name',
    'animation-play-state',
    'animation-range',
    'animation-range-end',
    'animation-range-start',
    'animation-timeline',
    'animation-timing-function',
    'appearance',
    'aspect-ratio',
    'backdrop-filter',
    'backface-visibility',
    'background',
    'background-attachment',
    'background-blend-mode',
    'background-clip',
    'background-color',
    'background-image',
    'background-origin',
    'background-position',
    'background-position-x',
    'background-position-y',
    'background-repeat',
    'background-size',
    'baseline-shift',
    'block-size',
    'border',
    'border-block',
    'border-block-color',
    'border-block-end',
    'border-block-end-color',
    'border-block-end-style',
    'border-block-end-width',
    'border-block-start',
    'border-block-start-color',
    'border-block-start-style',
    'border-block-start-width',
    'border-block-style',
    'border-block-width',
    'border-bottom',
    'border-bottom-color',
    'border-bottom-left-radius',
    'border-bottom-right-radius',
    'border-bottom-style',
    'border-bottom-width',
    'border-collapse',
    'border-color',
    'border-end-end-radius',
    'border-end-start-radius',
    'border-image',
    'border-image-outset',
    'border-image-repeat',
    'border-image-slice',
    'border-image-source',
    'border-image-width',
    'border-inline',
    'border-inline-color',
    'border-inline-end',
    'border-inline-end-color',
    'border-inline-end-style',
    'border-inline-end-width',
    'border-inline-start',
    'border-inline-start-color',
    'border-inline-start-style',
    'border-inline-start-width',
    'border-inline-style',
    'border-inline-width',
    'border-left',
    'border-left-color',
    'border-left-style',
    'border-left-width',
    'border-radius',
    'border-right',
    'border-right-color',
    'border-right-style',
    'border-right-width',
    'border-spacing',
    'border-start-end-radius',
    'border-start-start-radius',
    'border-style',
    'border-top',
    'border-top-color',
    'border-top-left-radius',
    'border-top-right-radius',
    'border-top-style',
    'border-top-width',
    'border-width',
    'bottom',
    'box-align',
    'box-decoration-break',
    'box-direction',
    'box-flex',
    'box-flex-group',
    'box-lines',
    'box-ordinal-group',
    'box-orient',
    'box-pack',
    'box-shadow',
    'box-sizing',
    'break-after',
    'break-before',
    'break-inside',
    'caption-side',
    'caret-color',
    'clear',
    'clip',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'color-scheme',
    'column-count',
    'column-fill',
    'column-gap',
    'column-rule',
    'column-rule-color',
    'column-rule-style',
    'column-rule-width',
    'column-span',
    'column-width',
    'columns',
    'contain',
    'contain-intrinsic-block-size',
    'contain-intrinsic-height',
    'contain-intrinsic-inline-size',
    'contain-intrinsic-size',
    'contain-intrinsic-width',
    'container',
    'container-name',
    'container-type',
    'content',
    'content-visibility',
    'counter-increment',
    'counter-reset',
    'counter-set',
    'cue',
    'cue-after',
    'cue-before',
    'cursor',
    'cx',
    'cy',
    'direction',
    'display',
    'dominant-baseline',
    'empty-cells',
    'enable-background',
    'field-sizing',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'flex',
    'flex-basis',
    'flex-direction',
    'flex-flow',
    'flex-grow',
    'flex-shrink',
    'flex-wrap',
    'float',
    'flood-color',
    'flood-opacity',
    'flow',
    'font',
    'font-display',
    'font-family',
    'font-feature-settings',
    'font-kerning',
    'font-language-override',
    'font-optical-sizing',
    'font-palette',
    'font-size',
    'font-size-adjust',
    'font-smooth',
    'font-smoothing',
    'font-stretch',
    'font-style',
    'font-synthesis',
    'font-synthesis-position',
    'font-synthesis-small-caps',
    'font-synthesis-style',
    'font-synthesis-weight',
    'font-variant',
    'font-variant-alternates',
    'font-variant-caps',
    'font-variant-east-asian',
    'font-variant-emoji',
    'font-variant-ligatures',
    'font-variant-numeric',
    'font-variant-position',
    'font-variation-settings',
    'font-weight',
    'forced-color-adjust',
    'gap',
    'glyph-orientation-horizontal',
    'glyph-orientation-vertical',
    'grid',
    'grid-area',
    'grid-auto-columns',
    'grid-auto-flow',
    'grid-auto-rows',
    'grid-column',
    'grid-column-end',
    'grid-column-start',
    'grid-gap',
    'grid-row',
    'grid-row-end',
    'grid-row-start',
    'grid-template',
    'grid-template-areas',
    'grid-template-columns',
    'grid-template-rows',
    'hanging-punctuation',
    'height',
    'hyphenate-character',
    'hyphenate-limit-chars',
    'hyphens',
    'icon',
    'image-orientation',
    'image-rendering',
    'image-resolution',
    'ime-mode',
    'initial-letter',
    'initial-letter-align',
    'inline-size',
    'inset',
    'inset-area',
    'inset-block',
    'inset-block-end',
    'inset-block-start',
    'inset-inline',
    'inset-inline-end',
    'inset-inline-start',
    'isolation',
    'justify-content',
    'justify-items',
    'justify-self',
    'kerning',
    'left',
    'letter-spacing',
    'lighting-color',
    'line-break',
    'line-height',
    'line-height-step',
    'list-style',
    'list-style-image',
    'list-style-position',
    'list-style-type',
    'margin',
    'margin-block',
    'margin-block-end',
    'margin-block-start',
    'margin-bottom',
    'margin-inline',
    'margin-inline-end',
    'margin-inline-start',
    'margin-left',
    'margin-right',
    'margin-top',
    'margin-trim',
    'marker',
    'marker-end',
    'marker-mid',
    'marker-start',
    'marks',
    'mask',
    'mask-border',
    'mask-border-mode',
    'mask-border-outset',
    'mask-border-repeat',
    'mask-border-slice',
    'mask-border-source',
    'mask-border-width',
    'mask-clip',
    'mask-composite',
    'mask-image',
    'mask-mode',
    'mask-origin',
    'mask-position',
    'mask-repeat',
    'mask-size',
    'mask-type',
    'masonry-auto-flow',
    'math-depth',
    'math-shift',
    'math-style',
    'max-block-size',
    'max-height',
    'max-inline-size',
    'max-width',
    'min-block-size',
    'min-height',
    'min-inline-size',
    'min-width',
    'mix-blend-mode',
    'nav-down',
    'nav-index',
    'nav-left',
    'nav-right',
    'nav-up',
    'none',
    'normal',
    'object-fit',
    'object-position',
    'offset',
    'offset-anchor',
    'offset-distance',
    'offset-path',
    'offset-position',
    'offset-rotate',
    'opacity',
    'order',
    'orphans',
    'outline',
    'outline-color',
    'outline-offset',
    'outline-style',
    'outline-width',
    'overflow',
    'overflow-anchor',
    'overflow-block',
    'overflow-clip-margin',
    'overflow-inline',
    'overflow-wrap',
    'overflow-x',
    'overflow-y',
    'overlay',
    'overscroll-behavior',
    'overscroll-behavior-block',
    'overscroll-behavior-inline',
    'overscroll-behavior-x',
    'overscroll-behavior-y',
    'padding',
    'padding-block',
    'padding-block-end',
    'padding-block-start',
    'padding-bottom',
    'padding-inline',
    'padding-inline-end',
    'padding-inline-start',
    'padding-left',
    'padding-right',
    'padding-top',
    'page',
    'page-break-after',
    'page-break-before',
    'page-break-inside',
    'paint-order',
    'pause',
    'pause-after',
    'pause-before',
    'perspective',
    'perspective-origin',
    'place-content',
    'place-items',
    'place-self',
    'pointer-events',
    'position',
    'position-anchor',
    'position-visibility',
    'print-color-adjust',
    'quotes',
    'r',
    'resize',
    'rest',
    'rest-after',
    'rest-before',
    'right',
    'rotate',
    'row-gap',
    'ruby-align',
    'ruby-position',
    'scale',
    'scroll-behavior',
    'scroll-margin',
    'scroll-margin-block',
    'scroll-margin-block-end',
    'scroll-margin-block-start',
    'scroll-margin-bottom',
    'scroll-margin-inline',
    'scroll-margin-inline-end',
    'scroll-margin-inline-start',
    'scroll-margin-left',
    'scroll-margin-right',
    'scroll-margin-top',
    'scroll-padding',
    'scroll-padding-block',
    'scroll-padding-block-end',
    'scroll-padding-block-start',
    'scroll-padding-bottom',
    'scroll-padding-inline',
    'scroll-padding-inline-end',
    'scroll-padding-inline-start',
    'scroll-padding-left',
    'scroll-padding-right',
    'scroll-padding-top',
    'scroll-snap-align',
    'scroll-snap-stop',
    'scroll-snap-type',
    'scroll-timeline',
    'scroll-timeline-axis',
    'scroll-timeline-name',
    'scrollbar-color',
    'scrollbar-gutter',
    'scrollbar-width',
    'shape-image-threshold',
    'shape-margin',
    'shape-outside',
    'shape-rendering',
    'speak',
    'speak-as',
    'src',
    'stop-color',
    'stop-opacity',
    'stroke',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke-width',
    'tab-size',
    'table-layout',
    'text-align',
    'text-align-all',
    'text-align-last',
    'text-anchor',
    'text-combine-upright',
    'text-decoration',
    'text-decoration-color',
    'text-decoration-line',
    'text-decoration-skip',
    'text-decoration-skip-ink',
    'text-decoration-style',
    'text-decoration-thickness',
    'text-emphasis',
    'text-emphasis-color',
    'text-emphasis-position',
    'text-emphasis-style',
    'text-indent',
    'text-justify',
    'text-orientation',
    'text-overflow',
    'text-rendering',
    'text-shadow',
    'text-size-adjust',
    'text-transform',
    'text-underline-offset',
    'text-underline-position',
    'text-wrap',
    'text-wrap-mode',
    'text-wrap-style',
    'timeline-scope',
    'top',
    'touch-action',
    'transform',
    'transform-box',
    'transform-origin',
    'transform-style',
    'transition',
    'transition-behavior',
    'transition-delay',
    'transition-duration',
    'transition-property',
    'transition-timing-function',
    'translate',
    'unicode-bidi',
    'user-modify',
    'user-select',
    'vector-effect',
    'vertical-align',
    'view-timeline',
    'view-timeline-axis',
    'view-timeline-inset',
    'view-timeline-name',
    'view-transition-name',
    'visibility',
    'voice-balance',
    'voice-duration',
    'voice-family',
    'voice-pitch',
    'voice-range',
    'voice-rate',
    'voice-stress',
    'voice-volume',
    'white-space',
    'white-space-collapse',
    'widows',
    'width',
    'will-change',
    'word-break',
    'word-spacing',
    'word-wrap',
    'writing-mode',
    'x',
    'y',
    'z-index',
    'zoom',
  ]
    .sort()
    .reverse();
function er(e) {
  return e ? ('string' == typeof e ? e : e.source) : null;
}
function tr(e) {
  return rr('(?=', e, ')');
}
function rr(...e) {
  return e.map((e) => er(e)).join('');
}
function nr(...e) {
  const t = (function (e) {
    const t = e[e.length - 1];
    return 'object' == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
  })(e);
  return '(' + (t.capture ? '' : '?:') + e.map((e) => er(e)).join('|') + ')';
}
const ir = (e) => rr(/\b/, e, /\w$/.test(e) ? /\b/ : /\B/),
  ar = ['Protocol', 'Type'].map(ir),
  or = ['init', 'self'].map(ir),
  sr = ['Any', 'Self'],
  lr = [
    'actor',
    'any',
    'associatedtype',
    'async',
    'await',
    /as\?/,
    /as!/,
    'as',
    'borrowing',
    'break',
    'case',
    'catch',
    'class',
    'consume',
    'consuming',
    'continue',
    'convenience',
    'copy',
    'default',
    'defer',
    'deinit',
    'didSet',
    'distributed',
    'do',
    'dynamic',
    'each',
    'else',
    'enum',
    'extension',
    'fallthrough',
    /fileprivate\(set\)/,
    'fileprivate',
    'final',
    'for',
    'func',
    'get',
    'guard',
    'if',
    'import',
    'indirect',
    'infix',
    /init\?/,
    /init!/,
    'inout',
    /internal\(set\)/,
    'internal',
    'in',
    'is',
    'isolated',
    'nonisolated',
    'lazy',
    'let',
    'macro',
    'mutating',
    'nonmutating',
    /open\(set\)/,
    'open',
    'operator',
    'optional',
    'override',
    'package',
    'postfix',
    'precedencegroup',
    'prefix',
    /private\(set\)/,
    'private',
    'protocol',
    /public\(set\)/,
    'public',
    'repeat',
    'required',
    'rethrows',
    'return',
    'set',
    'some',
    'static',
    'struct',
    'subscript',
    'super',
    'switch',
    'throws',
    'throw',
    /try\?/,
    /try!/,
    'try',
    'typealias',
    /unowned\(safe\)/,
    /unowned\(unsafe\)/,
    'unowned',
    'var',
    'weak',
    'where',
    'while',
    'willSet',
  ],
  cr = ['false', 'nil', 'true'],
  hr = ['assignment', 'associativity', 'higherThan', 'left', 'lowerThan', 'none', 'right'],
  dr = [
    '#colorLiteral',
    '#column',
    '#dsohandle',
    '#else',
    '#elseif',
    '#endif',
    '#error',
    '#file',
    '#fileID',
    '#fileLiteral',
    '#filePath',
    '#function',
    '#if',
    '#imageLiteral',
    '#keyPath',
    '#line',
    '#selector',
    '#sourceLocation',
    '#warning',
  ],
  ur = [
    'abs',
    'all',
    'any',
    'assert',
    'assertionFailure',
    'debugPrint',
    'dump',
    'fatalError',
    'getVaList',
    'isKnownUniquelyReferenced',
    'max',
    'min',
    'numericCast',
    'pointwiseMax',
    'pointwiseMin',
    'precondition',
    'preconditionFailure',
    'print',
    'readLine',
    'repeatElement',
    'sequence',
    'stride',
    'swap',
    'swift_unboxFromSwiftValueWithType',
    'transcode',
    'type',
    'unsafeBitCast',
    'unsafeDowncast',
    'withExtendedLifetime',
    'withUnsafeMutablePointer',
    'withUnsafePointer',
    'withVaList',
    'withoutActuallyEscaping',
    'zip',
  ],
  pr = nr(
    /[/=\-+!*%<>&|^~?]/,
    /[\u00A1-\u00A7]/,
    /[\u00A9\u00AB]/,
    /[\u00AC\u00AE]/,
    /[\u00B0\u00B1]/,
    /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
    /[\u2016-\u2017]/,
    /[\u2020-\u2027]/,
    /[\u2030-\u203E]/,
    /[\u2041-\u2053]/,
    /[\u2055-\u205E]/,
    /[\u2190-\u23FF]/,
    /[\u2500-\u2775]/,
    /[\u2794-\u2BFF]/,
    /[\u2E00-\u2E7F]/,
    /[\u3001-\u3003]/,
    /[\u3008-\u3020]/,
    /[\u3030]/
  ),
  gr = nr(
    pr,
    /[\u0300-\u036F]/,
    /[\u1DC0-\u1DFF]/,
    /[\u20D0-\u20FF]/,
    /[\uFE00-\uFE0F]/,
    /[\uFE20-\uFE2F]/
  ),
  fr = rr(pr, gr, '*'),
  mr = nr(
    /[a-zA-Z_]/,
    /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
    /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
    /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
    /[\u1E00-\u1FFF]/,
    /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
    /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
    /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
    /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
    /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
    /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  ),
  br = nr(mr, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/),
  yr = rr(mr, br, '*'),
  xr = rr(/[A-Z]/, br, '*'),
  kr = [
    'attached',
    'autoclosure',
    rr(/convention\(/, nr('swift', 'block', 'c'), /\)/),
    'discardableResult',
    'dynamicCallable',
    'dynamicMemberLookup',
    'escaping',
    'freestanding',
    'frozen',
    'GKInspectable',
    'IBAction',
    'IBDesignable',
    'IBInspectable',
    'IBOutlet',
    'IBSegueAction',
    'inlinable',
    'main',
    'nonobjc',
    'NSApplicationMain',
    'NSCopying',
    'NSManaged',
    rr(/objc\(/, yr, /\)/),
    'objc',
    'objcMembers',
    'propertyWrapper',
    'requires_stored_property_inits',
    'resultBuilder',
    'Sendable',
    'testable',
    'UIApplicationMain',
    'unchecked',
    'unknown',
    'usableFromInline',
    'warn_unqualified_access',
  ],
  Cr = [
    'iOS',
    'iOSApplicationExtension',
    'macOS',
    'macOSApplicationExtension',
    'macCatalyst',
    'macCatalystApplicationExtension',
    'watchOS',
    'watchOSApplicationExtension',
    'tvOS',
    'tvOSApplicationExtension',
    'swift',
  ];
const wr = '[A-Za-z$_][0-9A-Za-z$_]*',
  vr = [
    'as',
    'in',
    'of',
    'if',
    'for',
    'while',
    'finally',
    'var',
    'new',
    'function',
    'do',
    'return',
    'void',
    'else',
    'break',
    'catch',
    'instanceof',
    'with',
    'throw',
    'case',
    'default',
    'try',
    'switch',
    'continue',
    'typeof',
    'delete',
    'let',
    'yield',
    'const',
    'class',
    'debugger',
    'async',
    'await',
    'static',
    'import',
    'from',
    'export',
    'extends',
    'using',
  ],
  _r = ['true', 'false', 'null', 'undefined', 'NaN', 'Infinity'],
  Sr = [
    'Object',
    'Function',
    'Boolean',
    'Symbol',
    'Math',
    'Date',
    'Number',
    'BigInt',
    'String',
    'RegExp',
    'Array',
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Int16Array',
    'Int32Array',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array',
    'Set',
    'Map',
    'WeakSet',
    'WeakMap',
    'ArrayBuffer',
    'SharedArrayBuffer',
    'Atomics',
    'DataView',
    'JSON',
    'Promise',
    'Generator',
    'GeneratorFunction',
    'AsyncFunction',
    'Reflect',
    'Proxy',
    'Intl',
    'WebAssembly',
  ],
  Er = [
    'Error',
    'EvalError',
    'InternalError',
    'RangeError',
    'ReferenceError',
    'SyntaxError',
    'TypeError',
    'URIError',
  ],
  Dr = [
    'setInterval',
    'setTimeout',
    'clearInterval',
    'clearTimeout',
    'require',
    'exports',
    'eval',
    'isFinite',
    'isNaN',
    'parseFloat',
    'parseInt',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'escape',
    'unescape',
  ],
  Ar = [
    'arguments',
    'this',
    'super',
    'console',
    'window',
    'document',
    'localStorage',
    'sessionStorage',
    'module',
    'global',
  ],
  Tr = [].concat(Dr, Sr, Er);
const Fr = {
  arduino: function (e) {
    const t = {
        type: ['boolean', 'byte', 'word', 'String'],
        built_in: [
          'KeyboardController',
          'MouseController',
          'SoftwareSerial',
          'EthernetServer',
          'EthernetClient',
          'LiquidCrystal',
          'RobotControl',
          'GSMVoiceCall',
          'EthernetUDP',
          'EsploraTFT',
          'HttpClient',
          'RobotMotor',
          'WiFiClient',
          'GSMScanner',
          'FileSystem',
          'Scheduler',
          'GSMServer',
          'YunClient',
          'YunServer',
          'IPAddress',
          'GSMClient',
          'GSMModem',
          'Keyboard',
          'Ethernet',
          'Console',
          'GSMBand',
          'Esplora',
          'Stepper',
          'Process',
          'WiFiUDP',
          'GSM_SMS',
          'Mailbox',
          'USBHost',
          'Firmata',
          'PImage',
          'Client',
          'Server',
          'GSMPIN',
          'FileIO',
          'Bridge',
          'Serial',
          'EEPROM',
          'Stream',
          'Mouse',
          'Audio',
          'Servo',
          'File',
          'Task',
          'GPRS',
          'WiFi',
          'Wire',
          'TFT',
          'GSM',
          'SPI',
          'SD',
        ],
        _hints: [
          'setup',
          'loop',
          'runShellCommandAsynchronously',
          'analogWriteResolution',
          'retrieveCallingNumber',
          'printFirmwareVersion',
          'analogReadResolution',
          'sendDigitalPortPair',
          'noListenOnLocalhost',
          'readJoystickButton',
          'setFirmwareVersion',
          'readJoystickSwitch',
          'scrollDisplayRight',
          'getVoiceCallStatus',
          'scrollDisplayLeft',
          'writeMicroseconds',
          'delayMicroseconds',
          'beginTransmission',
          'getSignalStrength',
          'runAsynchronously',
          'getAsynchronously',
          'listenOnLocalhost',
          'getCurrentCarrier',
          'readAccelerometer',
          'messageAvailable',
          'sendDigitalPorts',
          'lineFollowConfig',
          'countryNameWrite',
          'runShellCommand',
          'readStringUntil',
          'rewindDirectory',
          'readTemperature',
          'setClockDivider',
          'readLightSensor',
          'endTransmission',
          'analogReference',
          'detachInterrupt',
          'countryNameRead',
          'attachInterrupt',
          'encryptionType',
          'readBytesUntil',
          'robotNameWrite',
          'readMicrophone',
          'robotNameRead',
          'cityNameWrite',
          'userNameWrite',
          'readJoystickY',
          'readJoystickX',
          'mouseReleased',
          'openNextFile',
          'scanNetworks',
          'noInterrupts',
          'digitalWrite',
          'beginSpeaker',
          'mousePressed',
          'isActionDone',
          'mouseDragged',
          'displayLogos',
          'noAutoscroll',
          'addParameter',
          'remoteNumber',
          'getModifiers',
          'keyboardRead',
          'userNameRead',
          'waitContinue',
          'processInput',
          'parseCommand',
          'printVersion',
          'readNetworks',
          'writeMessage',
          'blinkVersion',
          'cityNameRead',
          'readMessage',
          'setDataMode',
          'parsePacket',
          'isListening',
          'setBitOrder',
          'beginPacket',
          'isDirectory',
          'motorsWrite',
          'drawCompass',
          'digitalRead',
          'clearScreen',
          'serialEvent',
          'rightToLeft',
          'setTextSize',
          'leftToRight',
          'requestFrom',
          'keyReleased',
          'compassRead',
          'analogWrite',
          'interrupts',
          'WiFiServer',
          'disconnect',
          'playMelody',
          'parseFloat',
          'autoscroll',
          'getPINUsed',
          'setPINUsed',
          'setTimeout',
          'sendAnalog',
          'readSlider',
          'analogRead',
          'beginWrite',
          'createChar',
          'motorsStop',
          'keyPressed',
          'tempoWrite',
          'readButton',
          'subnetMask',
          'debugPrint',
          'macAddress',
          'writeGreen',
          'randomSeed',
          'attachGPRS',
          'readString',
          'sendString',
          'remotePort',
          'releaseAll',
          'mouseMoved',
          'background',
          'getXChange',
          'getYChange',
          'answerCall',
          'getResult',
          'voiceCall',
          'endPacket',
          'constrain',
          'getSocket',
          'writeJSON',
          'getButton',
          'available',
          'connected',
          'findUntil',
          'readBytes',
          'exitValue',
          'readGreen',
          'writeBlue',
          'startLoop',
          'IPAddress',
          'isPressed',
          'sendSysex',
          'pauseMode',
          'gatewayIP',
          'setCursor',
          'getOemKey',
          'tuneWrite',
          'noDisplay',
          'loadImage',
          'switchPIN',
          'onRequest',
          'onReceive',
          'changePIN',
          'playFile',
          'noBuffer',
          'parseInt',
          'overflow',
          'checkPIN',
          'knobRead',
          'beginTFT',
          'bitClear',
          'updateIR',
          'bitWrite',
          'position',
          'writeRGB',
          'highByte',
          'writeRed',
          'setSpeed',
          'readBlue',
          'noStroke',
          'remoteIP',
          'transfer',
          'shutdown',
          'hangCall',
          'beginSMS',
          'endWrite',
          'attached',
          'maintain',
          'noCursor',
          'checkReg',
          'checkPUK',
          'shiftOut',
          'isValid',
          'shiftIn',
          'pulseIn',
          'connect',
          'println',
          'localIP',
          'pinMode',
          'getIMEI',
          'display',
          'noBlink',
          'process',
          'getBand',
          'running',
          'beginSD',
          'drawBMP',
          'lowByte',
          'setBand',
          'release',
          'bitRead',
          'prepare',
          'pointTo',
          'readRed',
          'setMode',
          'noFill',
          'remove',
          'listen',
          'stroke',
          'detach',
          'attach',
          'noTone',
          'exists',
          'buffer',
          'height',
          'bitSet',
          'circle',
          'config',
          'cursor',
          'random',
          'IRread',
          'setDNS',
          'endSMS',
          'getKey',
          'micros',
          'millis',
          'begin',
          'print',
          'write',
          'ready',
          'flush',
          'width',
          'isPIN',
          'blink',
          'clear',
          'press',
          'mkdir',
          'rmdir',
          'close',
          'point',
          'yield',
          'image',
          'BSSID',
          'click',
          'delay',
          'read',
          'text',
          'move',
          'peek',
          'beep',
          'rect',
          'line',
          'open',
          'seek',
          'fill',
          'size',
          'turn',
          'stop',
          'home',
          'find',
          'step',
          'tone',
          'sqrt',
          'RSSI',
          'SSID',
          'end',
          'bit',
          'tan',
          'cos',
          'sin',
          'pow',
          'map',
          'abs',
          'max',
          'min',
          'get',
          'run',
          'put',
        ],
        literal: [
          'DIGITAL_MESSAGE',
          'FIRMATA_STRING',
          'ANALOG_MESSAGE',
          'REPORT_DIGITAL',
          'REPORT_ANALOG',
          'INPUT_PULLUP',
          'SET_PIN_MODE',
          'INTERNAL2V56',
          'SYSTEM_RESET',
          'LED_BUILTIN',
          'INTERNAL1V1',
          'SYSEX_START',
          'INTERNAL',
          'EXTERNAL',
          'DEFAULT',
          'OUTPUT',
          'INPUT',
          'HIGH',
          'LOW',
        ],
      },
      r = (function (e) {
        const t = e.regex,
          r = e.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
          n = 'decltype\\(auto\\)',
          i = '[a-zA-Z_]\\w*::',
          a =
            '(?!struct)(' +
            n +
            '|' +
            t.optional(i) +
            '[a-zA-Z_]\\w*' +
            t.optional('<[^<>]+>') +
            ')',
          o = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' },
          s = {
            className: 'string',
            variants: [
              { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [e.BACKSLASH_ESCAPE] },
              {
                begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
                end: "'",
                illegal: '.',
              },
              e.END_SAME_AS_BEGIN({
                begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
                end: /\)([^()\\ ]{0,16})"/,
              }),
            ],
          },
          l = {
            className: 'number',
            variants: [
              {
                begin:
                  "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
              },
              {
                begin:
                  "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
              },
            ],
            relevance: 0,
          },
          c = {
            className: 'meta',
            begin: /#\s*[a-z]+\b/,
            end: /$/,
            keywords: {
              keyword:
                'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
            },
            contains: [
              { begin: /\\\n/, relevance: 0 },
              e.inherit(s, { className: 'string' }),
              { className: 'string', begin: /<.*?>/ },
              r,
              e.C_BLOCK_COMMENT_MODE,
            ],
          },
          h = { className: 'title', begin: t.optional(i) + e.IDENT_RE, relevance: 0 },
          d = t.optional(i) + e.IDENT_RE + '\\s*\\(',
          u = {
            type: [
              'bool',
              'char',
              'char16_t',
              'char32_t',
              'char8_t',
              'double',
              'float',
              'int',
              'long',
              'short',
              'void',
              'wchar_t',
              'unsigned',
              'signed',
              'const',
              'static',
            ],
            keyword: [
              'alignas',
              'alignof',
              'and',
              'and_eq',
              'asm',
              'atomic_cancel',
              'atomic_commit',
              'atomic_noexcept',
              'auto',
              'bitand',
              'bitor',
              'break',
              'case',
              'catch',
              'class',
              'co_await',
              'co_return',
              'co_yield',
              'compl',
              'concept',
              'const_cast|10',
              'consteval',
              'constexpr',
              'constinit',
              'continue',
              'decltype',
              'default',
              'delete',
              'do',
              'dynamic_cast|10',
              'else',
              'enum',
              'explicit',
              'export',
              'extern',
              'false',
              'final',
              'for',
              'friend',
              'goto',
              'if',
              'import',
              'inline',
              'module',
              'mutable',
              'namespace',
              'new',
              'noexcept',
              'not',
              'not_eq',
              'nullptr',
              'operator',
              'or',
              'or_eq',
              'override',
              'private',
              'protected',
              'public',
              'reflexpr',
              'register',
              'reinterpret_cast|10',
              'requires',
              'return',
              'sizeof',
              'static_assert',
              'static_cast|10',
              'struct',
              'switch',
              'synchronized',
              'template',
              'this',
              'thread_local',
              'throw',
              'transaction_safe',
              'transaction_safe_dynamic',
              'true',
              'try',
              'typedef',
              'typeid',
              'typename',
              'union',
              'using',
              'virtual',
              'volatile',
              'while',
              'xor',
              'xor_eq',
            ],
            literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
            built_in: ['_Pragma'],
            _type_hints: [
              'any',
              'auto_ptr',
              'barrier',
              'binary_semaphore',
              'bitset',
              'complex',
              'condition_variable',
              'condition_variable_any',
              'counting_semaphore',
              'deque',
              'false_type',
              'flat_map',
              'flat_set',
              'future',
              'imaginary',
              'initializer_list',
              'istringstream',
              'jthread',
              'latch',
              'lock_guard',
              'multimap',
              'multiset',
              'mutex',
              'optional',
              'ostringstream',
              'packaged_task',
              'pair',
              'promise',
              'priority_queue',
              'queue',
              'recursive_mutex',
              'recursive_timed_mutex',
              'scoped_lock',
              'set',
              'shared_future',
              'shared_lock',
              'shared_mutex',
              'shared_timed_mutex',
              'shared_ptr',
              'stack',
              'string_view',
              'stringstream',
              'timed_mutex',
              'thread',
              'true_type',
              'tuple',
              'unique_lock',
              'unique_ptr',
              'unordered_map',
              'unordered_multimap',
              'unordered_multiset',
              'unordered_set',
              'variant',
              'vector',
              'weak_ptr',
              'wstring',
              'wstring_view',
            ],
          },
          p = {
            className: 'function.dispatch',
            relevance: 0,
            keywords: {
              _hint: [
                'abort',
                'abs',
                'acos',
                'apply',
                'as_const',
                'asin',
                'atan',
                'atan2',
                'calloc',
                'ceil',
                'cerr',
                'cin',
                'clog',
                'cos',
                'cosh',
                'cout',
                'declval',
                'endl',
                'exchange',
                'exit',
                'exp',
                'fabs',
                'floor',
                'fmod',
                'forward',
                'fprintf',
                'fputs',
                'free',
                'frexp',
                'fscanf',
                'future',
                'invoke',
                'isalnum',
                'isalpha',
                'iscntrl',
                'isdigit',
                'isgraph',
                'islower',
                'isprint',
                'ispunct',
                'isspace',
                'isupper',
                'isxdigit',
                'labs',
                'launder',
                'ldexp',
                'log',
                'log10',
                'make_pair',
                'make_shared',
                'make_shared_for_overwrite',
                'make_tuple',
                'make_unique',
                'malloc',
                'memchr',
                'memcmp',
                'memcpy',
                'memset',
                'modf',
                'move',
                'pow',
                'printf',
                'putchar',
                'puts',
                'realloc',
                'scanf',
                'sin',
                'sinh',
                'snprintf',
                'sprintf',
                'sqrt',
                'sscanf',
                'std',
                'stderr',
                'stdin',
                'stdout',
                'strcat',
                'strchr',
                'strcmp',
                'strcpy',
                'strcspn',
                'strlen',
                'strncat',
                'strncmp',
                'strncpy',
                'strpbrk',
                'strrchr',
                'strspn',
                'strstr',
                'swap',
                'tan',
                'tanh',
                'terminate',
                'to_underlying',
                'tolower',
                'toupper',
                'vfprintf',
                'visit',
                'vprintf',
                'vsprintf',
              ],
            },
            begin: t.concat(
              /\b/,
              /(?!decltype)/,
              /(?!if)/,
              /(?!for)/,
              /(?!switch)/,
              /(?!while)/,
              e.IDENT_RE,
              t.lookahead(/(<[^<>]+>|)\s*\(/)
            ),
          },
          g = [p, c, o, r, e.C_BLOCK_COMMENT_MODE, l, s],
          f = {
            variants: [
              { begin: /=/, end: /;/ },
              { begin: /\(/, end: /\)/ },
              { beginKeywords: 'new throw return else', end: /;/ },
            ],
            keywords: u,
            contains: g.concat([
              { begin: /\(/, end: /\)/, keywords: u, contains: g.concat(['self']), relevance: 0 },
            ]),
            relevance: 0,
          },
          m = {
            className: 'function',
            begin: '(' + a + '[\\*&\\s]+)+' + d,
            returnBegin: !0,
            end: /[{;=]/,
            excludeEnd: !0,
            keywords: u,
            illegal: /[^\w\s\*&:<>.]/,
            contains: [
              { begin: n, keywords: u, relevance: 0 },
              { begin: d, returnBegin: !0, contains: [h], relevance: 0 },
              { begin: /::/, relevance: 0 },
              { begin: /:/, endsWithParent: !0, contains: [s, l] },
              { relevance: 0, match: /,/ },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                keywords: u,
                relevance: 0,
                contains: [
                  r,
                  e.C_BLOCK_COMMENT_MODE,
                  s,
                  l,
                  o,
                  {
                    begin: /\(/,
                    end: /\)/,
                    keywords: u,
                    relevance: 0,
                    contains: ['self', r, e.C_BLOCK_COMMENT_MODE, s, l, o],
                  },
                ],
              },
              o,
              r,
              e.C_BLOCK_COMMENT_MODE,
              c,
            ],
          };
        return {
          name: 'C++',
          aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
          keywords: u,
          illegal: '</',
          classNameAliases: { 'function.dispatch': 'built_in' },
          contains: [].concat(f, m, p, g, [
            c,
            {
              begin:
                '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)',
              end: '>',
              keywords: u,
              contains: ['self', o],
            },
            { begin: e.IDENT_RE + '::', keywords: u },
            {
              match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
              className: { 1: 'keyword', 3: 'title.class' },
            },
          ]),
        };
      })(e),
      n = r.keywords;
    return (
      (n.type = [...n.type, ...t.type]),
      (n.literal = [...n.literal, ...t.literal]),
      (n.built_in = [...n.built_in, ...t.built_in]),
      (n._hints = t._hints),
      (r.name = 'Arduino'),
      (r.aliases = ['ino']),
      (r.supersetOf = 'cpp'),
      r
    );
  },
  bash: function (e) {
    const t = e.regex,
      r = {},
      n = { begin: /\$\{/, end: /\}/, contains: ['self', { begin: /:-/, contains: [r] }] };
    Object.assign(r, {
      className: 'variable',
      variants: [{ begin: t.concat(/\$[\w\d#@][\w\d_]*/, '(?![\\w\\d])(?![$])') }, n],
    });
    const i = { className: 'subst', begin: /\$\(/, end: /\)/, contains: [e.BACKSLASH_ESCAPE] },
      a = e.inherit(e.COMMENT(), { match: [/(^|\s)/, /#.*$/], scope: { 2: 'comment' } }),
      o = {
        begin: /<<-?\s*(?=\w+)/,
        starts: {
          contains: [e.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: 'string' })],
        },
      },
      s = { className: 'string', begin: /"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, r, i] };
    i.contains.push(s);
    const l = {
        begin: /\$?\(\(/,
        end: /\)\)/,
        contains: [{ begin: /\d+#[0-9a-f]+/, className: 'number' }, e.NUMBER_MODE, r],
      },
      c = e.SHEBANG({
        binary: `(${['fish', 'bash', 'zsh', 'sh', 'csh', 'ksh', 'tcsh', 'dash', 'scsh'].join('|')})`,
        relevance: 10,
      }),
      h = {
        className: 'function',
        begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
        returnBegin: !0,
        contains: [e.inherit(e.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
        relevance: 0,
      };
    return {
      name: 'Bash',
      aliases: ['sh', 'zsh'],
      keywords: {
        $pattern: /\b[a-z][a-z0-9._-]+\b/,
        keyword: [
          'if',
          'then',
          'else',
          'elif',
          'fi',
          'time',
          'for',
          'while',
          'until',
          'in',
          'do',
          'done',
          'case',
          'esac',
          'coproc',
          'function',
          'select',
        ],
        literal: ['true', 'false'],
        built_in: [
          'break',
          'cd',
          'continue',
          'eval',
          'exec',
          'exit',
          'export',
          'getopts',
          'hash',
          'pwd',
          'readonly',
          'return',
          'shift',
          'test',
          'times',
          'trap',
          'umask',
          'unset',
          'alias',
          'bind',
          'builtin',
          'caller',
          'command',
          'declare',
          'echo',
          'enable',
          'help',
          'let',
          'local',
          'logout',
          'mapfile',
          'printf',
          'read',
          'readarray',
          'source',
          'sudo',
          'type',
          'typeset',
          'ulimit',
          'unalias',
          'set',
          'shopt',
          'autoload',
          'bg',
          'bindkey',
          'bye',
          'cap',
          'chdir',
          'clone',
          'comparguments',
          'compcall',
          'compctl',
          'compdescribe',
          'compfiles',
          'compgroups',
          'compquote',
          'comptags',
          'comptry',
          'compvalues',
          'dirs',
          'disable',
          'disown',
          'echotc',
          'echoti',
          'emulate',
          'fc',
          'fg',
          'float',
          'functions',
          'getcap',
          'getln',
          'history',
          'integer',
          'jobs',
          'kill',
          'limit',
          'log',
          'noglob',
          'popd',
          'print',
          'pushd',
          'pushln',
          'rehash',
          'sched',
          'setcap',
          'setopt',
          'stat',
          'suspend',
          'ttyctl',
          'unfunction',
          'unhash',
          'unlimit',
          'unsetopt',
          'vared',
          'wait',
          'whence',
          'where',
          'which',
          'zcompile',
          'zformat',
          'zftp',
          'zle',
          'zmodload',
          'zparseopts',
          'zprof',
          'zpty',
          'zregexparse',
          'zsocket',
          'zstyle',
          'ztcp',
          'chcon',
          'chgrp',
          'chown',
          'chmod',
          'cp',
          'dd',
          'df',
          'dir',
          'dircolors',
          'ln',
          'ls',
          'mkdir',
          'mkfifo',
          'mknod',
          'mktemp',
          'mv',
          'realpath',
          'rm',
          'rmdir',
          'shred',
          'sync',
          'touch',
          'truncate',
          'vdir',
          'b2sum',
          'base32',
          'base64',
          'cat',
          'cksum',
          'comm',
          'csplit',
          'cut',
          'expand',
          'fmt',
          'fold',
          'head',
          'join',
          'md5sum',
          'nl',
          'numfmt',
          'od',
          'paste',
          'ptx',
          'pr',
          'sha1sum',
          'sha224sum',
          'sha256sum',
          'sha384sum',
          'sha512sum',
          'shuf',
          'sort',
          'split',
          'sum',
          'tac',
          'tail',
          'tr',
          'tsort',
          'unexpand',
          'uniq',
          'wc',
          'arch',
          'basename',
          'chroot',
          'date',
          'dirname',
          'du',
          'echo',
          'env',
          'expr',
          'factor',
          'groups',
          'hostid',
          'id',
          'link',
          'logname',
          'nice',
          'nohup',
          'nproc',
          'pathchk',
          'pinky',
          'printenv',
          'printf',
          'pwd',
          'readlink',
          'runcon',
          'seq',
          'sleep',
          'stat',
          'stdbuf',
          'stty',
          'tee',
          'test',
          'timeout',
          'tty',
          'uname',
          'unlink',
          'uptime',
          'users',
          'who',
          'whoami',
          'yes',
        ],
      },
      contains: [
        c,
        e.SHEBANG(),
        h,
        l,
        a,
        o,
        { match: /(\/[a-z._-]+)+/ },
        s,
        { match: /\\"/ },
        { className: 'string', begin: /'/, end: /'/ },
        { match: /\\'/ },
        r,
      ],
    };
  },
  c: function (e) {
    const t = e.regex,
      r = e.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
      n = 'decltype\\(auto\\)',
      i = '[a-zA-Z_]\\w*::',
      a = '(' + n + '|' + t.optional(i) + '[a-zA-Z_]\\w*' + t.optional('<[^<>]+>') + ')',
      o = {
        className: 'type',
        variants: [{ begin: '\\b[a-z\\d_]*_t\\b' }, { match: /\batomic_[a-z]{3,6}\b/ }],
      },
      s = {
        className: 'string',
        variants: [
          { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [e.BACKSLASH_ESCAPE] },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: '.',
          },
          e.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/,
          }),
        ],
      },
      l = {
        className: 'number',
        variants: [
          { match: /\b(0b[01']+)/ },
          {
            match:
              /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/,
          },
          {
            match:
              /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/,
          },
          { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ },
        ],
        relevance: 0,
      },
      c = {
        className: 'meta',
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword:
            'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include',
        },
        contains: [
          { begin: /\\\n/, relevance: 0 },
          e.inherit(s, { className: 'string' }),
          { className: 'string', begin: /<.*?>/ },
          r,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      h = { className: 'title', begin: t.optional(i) + e.IDENT_RE, relevance: 0 },
      d = t.optional(i) + e.IDENT_RE + '\\s*\\(',
      u = {
        keyword: [
          'asm',
          'auto',
          'break',
          'case',
          'continue',
          'default',
          'do',
          'else',
          'enum',
          'extern',
          'for',
          'fortran',
          'goto',
          'if',
          'inline',
          'register',
          'restrict',
          'return',
          'sizeof',
          'typeof',
          'typeof_unqual',
          'struct',
          'switch',
          'typedef',
          'union',
          'volatile',
          'while',
          '_Alignas',
          '_Alignof',
          '_Atomic',
          '_Generic',
          '_Noreturn',
          '_Static_assert',
          '_Thread_local',
          'alignas',
          'alignof',
          'noreturn',
          'static_assert',
          'thread_local',
          '_Pragma',
        ],
        type: [
          'float',
          'double',
          'signed',
          'unsigned',
          'int',
          'short',
          'long',
          'char',
          'void',
          '_Bool',
          '_BitInt',
          '_Complex',
          '_Imaginary',
          '_Decimal32',
          '_Decimal64',
          '_Decimal96',
          '_Decimal128',
          '_Decimal64x',
          '_Decimal128x',
          '_Float16',
          '_Float32',
          '_Float64',
          '_Float128',
          '_Float32x',
          '_Float64x',
          '_Float128x',
          'const',
          'static',
          'constexpr',
          'complex',
          'bool',
          'imaginary',
        ],
        literal: 'true false NULL',
        built_in:
          'std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr',
      },
      p = [c, o, r, e.C_BLOCK_COMMENT_MODE, l, s],
      g = {
        variants: [
          { begin: /=/, end: /;/ },
          { begin: /\(/, end: /\)/ },
          { beginKeywords: 'new throw return else', end: /;/ },
        ],
        keywords: u,
        contains: p.concat([
          { begin: /\(/, end: /\)/, keywords: u, contains: p.concat(['self']), relevance: 0 },
        ]),
        relevance: 0,
      },
      f = {
        begin: '(' + a + '[\\*&\\s]+)+' + d,
        returnBegin: !0,
        end: /[{;=]/,
        excludeEnd: !0,
        keywords: u,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          { begin: n, keywords: u, relevance: 0 },
          {
            begin: d,
            returnBegin: !0,
            contains: [e.inherit(h, { className: 'title.function' })],
            relevance: 0,
          },
          { relevance: 0, match: /,/ },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            keywords: u,
            relevance: 0,
            contains: [
              r,
              e.C_BLOCK_COMMENT_MODE,
              s,
              l,
              o,
              {
                begin: /\(/,
                end: /\)/,
                keywords: u,
                relevance: 0,
                contains: ['self', r, e.C_BLOCK_COMMENT_MODE, s, l, o],
              },
            ],
          },
          o,
          r,
          e.C_BLOCK_COMMENT_MODE,
          c,
        ],
      };
    return {
      name: 'C',
      aliases: ['h'],
      keywords: u,
      disableAutodetect: !0,
      illegal: '</',
      contains: [].concat(g, f, p, [
        c,
        { begin: e.IDENT_RE + '::', keywords: u },
        {
          className: 'class',
          beginKeywords: 'enum class struct union',
          end: /[{;:<>=]/,
          contains: [{ beginKeywords: 'final class struct' }, e.TITLE_MODE],
        },
      ]),
      exports: { preprocessor: c, strings: s, keywords: u },
    };
  },
  cpp: function (e) {
    const t = e.regex,
      r = e.COMMENT('//', '$', { contains: [{ begin: /\\\n/ }] }),
      n = 'decltype\\(auto\\)',
      i = '[a-zA-Z_]\\w*::',
      a = '(?!struct)(' + n + '|' + t.optional(i) + '[a-zA-Z_]\\w*' + t.optional('<[^<>]+>') + ')',
      o = { className: 'type', begin: '\\b[a-z\\d_]*_t\\b' },
      s = {
        className: 'string',
        variants: [
          { begin: '(u8?|U|L)?"', end: '"', illegal: '\\n', contains: [e.BACKSLASH_ESCAPE] },
          {
            begin: "(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
            end: "'",
            illegal: '.',
          },
          e.END_SAME_AS_BEGIN({
            begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
            end: /\)([^()\\ ]{0,16})"/,
          }),
        ],
      },
      l = {
        className: 'number',
        variants: [
          {
            begin:
              "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)",
          },
          {
            begin:
              "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)",
          },
        ],
        relevance: 0,
      },
      c = {
        className: 'meta',
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: {
          keyword:
            'if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include',
        },
        contains: [
          { begin: /\\\n/, relevance: 0 },
          e.inherit(s, { className: 'string' }),
          { className: 'string', begin: /<.*?>/ },
          r,
          e.C_BLOCK_COMMENT_MODE,
        ],
      },
      h = { className: 'title', begin: t.optional(i) + e.IDENT_RE, relevance: 0 },
      d = t.optional(i) + e.IDENT_RE + '\\s*\\(',
      u = {
        type: [
          'bool',
          'char',
          'char16_t',
          'char32_t',
          'char8_t',
          'double',
          'float',
          'int',
          'long',
          'short',
          'void',
          'wchar_t',
          'unsigned',
          'signed',
          'const',
          'static',
        ],
        keyword: [
          'alignas',
          'alignof',
          'and',
          'and_eq',
          'asm',
          'atomic_cancel',
          'atomic_commit',
          'atomic_noexcept',
          'auto',
          'bitand',
          'bitor',
          'break',
          'case',
          'catch',
          'class',
          'co_await',
          'co_return',
          'co_yield',
          'compl',
          'concept',
          'const_cast|10',
          'consteval',
          'constexpr',
          'constinit',
          'continue',
          'decltype',
          'default',
          'delete',
          'do',
          'dynamic_cast|10',
          'else',
          'enum',
          'explicit',
          'export',
          'extern',
          'false',
          'final',
          'for',
          'friend',
          'goto',
          'if',
          'import',
          'inline',
          'module',
          'mutable',
          'namespace',
          'new',
          'noexcept',
          'not',
          'not_eq',
          'nullptr',
          'operator',
          'or',
          'or_eq',
          'override',
          'private',
          'protected',
          'public',
          'reflexpr',
          'register',
          'reinterpret_cast|10',
          'requires',
          'return',
          'sizeof',
          'static_assert',
          'static_cast|10',
          'struct',
          'switch',
          'synchronized',
          'template',
          'this',
          'thread_local',
          'throw',
          'transaction_safe',
          'transaction_safe_dynamic',
          'true',
          'try',
          'typedef',
          'typeid',
          'typename',
          'union',
          'using',
          'virtual',
          'volatile',
          'while',
          'xor',
          'xor_eq',
        ],
        literal: ['NULL', 'false', 'nullopt', 'nullptr', 'true'],
        built_in: ['_Pragma'],
        _type_hints: [
          'any',
          'auto_ptr',
          'barrier',
          'binary_semaphore',
          'bitset',
          'complex',
          'condition_variable',
          'condition_variable_any',
          'counting_semaphore',
          'deque',
          'false_type',
          'flat_map',
          'flat_set',
          'future',
          'imaginary',
          'initializer_list',
          'istringstream',
          'jthread',
          'latch',
          'lock_guard',
          'multimap',
          'multiset',
          'mutex',
          'optional',
          'ostringstream',
          'packaged_task',
          'pair',
          'promise',
          'priority_queue',
          'queue',
          'recursive_mutex',
          'recursive_timed_mutex',
          'scoped_lock',
          'set',
          'shared_future',
          'shared_lock',
          'shared_mutex',
          'shared_timed_mutex',
          'shared_ptr',
          'stack',
          'string_view',
          'stringstream',
          'timed_mutex',
          'thread',
          'true_type',
          'tuple',
          'unique_lock',
          'unique_ptr',
          'unordered_map',
          'unordered_multimap',
          'unordered_multiset',
          'unordered_set',
          'variant',
          'vector',
          'weak_ptr',
          'wstring',
          'wstring_view',
        ],
      },
      p = {
        className: 'function.dispatch',
        relevance: 0,
        keywords: {
          _hint: [
            'abort',
            'abs',
            'acos',
            'apply',
            'as_const',
            'asin',
            'atan',
            'atan2',
            'calloc',
            'ceil',
            'cerr',
            'cin',
            'clog',
            'cos',
            'cosh',
            'cout',
            'declval',
            'endl',
            'exchange',
            'exit',
            'exp',
            'fabs',
            'floor',
            'fmod',
            'forward',
            'fprintf',
            'fputs',
            'free',
            'frexp',
            'fscanf',
            'future',
            'invoke',
            'isalnum',
            'isalpha',
            'iscntrl',
            'isdigit',
            'isgraph',
            'islower',
            'isprint',
            'ispunct',
            'isspace',
            'isupper',
            'isxdigit',
            'labs',
            'launder',
            'ldexp',
            'log',
            'log10',
            'make_pair',
            'make_shared',
            'make_shared_for_overwrite',
            'make_tuple',
            'make_unique',
            'malloc',
            'memchr',
            'memcmp',
            'memcpy',
            'memset',
            'modf',
            'move',
            'pow',
            'printf',
            'putchar',
            'puts',
            'realloc',
            'scanf',
            'sin',
            'sinh',
            'snprintf',
            'sprintf',
            'sqrt',
            'sscanf',
            'std',
            'stderr',
            'stdin',
            'stdout',
            'strcat',
            'strchr',
            'strcmp',
            'strcpy',
            'strcspn',
            'strlen',
            'strncat',
            'strncmp',
            'strncpy',
            'strpbrk',
            'strrchr',
            'strspn',
            'strstr',
            'swap',
            'tan',
            'tanh',
            'terminate',
            'to_underlying',
            'tolower',
            'toupper',
            'vfprintf',
            'visit',
            'vprintf',
            'vsprintf',
          ],
        },
        begin: t.concat(
          /\b/,
          /(?!decltype)/,
          /(?!if)/,
          /(?!for)/,
          /(?!switch)/,
          /(?!while)/,
          e.IDENT_RE,
          t.lookahead(/(<[^<>]+>|)\s*\(/)
        ),
      },
      g = [p, c, o, r, e.C_BLOCK_COMMENT_MODE, l, s],
      f = {
        variants: [
          { begin: /=/, end: /;/ },
          { begin: /\(/, end: /\)/ },
          { beginKeywords: 'new throw return else', end: /;/ },
        ],
        keywords: u,
        contains: g.concat([
          { begin: /\(/, end: /\)/, keywords: u, contains: g.concat(['self']), relevance: 0 },
        ]),
        relevance: 0,
      },
      m = {
        className: 'function',
        begin: '(' + a + '[\\*&\\s]+)+' + d,
        returnBegin: !0,
        end: /[{;=]/,
        excludeEnd: !0,
        keywords: u,
        illegal: /[^\w\s\*&:<>.]/,
        contains: [
          { begin: n, keywords: u, relevance: 0 },
          { begin: d, returnBegin: !0, contains: [h], relevance: 0 },
          { begin: /::/, relevance: 0 },
          { begin: /:/, endsWithParent: !0, contains: [s, l] },
          { relevance: 0, match: /,/ },
          {
            className: 'params',
            begin: /\(/,
            end: /\)/,
            keywords: u,
            relevance: 0,
            contains: [
              r,
              e.C_BLOCK_COMMENT_MODE,
              s,
              l,
              o,
              {
                begin: /\(/,
                end: /\)/,
                keywords: u,
                relevance: 0,
                contains: ['self', r, e.C_BLOCK_COMMENT_MODE, s, l, o],
              },
            ],
          },
          o,
          r,
          e.C_BLOCK_COMMENT_MODE,
          c,
        ],
      };
    return {
      name: 'C++',
      aliases: ['cc', 'c++', 'h++', 'hpp', 'hh', 'hxx', 'cxx'],
      keywords: u,
      illegal: '</',
      classNameAliases: { 'function.dispatch': 'built_in' },
      contains: [].concat(f, m, p, g, [
        c,
        {
          begin:
            '\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)',
          end: '>',
          keywords: u,
          contains: ['self', o],
        },
        { begin: e.IDENT_RE + '::', keywords: u },
        {
          match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/],
          className: { 1: 'keyword', 3: 'title.class' },
        },
      ]),
    };
  },
  csharp: function (e) {
    const t = {
        keyword: [
          'abstract',
          'as',
          'base',
          'break',
          'case',
          'catch',
          'class',
          'const',
          'continue',
          'do',
          'else',
          'event',
          'explicit',
          'extern',
          'finally',
          'fixed',
          'for',
          'foreach',
          'goto',
          'if',
          'implicit',
          'in',
          'interface',
          'internal',
          'is',
          'lock',
          'namespace',
          'new',
          'operator',
          'out',
          'override',
          'params',
          'private',
          'protected',
          'public',
          'readonly',
          'record',
          'ref',
          'return',
          'scoped',
          'sealed',
          'sizeof',
          'stackalloc',
          'static',
          'struct',
          'switch',
          'this',
          'throw',
          'try',
          'typeof',
          'unchecked',
          'unsafe',
          'using',
          'virtual',
          'void',
          'volatile',
          'while',
        ].concat([
          'add',
          'alias',
          'and',
          'ascending',
          'args',
          'async',
          'await',
          'by',
          'descending',
          'dynamic',
          'equals',
          'file',
          'from',
          'get',
          'global',
          'group',
          'init',
          'into',
          'join',
          'let',
          'nameof',
          'not',
          'notnull',
          'on',
          'or',
          'orderby',
          'partial',
          'record',
          'remove',
          'required',
          'scoped',
          'select',
          'set',
          'unmanaged',
          'value|0',
          'var',
          'when',
          'where',
          'with',
          'yield',
        ]),
        built_in: [
          'bool',
          'byte',
          'char',
          'decimal',
          'delegate',
          'double',
          'dynamic',
          'enum',
          'float',
          'int',
          'long',
          'nint',
          'nuint',
          'object',
          'sbyte',
          'short',
          'string',
          'ulong',
          'uint',
          'ushort',
        ],
        literal: ['default', 'false', 'null', 'true'],
      },
      r = e.inherit(e.TITLE_MODE, { begin: '[a-zA-Z](\\.?\\w)*' }),
      n = {
        className: 'number',
        variants: [
          { begin: "\\b(0b[01']+)" },
          { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
          {
            begin:
              "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)",
          },
        ],
        relevance: 0,
      },
      i = { className: 'string', begin: '@"', end: '"', contains: [{ begin: '""' }] },
      a = e.inherit(i, { illegal: /\n/ }),
      o = { className: 'subst', begin: /\{/, end: /\}/, keywords: t },
      s = e.inherit(o, { illegal: /\n/ }),
      l = {
        className: 'string',
        begin: /\$"/,
        end: '"',
        illegal: /\n/,
        contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, e.BACKSLASH_ESCAPE, s],
      },
      c = {
        className: 'string',
        begin: /\$@"/,
        end: '"',
        contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, o],
      },
      h = e.inherit(c, {
        illegal: /\n/,
        contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, s],
      });
    ((o.contains = [c, l, i, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, n, e.C_BLOCK_COMMENT_MODE]),
      (s.contains = [
        h,
        l,
        a,
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
        n,
        e.inherit(e.C_BLOCK_COMMENT_MODE, { illegal: /\n/ }),
      ]));
    const d = {
        variants: [
          { className: 'string', begin: /"""("*)(?!")(.|\n)*?"""\1/, relevance: 1 },
          c,
          l,
          i,
          e.APOS_STRING_MODE,
          e.QUOTE_STRING_MODE,
        ],
      },
      u = { begin: '<', end: '>', contains: [{ beginKeywords: 'in out' }, r] },
      p = e.IDENT_RE + '(<' + e.IDENT_RE + '(\\s*,\\s*' + e.IDENT_RE + ')*>)?(\\[\\])?',
      g = { begin: '@' + e.IDENT_RE, relevance: 0 };
    return {
      name: 'C#',
      aliases: ['cs', 'c#'],
      keywords: t,
      illegal: /::/,
      contains: [
        e.COMMENT('///', '$', {
          returnBegin: !0,
          contains: [
            {
              className: 'doctag',
              variants: [
                { begin: '///', relevance: 0 },
                { begin: '\x3c!--|--\x3e' },
                { begin: '</?', end: '>' },
              ],
            },
          ],
        }),
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        {
          className: 'meta',
          begin: '#',
          end: '$',
          keywords: {
            keyword:
              'if else elif endif define undef warning error line region endregion pragma checksum',
          },
        },
        d,
        n,
        {
          beginKeywords: 'class interface',
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:,]/,
          contains: [
            { beginKeywords: 'where class' },
            r,
            u,
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
          ],
        },
        {
          beginKeywords: 'namespace',
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [r, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
        },
        {
          beginKeywords: 'record',
          relevance: 0,
          end: /[{;=]/,
          illegal: /[^\s:]/,
          contains: [r, u, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
        },
        {
          className: 'meta',
          begin: '^\\s*\\[(?=[\\w])',
          excludeBegin: !0,
          end: '\\]',
          excludeEnd: !0,
          contains: [{ className: 'string', begin: /"/, end: /"/ }],
        },
        { beginKeywords: 'new return throw await else', relevance: 0 },
        {
          className: 'function',
          begin: '(' + p + '\\s+)+' + e.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
          returnBegin: !0,
          end: /\s*[{;=]/,
          excludeEnd: !0,
          keywords: t,
          contains: [
            {
              beginKeywords: [
                'public',
                'private',
                'protected',
                'static',
                'internal',
                'protected',
                'abstract',
                'async',
                'extern',
                'override',
                'unsafe',
                'virtual',
                'new',
                'sealed',
                'partial',
              ].join(' '),
              relevance: 0,
            },
            {
              begin: e.IDENT_RE + '\\s*(<[^=]+>\\s*)?\\(',
              returnBegin: !0,
              contains: [e.TITLE_MODE, u],
              relevance: 0,
            },
            { match: /\(\)/ },
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: t,
              relevance: 0,
              contains: [d, n, e.C_BLOCK_COMMENT_MODE],
            },
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
          ],
        },
        g,
      ],
    };
  },
  css: function (e) {
    const t = e.regex,
      r = ((e) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: 'selector-attr',
          begin: /\[/,
          end: /\]/,
          illegal: '$',
          contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
          scope: 'number',
          begin:
            e.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
          relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
      }))(e),
      n = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE];
    return {
      name: 'CSS',
      case_insensitive: !0,
      illegal: /[=|'\$]/,
      keywords: { keyframePosition: 'from to' },
      classNameAliases: { keyframePosition: 'selector-tag' },
      contains: [
        r.BLOCK_COMMENT,
        { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ },
        r.CSS_NUMBER_MODE,
        { className: 'selector-id', begin: /#[A-Za-z0-9_-]+/, relevance: 0 },
        { className: 'selector-class', begin: '\\.[a-zA-Z-][a-zA-Z0-9_-]*', relevance: 0 },
        r.ATTRIBUTE_SELECTOR_MODE,
        {
          className: 'selector-pseudo',
          variants: [
            { begin: ':(' + vt.join('|') + ')' },
            { begin: ':(:)?(' + _t.join('|') + ')' },
          ],
        },
        r.CSS_VARIABLE,
        { className: 'attribute', begin: '\\b(' + St.join('|') + ')\\b' },
        {
          begin: /:/,
          end: /[;}{]/,
          contains: [
            r.BLOCK_COMMENT,
            r.HEXCOLOR,
            r.IMPORTANT,
            r.CSS_NUMBER_MODE,
            ...n,
            {
              begin: /(url|data-uri)\(/,
              end: /\)/,
              relevance: 0,
              keywords: { built_in: 'url data-uri' },
              contains: [
                ...n,
                { className: 'string', begin: /[^)]/, endsWithParent: !0, excludeEnd: !0 },
              ],
            },
            r.FUNCTION_DISPATCH,
          ],
        },
        {
          begin: t.lookahead(/@/),
          end: '[{;]',
          relevance: 0,
          illegal: /:/,
          contains: [
            { className: 'keyword', begin: /@-?\w[\w]*(-\w+)*/ },
            {
              begin: /\s/,
              endsWithParent: !0,
              excludeEnd: !0,
              relevance: 0,
              keywords: {
                $pattern: /[a-z-]+/,
                keyword: 'and or not only',
                attribute: wt.join(' '),
              },
              contains: [
                { begin: /[a-z-]+(?=:)/, className: 'attribute' },
                ...n,
                r.CSS_NUMBER_MODE,
              ],
            },
          ],
        },
        { className: 'selector-tag', begin: '\\b(' + Ct.join('|') + ')\\b' },
      ],
    };
  },
  diff: function (e) {
    const t = e.regex;
    return {
      name: 'Diff',
      aliases: ['patch'],
      contains: [
        {
          className: 'meta',
          relevance: 10,
          match: t.either(
            /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
            /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
            /^--- +\d+,\d+ +----$/
          ),
        },
        {
          className: 'comment',
          variants: [
            {
              begin: t.either(
                /Index: /,
                /^index/,
                /={3,}/,
                /^-{3}/,
                /^\*{3} /,
                /^\+{3}/,
                /^diff --git/
              ),
              end: /$/,
            },
            { match: /^\*{15}$/ },
          ],
        },
        { className: 'addition', begin: /^\+/, end: /$/ },
        { className: 'deletion', begin: /^-/, end: /$/ },
        { className: 'addition', begin: /^!/, end: /$/ },
      ],
    };
  },
  go: function (e) {
    const t = {
      keyword: [
        'break',
        'case',
        'chan',
        'const',
        'continue',
        'default',
        'defer',
        'else',
        'fallthrough',
        'for',
        'func',
        'go',
        'goto',
        'if',
        'import',
        'interface',
        'map',
        'package',
        'range',
        'return',
        'select',
        'struct',
        'switch',
        'type',
        'var',
      ],
      type: [
        'bool',
        'byte',
        'complex64',
        'complex128',
        'error',
        'float32',
        'float64',
        'int8',
        'int16',
        'int32',
        'int64',
        'string',
        'uint8',
        'uint16',
        'uint32',
        'uint64',
        'int',
        'uint',
        'uintptr',
        'rune',
      ],
      literal: ['true', 'false', 'iota', 'nil'],
      built_in: [
        'append',
        'cap',
        'close',
        'complex',
        'copy',
        'imag',
        'len',
        'make',
        'new',
        'panic',
        'print',
        'println',
        'real',
        'recover',
        'delete',
      ],
    };
    return {
      name: 'Go',
      aliases: ['golang'],
      keywords: t,
      illegal: '</',
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        {
          className: 'string',
          variants: [e.QUOTE_STRING_MODE, e.APOS_STRING_MODE, { begin: '`', end: '`' }],
        },
        {
          className: 'number',
          variants: [
            { match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/, relevance: 0 },
            {
              match:
                /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
              relevance: 0,
            },
            { match: /-?\b0[oO](_?[0-7])*i?/, relevance: 0 },
            { match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 },
            { match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 },
          ],
        },
        { begin: /:=/ },
        {
          className: 'function',
          beginKeywords: 'func',
          end: '\\s*(\\{|$)',
          excludeEnd: !0,
          contains: [
            e.TITLE_MODE,
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              endsParent: !0,
              keywords: t,
              illegal: /["']/,
            },
          ],
        },
      ],
    };
  },
  graphql: function (e) {
    const t = e.regex;
    return {
      name: 'GraphQL',
      aliases: ['gql'],
      case_insensitive: !0,
      disableAutodetect: !1,
      keywords: {
        keyword: [
          'query',
          'mutation',
          'subscription',
          'type',
          'input',
          'schema',
          'directive',
          'interface',
          'union',
          'scalar',
          'fragment',
          'enum',
          'on',
        ],
        literal: ['true', 'false', 'null'],
      },
      contains: [
        e.HASH_COMMENT_MODE,
        e.QUOTE_STRING_MODE,
        e.NUMBER_MODE,
        { scope: 'punctuation', match: /[.]{3}/, relevance: 0 },
        { scope: 'punctuation', begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/, relevance: 0 },
        { scope: 'variable', begin: /\$/, end: /\W/, excludeEnd: !0, relevance: 0 },
        { scope: 'meta', match: /@\w+/, excludeEnd: !0 },
        {
          scope: 'symbol',
          begin: t.concat(/[_A-Za-z][_0-9A-Za-z]*/, t.lookahead(/\s*:/)),
          relevance: 0,
        },
      ],
      illegal: [/[;<']/, /BEGIN/],
    };
  },
  ini: function (e) {
    const t = e.regex,
      r = {
        className: 'number',
        relevance: 0,
        variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: e.NUMBER_RE }],
      },
      n = e.COMMENT();
    n.variants = [
      { begin: /;/, end: /$/ },
      { begin: /#/, end: /$/ },
    ];
    const i = {
        className: 'variable',
        variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }],
      },
      a = { className: 'literal', begin: /\bon|off|true|false|yes|no\b/ },
      o = {
        className: 'string',
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          { begin: "'''", end: "'''", relevance: 10 },
          { begin: '"""', end: '"""', relevance: 10 },
          { begin: '"', end: '"' },
          { begin: "'", end: "'" },
        ],
      },
      s = { begin: /\[/, end: /\]/, contains: [n, a, i, o, r, 'self'], relevance: 0 },
      l = t.either(/[A-Za-z0-9_-]+/, /"(\\"|[^"])*"/, /'[^']*'/);
    return {
      name: 'TOML, also INI',
      aliases: ['toml'],
      case_insensitive: !0,
      illegal: /\S/,
      contains: [
        n,
        { className: 'section', begin: /\[+/, end: /\]+/ },
        {
          begin: t.concat(l, '(\\s*\\.\\s*', l, ')*', t.lookahead(/\s*=\s*[^#\s]/)),
          className: 'attr',
          starts: { end: /$/, contains: [n, s, a, i, o, r] },
        },
      ],
    };
  },
  java: function (e) {
    const t = e.regex,
      r = '[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*',
      n = r + Ft('(?:<' + r + '~~~(?:\\s*,\\s*' + r + '~~~)*>)?', /~~~/g, 2),
      i = {
        keyword: [
          'synchronized',
          'abstract',
          'private',
          'var',
          'static',
          'if',
          'const ',
          'for',
          'while',
          'strictfp',
          'finally',
          'protected',
          'import',
          'native',
          'final',
          'void',
          'enum',
          'else',
          'break',
          'transient',
          'catch',
          'instanceof',
          'volatile',
          'case',
          'assert',
          'package',
          'default',
          'public',
          'try',
          'switch',
          'continue',
          'throws',
          'protected',
          'public',
          'private',
          'module',
          'requires',
          'exports',
          'do',
          'sealed',
          'yield',
          'permits',
          'goto',
          'when',
        ],
        literal: ['false', 'true', 'null'],
        type: ['char', 'boolean', 'long', 'float', 'int', 'byte', 'short', 'double'],
        built_in: ['super', 'this'],
      },
      a = {
        className: 'meta',
        begin: '@' + r,
        contains: [{ begin: /\(/, end: /\)/, contains: ['self'] }],
      },
      o = {
        className: 'params',
        begin: /\(/,
        end: /\)/,
        keywords: i,
        relevance: 0,
        contains: [e.C_BLOCK_COMMENT_MODE],
        endsParent: !0,
      };
    return {
      name: 'Java',
      aliases: ['jsp'],
      keywords: i,
      illegal: /<\/|#/,
      contains: [
        e.COMMENT('/\\*\\*', '\\*/', {
          relevance: 0,
          contains: [
            { begin: /\w+@/, relevance: 0 },
            { className: 'doctag', begin: '@[A-Za-z]+' },
          ],
        }),
        { begin: /import java\.[a-z]+\./, keywords: 'import', relevance: 2 },
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        { begin: /"""/, end: /"""/, className: 'string', contains: [e.BACKSLASH_ESCAPE] },
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
        {
          match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, r],
          className: { 1: 'keyword', 3: 'title.class' },
        },
        { match: /non-sealed/, scope: 'keyword' },
        {
          begin: [t.concat(/(?!else)/, r), /\s+/, r, /\s+/, /=(?!=)/],
          className: { 1: 'type', 3: 'variable', 5: 'operator' },
        },
        {
          begin: [/record/, /\s+/, r],
          className: { 1: 'keyword', 3: 'title.class' },
          contains: [o, e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE],
        },
        { beginKeywords: 'new throw return else', relevance: 0 },
        {
          begin: ['(?:' + n + '\\s+)', e.UNDERSCORE_IDENT_RE, /\s*(?=\()/],
          className: { 2: 'title.function' },
          keywords: i,
          contains: [
            {
              className: 'params',
              begin: /\(/,
              end: /\)/,
              keywords: i,
              relevance: 0,
              contains: [a, e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, Tt, e.C_BLOCK_COMMENT_MODE],
            },
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
          ],
        },
        Tt,
        a,
      ],
    };
  },
  javascript: function (e) {
    const t = e.regex,
      r = Bt,
      n = '<>',
      i = '</>',
      a = {
        begin: /<[A-Za-z0-9\\._:-]+/,
        end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
        isTrulyOpeningTag: (e, t) => {
          const r = e[0].length + e.index,
            n = e.input[r];
          if ('<' === n || ',' === n) return void t.ignoreMatch();
          let i;
          '>' === n &&
            (((e, { after: t }) => {
              const r = '</' + e[0].slice(1);
              return -1 !== e.input.indexOf(r, t);
            })(e, { after: r }) ||
              t.ignoreMatch());
          const a = e.input.substring(r);
          ((i = a.match(/^\s*=/)) || ((i = a.match(/^\s+extends\s+/)) && 0 === i.index)) &&
            t.ignoreMatch();
        },
      },
      o = { $pattern: Bt, keyword: Mt, literal: Nt, built_in: Rt, 'variable.language': It },
      s = '[0-9](_?[0-9])*',
      l = `\\.(${s})`,
      c = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*',
      h = {
        className: 'number',
        variants: [
          { begin: `(\\b(${c})((${l})|\\.)?|(${l}))[eE][+-]?(${s})\\b` },
          { begin: `\\b(${c})\\b((${l})\\b|\\.)?|(${l})\\b` },
          { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
          { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
          { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
          { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
          { begin: '\\b0[0-7]+n?\\b' },
        ],
        relevance: 0,
      },
      d = { className: 'subst', begin: '\\$\\{', end: '\\}', keywords: o, contains: [] },
      u = {
        begin: '.?html`',
        end: '',
        starts: { end: '`', returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, d], subLanguage: 'xml' },
      },
      p = {
        begin: '.?css`',
        end: '',
        starts: { end: '`', returnEnd: !1, contains: [e.BACKSLASH_ESCAPE, d], subLanguage: 'css' },
      },
      g = {
        begin: '.?gql`',
        end: '',
        starts: {
          end: '`',
          returnEnd: !1,
          contains: [e.BACKSLASH_ESCAPE, d],
          subLanguage: 'graphql',
        },
      },
      f = { className: 'string', begin: '`', end: '`', contains: [e.BACKSLASH_ESCAPE, d] },
      m = {
        className: 'comment',
        variants: [
          e.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
            relevance: 0,
            contains: [
              {
                begin: '(?=@[A-Za-z]+)',
                relevance: 0,
                contains: [
                  { className: 'doctag', begin: '@[A-Za-z]+' },
                  {
                    className: 'type',
                    begin: '\\{',
                    end: '\\}',
                    excludeEnd: !0,
                    excludeBegin: !0,
                    relevance: 0,
                  },
                  {
                    className: 'variable',
                    begin: r + '(?=\\s*(-)|$)',
                    endsParent: !0,
                    relevance: 0,
                  },
                  { begin: /(?=[^\n])\s/, relevance: 0 },
                ],
              },
            ],
          }),
          e.C_BLOCK_COMMENT_MODE,
          e.C_LINE_COMMENT_MODE,
        ],
      },
      b = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, u, p, g, f, { match: /\$\d+/ }, h];
    d.contains = b.concat({ begin: /\{/, end: /\}/, keywords: o, contains: ['self'].concat(b) });
    const y = [].concat(m, d.contains),
      x = y.concat([{ begin: /(\s*)\(/, end: /\)/, keywords: o, contains: ['self'].concat(y) }]),
      k = {
        className: 'params',
        begin: /(\s*)\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: o,
        contains: x,
      },
      C = {
        variants: [
          {
            match: [
              /class/,
              /\s+/,
              r,
              /\s+/,
              /extends/,
              /\s+/,
              t.concat(r, '(', t.concat(/\./, r), ')*'),
            ],
            scope: { 1: 'keyword', 3: 'title.class', 5: 'keyword', 7: 'title.class.inherited' },
          },
          { match: [/class/, /\s+/, r], scope: { 1: 'keyword', 3: 'title.class' } },
        ],
      },
      w = {
        relevance: 0,
        match: t.either(
          /\bJSON/,
          /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
          /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
          /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
        ),
        className: 'title.class',
        keywords: { _: [...Lt, ...Ot] },
      },
      v = {
        variants: [
          { match: [/function/, /\s+/, r, /(?=\s*\()/] },
          { match: [/function/, /\s*(?=\()/] },
        ],
        className: { 1: 'keyword', 3: 'title.function' },
        label: 'func.def',
        contains: [k],
        illegal: /%/,
      },
      _ = {
        match: t.concat(
          /\b/,
          ((S = [...$t, 'super', 'import'].map((e) => `${e}\\s*\\(`)),
          t.concat('(?!', S.join('|'), ')')),
          r,
          t.lookahead(/\s*\(/)
        ),
        className: 'title.function',
        relevance: 0,
      };
    var S;
    const E = {
        begin: t.concat(/\./, t.lookahead(t.concat(r, /(?![0-9A-Za-z$_(])/))),
        end: r,
        excludeBegin: !0,
        keywords: 'prototype',
        className: 'property',
        relevance: 0,
      },
      D = {
        match: [/get|set/, /\s+/, r, /(?=\()/],
        className: { 1: 'keyword', 3: 'title.function' },
        contains: [{ begin: /\(\)/ }, k],
      },
      A =
        '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
        e.UNDERSCORE_IDENT_RE +
        ')\\s*=>',
      T = {
        match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(A)],
        keywords: 'async',
        className: { 1: 'keyword', 3: 'title.function' },
        contains: [k],
      };
    return {
      name: 'JavaScript',
      aliases: ['js', 'jsx', 'mjs', 'cjs'],
      keywords: o,
      exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: w },
      illegal: /#(?![$_A-z])/,
      contains: [
        e.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
        {
          label: 'use_strict',
          className: 'meta',
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/,
        },
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
        u,
        p,
        g,
        f,
        m,
        { match: /\$\d+/ },
        h,
        w,
        { scope: 'attr', match: r + t.lookahead(':'), relevance: 0 },
        T,
        {
          begin: '(' + e.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
          keywords: 'return throw case',
          relevance: 0,
          contains: [
            m,
            e.REGEXP_MODE,
            {
              className: 'function',
              begin: A,
              returnBegin: !0,
              end: '\\s*=>',
              contains: [
                {
                  className: 'params',
                  variants: [
                    { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                    { className: null, begin: /\(\s*\)/, skip: !0 },
                    {
                      begin: /(\s*)\(/,
                      end: /\)/,
                      excludeBegin: !0,
                      excludeEnd: !0,
                      keywords: o,
                      contains: x,
                    },
                  ],
                },
              ],
            },
            { begin: /,/, relevance: 0 },
            { match: /\s+/, relevance: 0 },
            {
              variants: [
                { begin: n, end: i },
                { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ },
                { begin: a.begin, 'on:begin': a.isTrulyOpeningTag, end: a.end },
              ],
              subLanguage: 'xml',
              contains: [{ begin: a.begin, end: a.end, skip: !0, contains: ['self'] }],
            },
          ],
        },
        v,
        { beginKeywords: 'while if switch catch for' },
        {
          begin:
            '\\b(?!function)' +
            e.UNDERSCORE_IDENT_RE +
            '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
          returnBegin: !0,
          label: 'func.def',
          contains: [k, e.inherit(e.TITLE_MODE, { begin: r, className: 'title.function' })],
        },
        { match: /\.\.\./, relevance: 0 },
        E,
        { match: '\\$' + r, relevance: 0 },
        { match: [/\bconstructor(?=\s*\()/], className: { 1: 'title.function' }, contains: [k] },
        _,
        { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' },
        C,
        D,
        { match: /\$[(.]/ },
      ],
    };
  },
  json: function (e) {
    const t = ['true', 'false', 'null'],
      r = { scope: 'literal', beginKeywords: t.join(' ') };
    return {
      name: 'JSON',
      aliases: ['jsonc'],
      keywords: { literal: t },
      contains: [
        { className: 'attr', begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 },
        { match: /[{}[\],:]/, className: 'punctuation', relevance: 0 },
        e.QUOTE_STRING_MODE,
        r,
        e.C_NUMBER_MODE,
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
      ],
      illegal: '\\S',
    };
  },
  kotlin: function (e) {
    const t = {
        keyword:
          'abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual',
        built_in: 'Byte Short Char Int Long Boolean Float Double Void Unit Nothing',
        literal: 'true false null',
      },
      r = { className: 'symbol', begin: e.UNDERSCORE_IDENT_RE + '@' },
      n = { className: 'subst', begin: /\$\{/, end: /\}/, contains: [e.C_NUMBER_MODE] },
      i = { className: 'variable', begin: '\\$' + e.UNDERSCORE_IDENT_RE },
      a = {
        className: 'string',
        variants: [
          { begin: '"""', end: '"""(?=[^"])', contains: [i, n] },
          { begin: "'", end: "'", illegal: /\n/, contains: [e.BACKSLASH_ESCAPE] },
          { begin: '"', end: '"', illegal: /\n/, contains: [e.BACKSLASH_ESCAPE, i, n] },
        ],
      };
    n.contains.push(a);
    const o = {
        className: 'meta',
        begin:
          '@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*' +
          e.UNDERSCORE_IDENT_RE +
          ')?',
      },
      s = {
        className: 'meta',
        begin: '@' + e.UNDERSCORE_IDENT_RE,
        contains: [
          { begin: /\(/, end: /\)/, contains: [e.inherit(a, { className: 'string' }), 'self'] },
        ],
      },
      l = qt,
      c = e.COMMENT('/\\*', '\\*/', { contains: [e.C_BLOCK_COMMENT_MODE] }),
      h = {
        variants: [
          { className: 'type', begin: e.UNDERSCORE_IDENT_RE },
          { begin: /\(/, end: /\)/, contains: [] },
        ],
      },
      d = h;
    return (
      (d.variants[1].contains = [h]),
      (h.variants[1].contains = [d]),
      {
        name: 'Kotlin',
        aliases: ['kt', 'kts'],
        keywords: t,
        contains: [
          e.COMMENT('/\\*\\*', '\\*/', {
            relevance: 0,
            contains: [{ className: 'doctag', begin: '@[A-Za-z]+' }],
          }),
          e.C_LINE_COMMENT_MODE,
          c,
          {
            className: 'keyword',
            begin: /\b(break|continue|return|this)\b/,
            starts: { contains: [{ className: 'symbol', begin: /@\w+/ }] },
          },
          r,
          o,
          s,
          {
            className: 'function',
            beginKeywords: 'fun',
            end: '[(]|$',
            returnBegin: !0,
            excludeEnd: !0,
            keywords: t,
            relevance: 5,
            contains: [
              {
                begin: e.UNDERSCORE_IDENT_RE + '\\s*\\(',
                returnBegin: !0,
                relevance: 0,
                contains: [e.UNDERSCORE_TITLE_MODE],
              },
              { className: 'type', begin: /</, end: />/, keywords: 'reified', relevance: 0 },
              {
                className: 'params',
                begin: /\(/,
                end: /\)/,
                endsParent: !0,
                keywords: t,
                relevance: 0,
                contains: [
                  {
                    begin: /:/,
                    end: /[=,\/]/,
                    endsWithParent: !0,
                    contains: [h, e.C_LINE_COMMENT_MODE, c],
                    relevance: 0,
                  },
                  e.C_LINE_COMMENT_MODE,
                  c,
                  o,
                  s,
                  a,
                  e.C_NUMBER_MODE,
                ],
              },
              c,
            ],
          },
          {
            begin: [/class|interface|trait/, /\s+/, e.UNDERSCORE_IDENT_RE],
            beginScope: { 3: 'title.class' },
            keywords: 'class interface trait',
            end: /[:\{(]|$/,
            excludeEnd: !0,
            illegal: 'extends implements',
            contains: [
              { beginKeywords: 'public protected internal private constructor' },
              e.UNDERSCORE_TITLE_MODE,
              {
                className: 'type',
                begin: /</,
                end: />/,
                excludeBegin: !0,
                excludeEnd: !0,
                relevance: 0,
              },
              {
                className: 'type',
                begin: /[,:]\s*/,
                end: /[<\(,){\s]|$/,
                excludeBegin: !0,
                returnEnd: !0,
              },
              o,
              s,
            ],
          },
          a,
          { className: 'meta', begin: '^#!/usr/bin/env', end: '$', illegal: '\n' },
          l,
        ],
      }
    );
  },
  less: function (e) {
    const t = ((e) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: 'selector-attr',
          begin: /\[/,
          end: /\]/,
          illegal: '$',
          contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
          scope: 'number',
          begin:
            e.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
          relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
      }))(e),
      r = Zt,
      n = '[\\w-]+',
      i = '(' + n + '|@\\{' + n + '\\})',
      a = [],
      o = [],
      s = function (e) {
        return { className: 'string', begin: '~?' + e + '.*?' + e };
      },
      l = function (e, t, r) {
        return { className: e, begin: t, relevance: r };
      },
      c = { $pattern: /[a-z-]+/, keyword: 'and or not only', attribute: Ut.join(' ') },
      h = { begin: '\\(', end: '\\)', contains: o, keywords: c, relevance: 0 };
    o.push(
      e.C_LINE_COMMENT_MODE,
      e.C_BLOCK_COMMENT_MODE,
      s("'"),
      s('"'),
      t.CSS_NUMBER_MODE,
      {
        begin: '(url|data-uri)\\(',
        starts: { className: 'string', end: '[\\)\\n]', excludeEnd: !0 },
      },
      t.HEXCOLOR,
      h,
      l('variable', '@@?' + n, 10),
      l('variable', '@\\{' + n + '\\}'),
      l('built_in', '~?`[^`]*?`'),
      { className: 'attribute', begin: n + '\\s*:', end: ':', returnBegin: !0, excludeEnd: !0 },
      t.IMPORTANT,
      { beginKeywords: 'and not' },
      t.FUNCTION_DISPATCH
    );
    const d = o.concat({ begin: /\{/, end: /\}/, contains: a }),
      u = {
        beginKeywords: 'when',
        endsWithParent: !0,
        contains: [{ beginKeywords: 'and not' }].concat(o),
      },
      p = {
        begin: i + '\\s*:',
        returnBegin: !0,
        end: /[;}]/,
        relevance: 0,
        contains: [
          { begin: /-(webkit|moz|ms|o)-/ },
          t.CSS_VARIABLE,
          {
            className: 'attribute',
            begin: '\\b(' + Vt.join('|') + ')\\b',
            end: /(?=:)/,
            starts: { endsWithParent: !0, illegal: '[<=$]', relevance: 0, contains: o },
          },
        ],
      },
      g = {
        className: 'keyword',
        begin:
          '@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b',
        starts: { end: '[;{}]', keywords: c, returnEnd: !0, contains: o, relevance: 0 },
      },
      f = {
        className: 'variable',
        variants: [{ begin: '@' + n + '\\s*:', relevance: 15 }, { begin: '@' + n }],
        starts: { end: '[;}]', returnEnd: !0, contains: d },
      },
      m = {
        variants: [
          { begin: '[\\.#:&\\[>]', end: '[;{}]' },
          { begin: i, end: /\{/ },
        ],
        returnBegin: !0,
        returnEnd: !0,
        illegal: '[<=\'$"]',
        relevance: 0,
        contains: [
          e.C_LINE_COMMENT_MODE,
          e.C_BLOCK_COMMENT_MODE,
          u,
          l('keyword', 'all\\b'),
          l('variable', '@\\{' + n + '\\}'),
          { begin: '\\b(' + Wt.join('|') + ')\\b', className: 'selector-tag' },
          t.CSS_NUMBER_MODE,
          l('selector-tag', i, 0),
          l('selector-id', '#' + i),
          l('selector-class', '\\.' + i, 0),
          l('selector-tag', '&', 0),
          t.ATTRIBUTE_SELECTOR_MODE,
          { className: 'selector-pseudo', begin: ':(' + Ht.join('|') + ')' },
          { className: 'selector-pseudo', begin: ':(:)?(' + Gt.join('|') + ')' },
          { begin: /\(/, end: /\)/, relevance: 0, contains: d },
          { begin: '!important' },
          t.FUNCTION_DISPATCH,
        ],
      },
      b = { begin: n + `:(:)?(${r.join('|')})`, returnBegin: !0, contains: [m] };
    return (
      a.push(e.C_LINE_COMMENT_MODE, e.C_BLOCK_COMMENT_MODE, g, f, b, p, m, u, t.FUNCTION_DISPATCH),
      { name: 'Less', case_insensitive: !0, illegal: '[=>\'/<($"]', contains: a }
    );
  },
  lua: function (e) {
    const t = '\\[=*\\[',
      r = '\\]=*\\]',
      n = { begin: t, end: r, contains: ['self'] },
      i = [
        e.COMMENT('--(?!' + t + ')', '$'),
        e.COMMENT('--' + t, r, { contains: [n], relevance: 10 }),
      ];
    return {
      name: 'Lua',
      aliases: ['pluto'],
      keywords: {
        $pattern: e.UNDERSCORE_IDENT_RE,
        literal: 'true false nil',
        keyword:
          'and break do else elseif end for goto if in local not or repeat return then until while',
        built_in:
          '_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove',
      },
      contains: i.concat([
        {
          className: 'function',
          beginKeywords: 'function',
          end: '\\)',
          contains: [
            e.inherit(e.TITLE_MODE, { begin: '([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*' }),
            { className: 'params', begin: '\\(', endsWithParent: !0, contains: i },
          ].concat(i),
        },
        e.C_NUMBER_MODE,
        e.APOS_STRING_MODE,
        e.QUOTE_STRING_MODE,
        { className: 'string', begin: t, end: r, contains: [n], relevance: 5 },
      ]),
    };
  },
  makefile: function (e) {
    const t = {
        className: 'variable',
        variants: [
          { begin: '\\$\\(' + e.UNDERSCORE_IDENT_RE + '\\)', contains: [e.BACKSLASH_ESCAPE] },
          { begin: /\$[@%<?\^\+\*]/ },
        ],
      },
      r = { className: 'string', begin: /"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, t] },
      n = {
        className: 'variable',
        begin: /\$\([\w-]+\s/,
        end: /\)/,
        keywords: {
          built_in:
            'subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value',
        },
        contains: [t, r],
      },
      i = { begin: '^' + e.UNDERSCORE_IDENT_RE + '\\s*(?=[:+?]?=)' },
      a = { className: 'section', begin: /^[^\s]+:/, end: /$/, contains: [t] };
    return {
      name: 'Makefile',
      aliases: ['mk', 'mak', 'make'],
      keywords: {
        $pattern: /[\w-]+/,
        keyword:
          'define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath',
      },
      contains: [
        e.HASH_COMMENT_MODE,
        t,
        r,
        n,
        i,
        {
          className: 'meta',
          begin: /^\.PHONY:/,
          end: /$/,
          keywords: { $pattern: /[\.\w]+/, keyword: '.PHONY' },
        },
        a,
      ],
    };
  },
  markdown: function (e) {
    const t = { begin: /<\/?[A-Za-z_]/, end: '>', subLanguage: 'xml', relevance: 0 },
      r = {
        variants: [
          { begin: /\[.+?\]\[.*?\]/, relevance: 0 },
          { begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 },
          {
            begin: e.regex.concat(/\[.+?\]\(/, /[A-Za-z][A-Za-z0-9+.-]*/, /:\/\/.*?\)/),
            relevance: 2,
          },
          { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 },
          { begin: /\[.*?\]\(.*?\)/, relevance: 0 },
        ],
        returnBegin: !0,
        contains: [
          { match: /\[(?=\])/ },
          {
            className: 'string',
            relevance: 0,
            begin: '\\[',
            end: '\\]',
            excludeBegin: !0,
            returnEnd: !0,
          },
          {
            className: 'link',
            relevance: 0,
            begin: '\\]\\(',
            end: '\\)',
            excludeBegin: !0,
            excludeEnd: !0,
          },
          {
            className: 'symbol',
            relevance: 0,
            begin: '\\]\\[',
            end: '\\]',
            excludeBegin: !0,
            excludeEnd: !0,
          },
        ],
      },
      n = {
        className: 'strong',
        contains: [],
        variants: [
          { begin: /_{2}(?!\s)/, end: /_{2}/ },
          { begin: /\*{2}(?!\s)/, end: /\*{2}/ },
        ],
      },
      i = {
        className: 'emphasis',
        contains: [],
        variants: [
          { begin: /\*(?![*\s])/, end: /\*/ },
          { begin: /_(?![_\s])/, end: /_/, relevance: 0 },
        ],
      },
      a = e.inherit(n, { contains: [] }),
      o = e.inherit(i, { contains: [] });
    (n.contains.push(o), i.contains.push(a));
    let s = [t, r];
    return (
      [n, i, a, o].forEach((e) => {
        e.contains = e.contains.concat(s);
      }),
      (s = s.concat(n, i)),
      {
        name: 'Markdown',
        aliases: ['md', 'mkdown', 'mkd'],
        contains: [
          {
            className: 'section',
            variants: [
              { begin: '^#{1,6}', end: '$', contains: s },
              {
                begin: '(?=^.+?\\n[=-]{2,}$)',
                contains: [{ begin: '^[=-]*$' }, { begin: '^', end: '\\n', contains: s }],
              },
            ],
          },
          t,
          {
            className: 'bullet',
            begin: '^[ \t]*([*+-]|(\\d+\\.))(?=\\s+)',
            end: '\\s+',
            excludeEnd: !0,
          },
          n,
          i,
          { className: 'quote', begin: '^>\\s+', contains: s, end: '$' },
          {
            className: 'code',
            variants: [
              { begin: '(`{3,})[^`](.|\\n)*?\\1`*[ ]*' },
              { begin: '(~{3,})[^~](.|\\n)*?\\1~*[ ]*' },
              { begin: '```', end: '```+[ ]*$' },
              { begin: '~~~', end: '~~~+[ ]*$' },
              { begin: '`.+?`' },
              {
                begin: '(?=^( {4}|\\t))',
                contains: [{ begin: '^( {4}|\\t)', end: '(\\n)$' }],
                relevance: 0,
              },
            ],
          },
          { begin: '^[-\\*]{3,}', end: '$' },
          r,
          {
            begin: /^\[[^\n]+\]:/,
            returnBegin: !0,
            contains: [
              { className: 'symbol', begin: /\[/, end: /\]/, excludeBegin: !0, excludeEnd: !0 },
              { className: 'link', begin: /:\s*/, end: /$/, excludeBegin: !0 },
            ],
          },
          { scope: 'literal', match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/ },
        ],
      }
    );
  },
  objectivec: function (e) {
    const t = /[a-zA-Z@][a-zA-Z0-9_]*/,
      r = { $pattern: t, keyword: ['@interface', '@class', '@protocol', '@implementation'] };
    return {
      name: 'Objective-C',
      aliases: ['mm', 'objc', 'obj-c', 'obj-c++', 'objective-c++'],
      keywords: {
        'variable.language': ['this', 'super'],
        $pattern: t,
        keyword: [
          'while',
          'export',
          'sizeof',
          'typedef',
          'const',
          'struct',
          'for',
          'union',
          'volatile',
          'static',
          'mutable',
          'if',
          'do',
          'return',
          'goto',
          'enum',
          'else',
          'break',
          'extern',
          'asm',
          'case',
          'default',
          'register',
          'explicit',
          'typename',
          'switch',
          'continue',
          'inline',
          'readonly',
          'assign',
          'readwrite',
          'self',
          '@synchronized',
          'id',
          'typeof',
          'nonatomic',
          'IBOutlet',
          'IBAction',
          'strong',
          'weak',
          'copy',
          'in',
          'out',
          'inout',
          'bycopy',
          'byref',
          'oneway',
          '__strong',
          '__weak',
          '__block',
          '__autoreleasing',
          '@private',
          '@protected',
          '@public',
          '@try',
          '@property',
          '@end',
          '@throw',
          '@catch',
          '@finally',
          '@autoreleasepool',
          '@synthesize',
          '@dynamic',
          '@selector',
          '@optional',
          '@required',
          '@encode',
          '@package',
          '@import',
          '@defs',
          '@compatibility_alias',
          '__bridge',
          '__bridge_transfer',
          '__bridge_retained',
          '__bridge_retain',
          '__covariant',
          '__contravariant',
          '__kindof',
          '_Nonnull',
          '_Nullable',
          '_Null_unspecified',
          '__FUNCTION__',
          '__PRETTY_FUNCTION__',
          '__attribute__',
          'getter',
          'setter',
          'retain',
          'unsafe_unretained',
          'nonnull',
          'nullable',
          'null_unspecified',
          'null_resettable',
          'class',
          'instancetype',
          'NS_DESIGNATED_INITIALIZER',
          'NS_UNAVAILABLE',
          'NS_REQUIRES_SUPER',
          'NS_RETURNS_INNER_POINTER',
          'NS_INLINE',
          'NS_AVAILABLE',
          'NS_DEPRECATED',
          'NS_ENUM',
          'NS_OPTIONS',
          'NS_SWIFT_UNAVAILABLE',
          'NS_ASSUME_NONNULL_BEGIN',
          'NS_ASSUME_NONNULL_END',
          'NS_REFINED_FOR_SWIFT',
          'NS_SWIFT_NAME',
          'NS_SWIFT_NOTHROW',
          'NS_DURING',
          'NS_HANDLER',
          'NS_ENDHANDLER',
          'NS_VALUERETURN',
          'NS_VOIDRETURN',
        ],
        literal: ['false', 'true', 'FALSE', 'TRUE', 'nil', 'YES', 'NO', 'NULL'],
        built_in: [
          'dispatch_once_t',
          'dispatch_queue_t',
          'dispatch_sync',
          'dispatch_async',
          'dispatch_once',
        ],
        type: [
          'int',
          'float',
          'char',
          'unsigned',
          'signed',
          'short',
          'long',
          'double',
          'wchar_t',
          'unichar',
          'void',
          'bool',
          'BOOL',
          'id|0',
          '_Bool',
        ],
      },
      illegal: '</',
      contains: [
        {
          className: 'built_in',
          begin: '\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+',
        },
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        e.C_NUMBER_MODE,
        e.QUOTE_STRING_MODE,
        e.APOS_STRING_MODE,
        {
          className: 'string',
          variants: [{ begin: '@"', end: '"', illegal: '\\n', contains: [e.BACKSLASH_ESCAPE] }],
        },
        {
          className: 'meta',
          begin: /#\s*[a-z]+\b/,
          end: /$/,
          keywords: {
            keyword:
              'if else elif endif define undef warning error line pragma ifdef ifndef include',
          },
          contains: [
            { begin: /\\\n/, relevance: 0 },
            e.inherit(e.QUOTE_STRING_MODE, { className: 'string' }),
            { className: 'string', begin: /<.*?>/, end: /$/, illegal: '\\n' },
            e.C_LINE_COMMENT_MODE,
            e.C_BLOCK_COMMENT_MODE,
          ],
        },
        {
          className: 'class',
          begin: '(' + r.keyword.join('|') + ')\\b',
          end: /(\{|$)/,
          excludeEnd: !0,
          keywords: r,
          contains: [e.UNDERSCORE_TITLE_MODE],
        },
        { begin: '\\.' + e.UNDERSCORE_IDENT_RE, relevance: 0 },
      ],
    };
  },
  perl: function (e) {
    const t = e.regex,
      r = /[dualxmsipngr]{0,12}/,
      n = {
        $pattern: /[\w.]+/,
        keyword: [
          'abs',
          'accept',
          'alarm',
          'and',
          'atan2',
          'bind',
          'binmode',
          'bless',
          'break',
          'caller',
          'chdir',
          'chmod',
          'chomp',
          'chop',
          'chown',
          'chr',
          'chroot',
          'class',
          'close',
          'closedir',
          'connect',
          'continue',
          'cos',
          'crypt',
          'dbmclose',
          'dbmopen',
          'defined',
          'delete',
          'die',
          'do',
          'dump',
          'each',
          'else',
          'elsif',
          'endgrent',
          'endhostent',
          'endnetent',
          'endprotoent',
          'endpwent',
          'endservent',
          'eof',
          'eval',
          'exec',
          'exists',
          'exit',
          'exp',
          'fcntl',
          'field',
          'fileno',
          'flock',
          'for',
          'foreach',
          'fork',
          'format',
          'formline',
          'getc',
          'getgrent',
          'getgrgid',
          'getgrnam',
          'gethostbyaddr',
          'gethostbyname',
          'gethostent',
          'getlogin',
          'getnetbyaddr',
          'getnetbyname',
          'getnetent',
          'getpeername',
          'getpgrp',
          'getpriority',
          'getprotobyname',
          'getprotobynumber',
          'getprotoent',
          'getpwent',
          'getpwnam',
          'getpwuid',
          'getservbyname',
          'getservbyport',
          'getservent',
          'getsockname',
          'getsockopt',
          'given',
          'glob',
          'gmtime',
          'goto',
          'grep',
          'gt',
          'hex',
          'if',
          'index',
          'int',
          'ioctl',
          'join',
          'keys',
          'kill',
          'last',
          'lc',
          'lcfirst',
          'length',
          'link',
          'listen',
          'local',
          'localtime',
          'log',
          'lstat',
          'lt',
          'ma',
          'map',
          'method',
          'mkdir',
          'msgctl',
          'msgget',
          'msgrcv',
          'msgsnd',
          'my',
          'ne',
          'next',
          'no',
          'not',
          'oct',
          'open',
          'opendir',
          'or',
          'ord',
          'our',
          'pack',
          'package',
          'pipe',
          'pop',
          'pos',
          'print',
          'printf',
          'prototype',
          'push',
          'q|0',
          'qq',
          'quotemeta',
          'qw',
          'qx',
          'rand',
          'read',
          'readdir',
          'readline',
          'readlink',
          'readpipe',
          'recv',
          'redo',
          'ref',
          'rename',
          'require',
          'reset',
          'return',
          'reverse',
          'rewinddir',
          'rindex',
          'rmdir',
          'say',
          'scalar',
          'seek',
          'seekdir',
          'select',
          'semctl',
          'semget',
          'semop',
          'send',
          'setgrent',
          'sethostent',
          'setnetent',
          'setpgrp',
          'setpriority',
          'setprotoent',
          'setpwent',
          'setservent',
          'setsockopt',
          'shift',
          'shmctl',
          'shmget',
          'shmread',
          'shmwrite',
          'shutdown',
          'sin',
          'sleep',
          'socket',
          'socketpair',
          'sort',
          'splice',
          'split',
          'sprintf',
          'sqrt',
          'srand',
          'stat',
          'state',
          'study',
          'sub',
          'substr',
          'symlink',
          'syscall',
          'sysopen',
          'sysread',
          'sysseek',
          'system',
          'syswrite',
          'tell',
          'telldir',
          'tie',
          'tied',
          'time',
          'times',
          'tr',
          'truncate',
          'uc',
          'ucfirst',
          'umask',
          'undef',
          'unless',
          'unlink',
          'unpack',
          'unshift',
          'untie',
          'until',
          'use',
          'utime',
          'values',
          'vec',
          'wait',
          'waitpid',
          'wantarray',
          'warn',
          'when',
          'while',
          'write',
          'x|0',
          'xor',
          'y|0',
        ].join(' '),
      },
      i = { className: 'subst', begin: '[$@]\\{', end: '\\}', keywords: n },
      a = { begin: /->\{/, end: /\}/ },
      o = { scope: 'attr', match: /\s+:\s*\w+(\s*\(.*?\))?/ },
      s = {
        scope: 'variable',
        variants: [
          { begin: /\$\d/ },
          {
            begin: t.concat(
              /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
              '(?![A-Za-z])(?![@$%])'
            ),
          },
          { begin: /[$%@](?!")[^\s\w{=]|\$=/, relevance: 0 },
        ],
        contains: [o],
      },
      l = {
        className: 'number',
        variants: [
          { match: /0?\.[0-9][0-9_]+\b/ },
          { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
          { match: /\b0[0-7][0-7_]*\b/ },
          { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
          { match: /\b0b[0-1][0-1_]*\b/ },
        ],
        relevance: 0,
      },
      c = [e.BACKSLASH_ESCAPE, i, s],
      h = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/],
      d = (e, n, i = '\\1') => {
        const a = '\\1' === i ? i : t.concat(i, n);
        return t.concat(
          t.concat('(?:', e, ')'),
          n,
          /(?:\\.|[^\\\/])*?/,
          a,
          /(?:\\.|[^\\\/])*?/,
          i,
          r
        );
      },
      u = (e, n, i) => t.concat(t.concat('(?:', e, ')'), n, /(?:\\.|[^\\\/])*?/, i, r),
      p = [
        s,
        e.HASH_COMMENT_MODE,
        e.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }),
        a,
        {
          className: 'string',
          contains: c,
          variants: [
            { begin: 'q[qwxr]?\\s*\\(', end: '\\)', relevance: 5 },
            { begin: 'q[qwxr]?\\s*\\[', end: '\\]', relevance: 5 },
            { begin: 'q[qwxr]?\\s*\\{', end: '\\}', relevance: 5 },
            { begin: 'q[qwxr]?\\s*\\|', end: '\\|', relevance: 5 },
            { begin: 'q[qwxr]?\\s*<', end: '>', relevance: 5 },
            { begin: 'qw\\s+q', end: 'q', relevance: 5 },
            { begin: "'", end: "'", contains: [e.BACKSLASH_ESCAPE] },
            { begin: '"', end: '"' },
            { begin: '`', end: '`', contains: [e.BACKSLASH_ESCAPE] },
            { begin: /\{\w+\}/, relevance: 0 },
            { begin: '-?\\w+\\s*=>', relevance: 0 },
          ],
        },
        l,
        {
          begin: '(\\/\\/|' + e.RE_STARTERS_RE + '|\\b(split|return|print|reverse|grep)\\b)\\s*',
          keywords: 'split return print reverse grep',
          relevance: 0,
          contains: [
            e.HASH_COMMENT_MODE,
            {
              className: 'regexp',
              variants: [
                { begin: d('s|tr|y', t.either(...h, { capture: !0 })) },
                { begin: d('s|tr|y', '\\(', '\\)') },
                { begin: d('s|tr|y', '\\[', '\\]') },
                { begin: d('s|tr|y', '\\{', '\\}') },
              ],
              relevance: 2,
            },
            {
              className: 'regexp',
              variants: [
                { begin: /(m|qr)\/\//, relevance: 0 },
                { begin: u('(?:m|qr)?', /\//, /\//) },
                { begin: u('m|qr', t.either(...h, { capture: !0 }), /\1/) },
                { begin: u('m|qr', /\(/, /\)/) },
                { begin: u('m|qr', /\[/, /\]/) },
                { begin: u('m|qr', /\{/, /\}/) },
              ],
            },
          ],
        },
        {
          className: 'function',
          beginKeywords: 'sub method',
          end: '(\\s*\\(.*?\\))?[;{]',
          excludeEnd: !0,
          relevance: 5,
          contains: [e.TITLE_MODE, o],
        },
        {
          className: 'class',
          beginKeywords: 'class',
          end: '[;{]',
          excludeEnd: !0,
          relevance: 5,
          contains: [e.TITLE_MODE, o, l],
        },
        { begin: '-\\w\\b', relevance: 0 },
        {
          begin: '^__DATA__$',
          end: '^__END__$',
          subLanguage: 'mojolicious',
          contains: [{ begin: '^@@.*', end: '$', className: 'comment' }],
        },
      ];
    return (
      (i.contains = p),
      (a.contains = p),
      { name: 'Perl', aliases: ['pl', 'pm'], keywords: n, contains: p }
    );
  },
  php: function (e) {
    const t = e.regex,
      r = /(?![A-Za-z0-9])(?![$])/,
      n = t.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, r),
      i = t.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, r),
      a = t.concat(/[A-Z]+/, r),
      o = { scope: 'variable', match: '\\$+' + n },
      s = { scope: 'subst', variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] },
      l = e.inherit(e.APOS_STRING_MODE, { illegal: null }),
      c = '[ \t\n]',
      h = {
        scope: 'string',
        variants: [
          e.inherit(e.QUOTE_STRING_MODE, {
            illegal: null,
            contains: e.QUOTE_STRING_MODE.contains.concat(s),
          }),
          l,
          {
            begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
            end: /[ \t]*(\w+)\b/,
            contains: e.QUOTE_STRING_MODE.contains.concat(s),
            'on:begin': (e, t) => {
              t.data._beginMatch = e[1] || e[2];
            },
            'on:end': (e, t) => {
              t.data._beginMatch !== e[1] && t.ignoreMatch();
            },
          },
          e.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*'(\w+)'\n/, end: /[ \t]*(\w+)\b/ }),
        ],
      },
      d = {
        scope: 'number',
        variants: [
          { begin: '\\b0[bB][01]+(?:_[01]+)*\\b' },
          { begin: '\\b0[oO][0-7]+(?:_[0-7]+)*\\b' },
          { begin: '\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b' },
          { begin: '(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?' },
        ],
        relevance: 0,
      },
      u = ['false', 'null', 'true'],
      p = [
        '__CLASS__',
        '__DIR__',
        '__FILE__',
        '__FUNCTION__',
        '__COMPILER_HALT_OFFSET__',
        '__LINE__',
        '__METHOD__',
        '__NAMESPACE__',
        '__TRAIT__',
        'die',
        'echo',
        'exit',
        'include',
        'include_once',
        'print',
        'require',
        'require_once',
        'array',
        'abstract',
        'and',
        'as',
        'binary',
        'bool',
        'boolean',
        'break',
        'callable',
        'case',
        'catch',
        'class',
        'clone',
        'const',
        'continue',
        'declare',
        'default',
        'do',
        'double',
        'else',
        'elseif',
        'empty',
        'enddeclare',
        'endfor',
        'endforeach',
        'endif',
        'endswitch',
        'endwhile',
        'enum',
        'eval',
        'extends',
        'final',
        'finally',
        'float',
        'for',
        'foreach',
        'from',
        'global',
        'goto',
        'if',
        'implements',
        'instanceof',
        'insteadof',
        'int',
        'integer',
        'interface',
        'isset',
        'iterable',
        'list',
        'match|0',
        'mixed',
        'new',
        'never',
        'object',
        'or',
        'private',
        'protected',
        'public',
        'readonly',
        'real',
        'return',
        'string',
        'switch',
        'throw',
        'trait',
        'try',
        'unset',
        'use',
        'var',
        'void',
        'while',
        'xor',
        'yield',
      ],
      g = [
        'Error|0',
        'AppendIterator',
        'ArgumentCountError',
        'ArithmeticError',
        'ArrayIterator',
        'ArrayObject',
        'AssertionError',
        'BadFunctionCallException',
        'BadMethodCallException',
        'CachingIterator',
        'CallbackFilterIterator',
        'CompileError',
        'Countable',
        'DirectoryIterator',
        'DivisionByZeroError',
        'DomainException',
        'EmptyIterator',
        'ErrorException',
        'Exception',
        'FilesystemIterator',
        'FilterIterator',
        'GlobIterator',
        'InfiniteIterator',
        'InvalidArgumentException',
        'IteratorIterator',
        'LengthException',
        'LimitIterator',
        'LogicException',
        'MultipleIterator',
        'NoRewindIterator',
        'OutOfBoundsException',
        'OutOfRangeException',
        'OuterIterator',
        'OverflowException',
        'ParentIterator',
        'ParseError',
        'RangeException',
        'RecursiveArrayIterator',
        'RecursiveCachingIterator',
        'RecursiveCallbackFilterIterator',
        'RecursiveDirectoryIterator',
        'RecursiveFilterIterator',
        'RecursiveIterator',
        'RecursiveIteratorIterator',
        'RecursiveRegexIterator',
        'RecursiveTreeIterator',
        'RegexIterator',
        'RuntimeException',
        'SeekableIterator',
        'SplDoublyLinkedList',
        'SplFileInfo',
        'SplFileObject',
        'SplFixedArray',
        'SplHeap',
        'SplMaxHeap',
        'SplMinHeap',
        'SplObjectStorage',
        'SplObserver',
        'SplPriorityQueue',
        'SplQueue',
        'SplStack',
        'SplSubject',
        'SplTempFileObject',
        'TypeError',
        'UnderflowException',
        'UnexpectedValueException',
        'UnhandledMatchError',
        'ArrayAccess',
        'BackedEnum',
        'Closure',
        'Fiber',
        'Generator',
        'Iterator',
        'IteratorAggregate',
        'Serializable',
        'Stringable',
        'Throwable',
        'Traversable',
        'UnitEnum',
        'WeakReference',
        'WeakMap',
        'Directory',
        '__PHP_Incomplete_Class',
        'parent',
        'php_user_filter',
        'self',
        'static',
        'stdClass',
      ],
      f = {
        keyword: p,
        literal: ((e) => {
          const t = [];
          return (
            e.forEach((e) => {
              (t.push(e),
                e.toLowerCase() === e ? t.push(e.toUpperCase()) : t.push(e.toLowerCase()));
            }),
            t
          );
        })(u),
        built_in: g,
      },
      m = (e) => e.map((e) => e.replace(/\|\d+$/, '')),
      b = {
        variants: [
          {
            match: [/new/, t.concat(c, '+'), t.concat('(?!', m(g).join('\\b|'), '\\b)'), i],
            scope: { 1: 'keyword', 4: 'title.class' },
          },
        ],
      },
      y = t.concat(n, '\\b(?!\\()'),
      x = {
        variants: [
          {
            match: [t.concat(/::/, t.lookahead(/(?!class\b)/)), y],
            scope: { 2: 'variable.constant' },
          },
          { match: [/::/, /class/], scope: { 2: 'variable.language' } },
          {
            match: [i, t.concat(/::/, t.lookahead(/(?!class\b)/)), y],
            scope: { 1: 'title.class', 3: 'variable.constant' },
          },
          { match: [i, t.concat('::', t.lookahead(/(?!class\b)/))], scope: { 1: 'title.class' } },
          { match: [i, /::/, /class/], scope: { 1: 'title.class', 3: 'variable.language' } },
        ],
      },
      k = { scope: 'attr', match: t.concat(n, t.lookahead(':'), t.lookahead(/(?!::)/)) },
      C = {
        relevance: 0,
        begin: /\(/,
        end: /\)/,
        keywords: f,
        contains: [k, o, x, e.C_BLOCK_COMMENT_MODE, h, d, b],
      },
      w = {
        relevance: 0,
        match: [
          /\b/,
          t.concat('(?!fn\\b|function\\b|', m(p).join('\\b|'), '|', m(g).join('\\b|'), '\\b)'),
          n,
          t.concat(c, '*'),
          t.lookahead(/(?=\()/),
        ],
        scope: { 3: 'title.function.invoke' },
        contains: [C],
      };
    C.contains.push(w);
    const v = [k, x, e.C_BLOCK_COMMENT_MODE, h, d, b],
      _ = {
        begin: t.concat(/#\[\s*\\?/, t.either(i, a)),
        beginScope: 'meta',
        end: /]/,
        endScope: 'meta',
        keywords: { literal: u, keyword: ['new', 'array'] },
        contains: [
          {
            begin: /\[/,
            end: /]/,
            keywords: { literal: u, keyword: ['new', 'array'] },
            contains: ['self', ...v],
          },
          ...v,
          { scope: 'meta', variants: [{ match: i }, { match: a }] },
        ],
      };
    return {
      case_insensitive: !1,
      keywords: f,
      contains: [
        _,
        e.HASH_COMMENT_MODE,
        e.COMMENT('//', '$'),
        e.COMMENT('/\\*', '\\*/', { contains: [{ scope: 'doctag', match: '@[A-Za-z]+' }] }),
        {
          match: /__halt_compiler\(\);/,
          keywords: '__halt_compiler',
          starts: {
            scope: 'comment',
            end: e.MATCH_NOTHING_RE,
            contains: [{ match: /\?>/, scope: 'meta', endsParent: !0 }],
          },
        },
        {
          scope: 'meta',
          variants: [
            { begin: /<\?php/, relevance: 10 },
            { begin: /<\?=/ },
            { begin: /<\?/, relevance: 0.1 },
            { begin: /\?>/ },
          ],
        },
        { scope: 'variable.language', match: /\$this\b/ },
        o,
        w,
        x,
        { match: [/const/, /\s/, n], scope: { 1: 'keyword', 3: 'variable.constant' } },
        b,
        {
          scope: 'function',
          relevance: 0,
          beginKeywords: 'fn function',
          end: /[;{]/,
          excludeEnd: !0,
          illegal: '[$%\\[]',
          contains: [
            { beginKeywords: 'use' },
            e.UNDERSCORE_TITLE_MODE,
            { begin: '=>', endsParent: !0 },
            {
              scope: 'params',
              begin: '\\(',
              end: '\\)',
              excludeBegin: !0,
              excludeEnd: !0,
              keywords: f,
              contains: ['self', _, o, x, e.C_BLOCK_COMMENT_MODE, h, d],
            },
          ],
        },
        {
          scope: 'class',
          variants: [
            { beginKeywords: 'enum', illegal: /[($"]/ },
            { beginKeywords: 'class interface trait', illegal: /[:($"]/ },
          ],
          relevance: 0,
          end: /\{/,
          excludeEnd: !0,
          contains: [{ beginKeywords: 'extends implements' }, e.UNDERSCORE_TITLE_MODE],
        },
        {
          beginKeywords: 'namespace',
          relevance: 0,
          end: ';',
          illegal: /[.']/,
          contains: [e.inherit(e.UNDERSCORE_TITLE_MODE, { scope: 'title.class' })],
        },
        {
          beginKeywords: 'use',
          relevance: 0,
          end: ';',
          contains: [
            { match: /\b(as|const|function)\b/, scope: 'keyword' },
            e.UNDERSCORE_TITLE_MODE,
          ],
        },
        h,
        d,
      ],
    };
  },
  'php-template': function (e) {
    return {
      name: 'PHP template',
      subLanguage: 'xml',
      contains: [
        {
          begin: /<\?(php|=)?/,
          end: /\?>/,
          subLanguage: 'php',
          contains: [
            { begin: '/\\*', end: '\\*/', skip: !0 },
            { begin: 'b"', end: '"', skip: !0 },
            { begin: "b'", end: "'", skip: !0 },
            e.inherit(e.APOS_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: !0,
            }),
            e.inherit(e.QUOTE_STRING_MODE, {
              illegal: null,
              className: null,
              contains: null,
              skip: !0,
            }),
          ],
        },
      ],
    };
  },
  plaintext: function (e) {
    return { name: 'Plain text', aliases: ['text', 'txt'], disableAutodetect: !0 };
  },
  python: function (e) {
    const t = e.regex,
      r = new RegExp('[\\p{XID_Start}_]\\p{XID_Continue}*', 'u'),
      n = [
        'and',
        'as',
        'assert',
        'async',
        'await',
        'break',
        'case',
        'class',
        'continue',
        'def',
        'del',
        'elif',
        'else',
        'except',
        'finally',
        'for',
        'from',
        'global',
        'if',
        'import',
        'in',
        'is',
        'lambda',
        'match',
        'nonlocal|10',
        'not',
        'or',
        'pass',
        'raise',
        'return',
        'try',
        'while',
        'with',
        'yield',
      ],
      i = {
        $pattern: /[A-Za-z]\w+|__\w+__/,
        keyword: n,
        built_in: [
          '__import__',
          'abs',
          'all',
          'any',
          'ascii',
          'bin',
          'bool',
          'breakpoint',
          'bytearray',
          'bytes',
          'callable',
          'chr',
          'classmethod',
          'compile',
          'complex',
          'delattr',
          'dict',
          'dir',
          'divmod',
          'enumerate',
          'eval',
          'exec',
          'filter',
          'float',
          'format',
          'frozenset',
          'getattr',
          'globals',
          'hasattr',
          'hash',
          'help',
          'hex',
          'id',
          'input',
          'int',
          'isinstance',
          'issubclass',
          'iter',
          'len',
          'list',
          'locals',
          'map',
          'max',
          'memoryview',
          'min',
          'next',
          'object',
          'oct',
          'open',
          'ord',
          'pow',
          'print',
          'property',
          'range',
          'repr',
          'reversed',
          'round',
          'set',
          'setattr',
          'slice',
          'sorted',
          'staticmethod',
          'str',
          'sum',
          'super',
          'tuple',
          'type',
          'vars',
          'zip',
        ],
        literal: ['__debug__', 'Ellipsis', 'False', 'None', 'NotImplemented', 'True'],
        type: [
          'Any',
          'Callable',
          'Coroutine',
          'Dict',
          'List',
          'Literal',
          'Generic',
          'Optional',
          'Sequence',
          'Set',
          'Tuple',
          'Type',
          'Union',
        ],
      },
      a = { className: 'meta', begin: /^(>>>|\.\.\.) / },
      o = { className: 'subst', begin: /\{/, end: /\}/, keywords: i, illegal: /#/ },
      s = { begin: /\{\{/, relevance: 0 },
      l = {
        className: 'string',
        contains: [e.BACKSLASH_ESCAPE],
        variants: [
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
            end: /'''/,
            contains: [e.BACKSLASH_ESCAPE, a],
            relevance: 10,
          },
          {
            begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
            end: /"""/,
            contains: [e.BACKSLASH_ESCAPE, a],
            relevance: 10,
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])'''/,
            end: /'''/,
            contains: [e.BACKSLASH_ESCAPE, a, s, o],
          },
          {
            begin: /([fF][rR]|[rR][fF]|[fF])"""/,
            end: /"""/,
            contains: [e.BACKSLASH_ESCAPE, a, s, o],
          },
          { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 },
          { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 },
          { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ },
          { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ },
          { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [e.BACKSLASH_ESCAPE, s, o] },
          { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [e.BACKSLASH_ESCAPE, s, o] },
          e.APOS_STRING_MODE,
          e.QUOTE_STRING_MODE,
        ],
      },
      c = '[0-9](_?[0-9])*',
      h = `(\\b(${c}))?\\.(${c})|\\b(${c})\\.`,
      d = `\\b|${n.join('|')}`,
      u = {
        className: 'number',
        relevance: 0,
        variants: [
          { begin: `(\\b(${c})|(${h}))[eE][+-]?(${c})[jJ]?(?=${d})` },
          { begin: `(${h})[jJ]?` },
          { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})` },
          { begin: `\\b0[bB](_?[01])+[lL]?(?=${d})` },
          { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})` },
          { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})` },
          { begin: `\\b(${c})[jJ](?=${d})` },
        ],
      },
      p = {
        className: 'comment',
        begin: t.lookahead(/# type:/),
        end: /$/,
        keywords: i,
        contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }],
      },
      g = {
        className: 'params',
        variants: [
          { className: '', begin: /\(\s*\)/, skip: !0 },
          {
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: i,
            contains: ['self', a, u, l, e.HASH_COMMENT_MODE],
          },
        ],
      };
    return (
      (o.contains = [l, u, a]),
      {
        name: 'Python',
        aliases: ['py', 'gyp', 'ipython'],
        unicodeRegex: !0,
        keywords: i,
        illegal: /(<\/|\?)|=>/,
        contains: [
          a,
          u,
          { scope: 'variable.language', match: /\bself\b/ },
          { beginKeywords: 'if', relevance: 0 },
          { match: /\bor\b/, scope: 'keyword' },
          l,
          p,
          e.HASH_COMMENT_MODE,
          {
            match: [/\bdef/, /\s+/, r],
            scope: { 1: 'keyword', 3: 'title.function' },
            contains: [g],
          },
          {
            variants: [
              { match: [/\bclass/, /\s+/, r, /\s*/, /\(\s*/, r, /\s*\)/] },
              { match: [/\bclass/, /\s+/, r] },
            ],
            scope: { 1: 'keyword', 3: 'title.class', 6: 'title.class.inherited' },
          },
          { className: 'meta', begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [u, g, l] },
        ],
      }
    );
  },
  'python-repl': function (e) {
    return {
      aliases: ['pycon'],
      contains: [
        {
          className: 'meta.prompt',
          starts: { end: / |$/, starts: { end: '$', subLanguage: 'python' } },
          variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }],
        },
      ],
    };
  },
  r: function (e) {
    const t = e.regex,
      r = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/,
      n = t.either(
        /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
        /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
        /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
      ),
      i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/,
      a = t.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/);
    return {
      name: 'R',
      keywords: {
        $pattern: r,
        keyword: 'function if in break next repeat else for while',
        literal:
          'NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10',
        built_in:
          'LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm',
      },
      contains: [
        e.COMMENT(/#'/, /$/, {
          contains: [
            {
              scope: 'doctag',
              match: /@examples/,
              starts: {
                end: t.lookahead(t.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)),
                endsParent: !0,
              },
            },
            {
              scope: 'doctag',
              begin: '@param',
              end: /$/,
              contains: [
                {
                  scope: 'variable',
                  variants: [{ match: r }, { match: /`(?:\\.|[^`\\])+`/ }],
                  endsParent: !0,
                },
              ],
            },
            { scope: 'doctag', match: /@[a-zA-Z]+/ },
            { scope: 'keyword', match: /\\[a-zA-Z]+/ },
          ],
        }),
        e.HASH_COMMENT_MODE,
        {
          scope: 'string',
          contains: [e.BACKSLASH_ESCAPE],
          variants: [
            e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }),
            e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }),
            e.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }),
            e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }),
            e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }),
            e.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }),
            { begin: '"', end: '"', relevance: 0 },
            { begin: "'", end: "'", relevance: 0 },
          ],
        },
        {
          relevance: 0,
          variants: [
            { scope: { 1: 'operator', 2: 'number' }, match: [i, n] },
            { scope: { 1: 'operator', 2: 'number' }, match: [/%[^%]*%/, n] },
            { scope: { 1: 'punctuation', 2: 'number' }, match: [a, n] },
            { scope: { 2: 'number' }, match: [/[^a-zA-Z0-9._]|^/, n] },
          ],
        },
        { scope: { 3: 'operator' }, match: [r, /\s+/, /<-/, /\s+/] },
        { scope: 'operator', relevance: 0, variants: [{ match: i }, { match: /%[^%]*%/ }] },
        { scope: 'punctuation', relevance: 0, match: a },
        { begin: '`', end: '`', contains: [{ begin: /\\./ }] },
      ],
    };
  },
  ruby: function (e) {
    const t = e.regex,
      r = '([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)',
      n = t.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/),
      i = t.concat(n, /(::\w+)*/),
      a = {
        'variable.constant': ['__FILE__', '__LINE__', '__ENCODING__'],
        'variable.language': ['self', 'super'],
        keyword: [
          'alias',
          'and',
          'begin',
          'BEGIN',
          'break',
          'case',
          'class',
          'defined',
          'do',
          'else',
          'elsif',
          'end',
          'END',
          'ensure',
          'for',
          'if',
          'in',
          'module',
          'next',
          'not',
          'or',
          'redo',
          'require',
          'rescue',
          'retry',
          'return',
          'then',
          'undef',
          'unless',
          'until',
          'when',
          'while',
          'yield',
          'include',
          'extend',
          'prepend',
          'public',
          'private',
          'protected',
          'raise',
          'throw',
        ],
        built_in: [
          'proc',
          'lambda',
          'attr_accessor',
          'attr_reader',
          'attr_writer',
          'define_method',
          'private_constant',
          'module_function',
        ],
        literal: ['true', 'false', 'nil'],
      },
      o = { className: 'doctag', begin: '@[A-Za-z]+' },
      s = { begin: '#<', end: '>' },
      l = [
        e.COMMENT('#', '$', { contains: [o] }),
        e.COMMENT('^=begin', '^=end', { contains: [o], relevance: 10 }),
        e.COMMENT('^__END__', e.MATCH_NOTHING_RE),
      ],
      c = { className: 'subst', begin: /#\{/, end: /\}/, keywords: a },
      h = {
        className: 'string',
        contains: [e.BACKSLASH_ESCAPE, c],
        variants: [
          { begin: /'/, end: /'/ },
          { begin: /"/, end: /"/ },
          { begin: /`/, end: /`/ },
          { begin: /%[qQwWx]?\(/, end: /\)/ },
          { begin: /%[qQwWx]?\[/, end: /\]/ },
          { begin: /%[qQwWx]?\{/, end: /\}/ },
          { begin: /%[qQwWx]?</, end: />/ },
          { begin: /%[qQwWx]?\//, end: /\// },
          { begin: /%[qQwWx]?%/, end: /%/ },
          { begin: /%[qQwWx]?-/, end: /-/ },
          { begin: /%[qQwWx]?\|/, end: /\|/ },
          { begin: /\B\?(\\\d{1,3})/ },
          { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
          { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
          { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
          { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
          { begin: /\B\?\\?\S/ },
          {
            begin: t.concat(/<<[-~]?'?/, t.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)),
            contains: [
              e.END_SAME_AS_BEGIN({
                begin: /(\w+)/,
                end: /(\w+)/,
                contains: [e.BACKSLASH_ESCAPE, c],
              }),
            ],
          },
        ],
      },
      d = '[0-9](_?[0-9])*',
      u = {
        className: 'number',
        relevance: 0,
        variants: [
          { begin: `\\b([1-9](_?[0-9])*|0)(\\.(${d}))?([eE][+-]?(${d})|r)?i?\\b` },
          { begin: '\\b0[dD][0-9](_?[0-9])*r?i?\\b' },
          { begin: '\\b0[bB][0-1](_?[0-1])*r?i?\\b' },
          { begin: '\\b0[oO][0-7](_?[0-7])*r?i?\\b' },
          { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b' },
          { begin: '\\b0(_?[0-7])+r?i?\\b' },
        ],
      },
      p = {
        variants: [
          { match: /\(\)/ },
          {
            className: 'params',
            begin: /\(/,
            end: /(?=\))/,
            excludeBegin: !0,
            endsParent: !0,
            keywords: a,
          },
        ],
      },
      g = [
        h,
        {
          variants: [
            { match: [/class\s+/, i, /\s+<\s+/, i] },
            { match: [/\b(class|module)\s+/, i] },
          ],
          scope: { 2: 'title.class', 4: 'title.class.inherited' },
          keywords: a,
        },
        { match: [/(include|extend)\s+/, i], scope: { 2: 'title.class' }, keywords: a },
        { relevance: 0, match: [i, /\.new[. (]/], scope: { 1: 'title.class' } },
        { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' },
        { relevance: 0, match: n, scope: 'title.class' },
        { match: [/def/, /\s+/, r], scope: { 1: 'keyword', 3: 'title.function' }, contains: [p] },
        { begin: e.IDENT_RE + '::' },
        { className: 'symbol', begin: e.UNDERSCORE_IDENT_RE + '(!|\\?)?:', relevance: 0 },
        { className: 'symbol', begin: ':(?!\\s)', contains: [h, { begin: r }], relevance: 0 },
        u,
        {
          className: 'variable',
          begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])",
        },
        {
          className: 'params',
          begin: /\|(?!=)/,
          end: /\|/,
          excludeBegin: !0,
          excludeEnd: !0,
          relevance: 0,
          keywords: a,
        },
        {
          begin: '(' + e.RE_STARTERS_RE + '|unless)\\s*',
          keywords: 'unless',
          contains: [
            {
              className: 'regexp',
              contains: [e.BACKSLASH_ESCAPE, c],
              illegal: /\n/,
              variants: [
                { begin: '/', end: '/[a-z]*' },
                { begin: /%r\{/, end: /\}[a-z]*/ },
                { begin: '%r\\(', end: '\\)[a-z]*' },
                { begin: '%r!', end: '![a-z]*' },
                { begin: '%r\\[', end: '\\][a-z]*' },
              ],
            },
          ].concat(s, l),
          relevance: 0,
        },
      ].concat(s, l);
    ((c.contains = g), (p.contains = g));
    const f = [
      { begin: /^\s*=>/, starts: { end: '$', contains: g } },
      {
        className: 'meta.prompt',
        begin:
          '^([>?]>|[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]|(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>)(?=[ ])',
        starts: { end: '$', keywords: a, contains: g },
      },
    ];
    return (
      l.unshift(s),
      {
        name: 'Ruby',
        aliases: ['rb', 'gemspec', 'podspec', 'thor', 'irb'],
        keywords: a,
        illegal: /\/\*/,
        contains: [e.SHEBANG({ binary: 'ruby' })].concat(f).concat(l).concat(g),
      }
    );
  },
  rust: function (e) {
    const t = e.regex,
      r = /(r#)?/,
      n = t.concat(r, e.UNDERSCORE_IDENT_RE),
      i = t.concat(r, e.IDENT_RE),
      a = {
        className: 'title.function.invoke',
        relevance: 0,
        begin: t.concat(/\b/, /(?!let|for|while|if|else|match\b)/, i, t.lookahead(/\s*\(/)),
      },
      o = '([ui](8|16|32|64|128|size)|f(32|64))?',
      s = [
        'drop ',
        'Copy',
        'Send',
        'Sized',
        'Sync',
        'Drop',
        'Fn',
        'FnMut',
        'FnOnce',
        'ToOwned',
        'Clone',
        'Debug',
        'PartialEq',
        'PartialOrd',
        'Eq',
        'Ord',
        'AsRef',
        'AsMut',
        'Into',
        'From',
        'Default',
        'Iterator',
        'Extend',
        'IntoIterator',
        'DoubleEndedIterator',
        'ExactSizeIterator',
        'SliceConcatExt',
        'ToString',
        'assert!',
        'assert_eq!',
        'bitflags!',
        'bytes!',
        'cfg!',
        'col!',
        'concat!',
        'concat_idents!',
        'debug_assert!',
        'debug_assert_eq!',
        'env!',
        'eprintln!',
        'panic!',
        'file!',
        'format!',
        'format_args!',
        'include_bytes!',
        'include_str!',
        'line!',
        'local_data_key!',
        'module_path!',
        'option_env!',
        'print!',
        'println!',
        'select!',
        'stringify!',
        'try!',
        'unimplemented!',
        'unreachable!',
        'vec!',
        'write!',
        'writeln!',
        'macro_rules!',
        'assert_ne!',
        'debug_assert_ne!',
      ],
      l = [
        'i8',
        'i16',
        'i32',
        'i64',
        'i128',
        'isize',
        'u8',
        'u16',
        'u32',
        'u64',
        'u128',
        'usize',
        'f32',
        'f64',
        'str',
        'char',
        'bool',
        'Box',
        'Option',
        'Result',
        'String',
        'Vec',
      ];
    return {
      name: 'Rust',
      aliases: ['rs'],
      keywords: {
        $pattern: e.IDENT_RE + '!?',
        type: l,
        keyword: [
          'abstract',
          'as',
          'async',
          'await',
          'become',
          'box',
          'break',
          'const',
          'continue',
          'crate',
          'do',
          'dyn',
          'else',
          'enum',
          'extern',
          'false',
          'final',
          'fn',
          'for',
          'if',
          'impl',
          'in',
          'let',
          'loop',
          'macro',
          'match',
          'mod',
          'move',
          'mut',
          'override',
          'priv',
          'pub',
          'ref',
          'return',
          'self',
          'Self',
          'static',
          'struct',
          'super',
          'trait',
          'true',
          'try',
          'type',
          'typeof',
          'union',
          'unsafe',
          'unsized',
          'use',
          'virtual',
          'where',
          'while',
          'yield',
        ],
        literal: ['true', 'false', 'Some', 'None', 'Ok', 'Err'],
        built_in: s,
      },
      illegal: '</',
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.COMMENT('/\\*', '\\*/', { contains: ['self'] }),
        e.inherit(e.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }),
        { className: 'symbol', begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/ },
        {
          scope: 'string',
          variants: [
            { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
            {
              begin: /b?'/,
              end: /'/,
              contains: [{ scope: 'char.escape', match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/ }],
            },
          ],
        },
        {
          className: 'number',
          variants: [
            { begin: '\\b0b([01_]+)' + o },
            { begin: '\\b0o([0-7_]+)' + o },
            { begin: '\\b0x([A-Fa-f0-9_]+)' + o },
            { begin: '\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)' + o },
          ],
          relevance: 0,
        },
        { begin: [/fn/, /\s+/, n], className: { 1: 'keyword', 3: 'title.function' } },
        {
          className: 'meta',
          begin: '#!?\\[',
          end: '\\]',
          contains: [{ className: 'string', begin: /"/, end: /"/, contains: [e.BACKSLASH_ESCAPE] }],
        },
        {
          begin: [/let/, /\s+/, /(?:mut\s+)?/, n],
          className: { 1: 'keyword', 3: 'keyword', 4: 'variable' },
        },
        {
          begin: [/for/, /\s+/, n, /\s+/, /in/],
          className: { 1: 'keyword', 3: 'variable', 5: 'keyword' },
        },
        { begin: [/type/, /\s+/, n], className: { 1: 'keyword', 3: 'title.class' } },
        {
          begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, n],
          className: { 1: 'keyword', 3: 'title.class' },
        },
        { begin: e.IDENT_RE + '::', keywords: { keyword: 'Self', built_in: s, type: l } },
        { className: 'punctuation', begin: '->' },
        a,
      ],
    };
  },
  scss: function (e) {
    const t = ((e) => ({
        IMPORTANT: { scope: 'meta', begin: '!important' },
        BLOCK_COMMENT: e.C_BLOCK_COMMENT_MODE,
        HEXCOLOR: { scope: 'number', begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ },
        FUNCTION_DISPATCH: { className: 'built_in', begin: /[\w-]+(?=\()/ },
        ATTRIBUTE_SELECTOR_MODE: {
          scope: 'selector-attr',
          begin: /\[/,
          end: /\]/,
          illegal: '$',
          contains: [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE],
        },
        CSS_NUMBER_MODE: {
          scope: 'number',
          begin:
            e.NUMBER_RE +
            '(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?',
          relevance: 0,
        },
        CSS_VARIABLE: { className: 'attr', begin: /--[A-Za-z_][A-Za-z0-9_-]*/ },
      }))(e),
      r = Qt,
      n = Xt,
      i = '@[a-z-]+',
      a = { className: 'variable', begin: '(\\$[a-zA-Z-][a-zA-Z0-9_-]*)\\b', relevance: 0 };
    return {
      name: 'SCSS',
      case_insensitive: !0,
      illegal: "[=/|']",
      contains: [
        e.C_LINE_COMMENT_MODE,
        e.C_BLOCK_COMMENT_MODE,
        t.CSS_NUMBER_MODE,
        { className: 'selector-id', begin: '#[A-Za-z0-9_-]+', relevance: 0 },
        { className: 'selector-class', begin: '\\.[A-Za-z0-9_-]+', relevance: 0 },
        t.ATTRIBUTE_SELECTOR_MODE,
        { className: 'selector-tag', begin: '\\b(' + Kt.join('|') + ')\\b', relevance: 0 },
        { className: 'selector-pseudo', begin: ':(' + n.join('|') + ')' },
        { className: 'selector-pseudo', begin: ':(:)?(' + r.join('|') + ')' },
        a,
        { begin: /\(/, end: /\)/, contains: [t.CSS_NUMBER_MODE] },
        t.CSS_VARIABLE,
        { className: 'attribute', begin: '\\b(' + Jt.join('|') + ')\\b' },
        {
          begin:
            '\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b',
        },
        {
          begin: /:/,
          end: /[;}{]/,
          relevance: 0,
          contains: [
            t.BLOCK_COMMENT,
            a,
            t.HEXCOLOR,
            t.CSS_NUMBER_MODE,
            e.QUOTE_STRING_MODE,
            e.APOS_STRING_MODE,
            t.IMPORTANT,
            t.FUNCTION_DISPATCH,
          ],
        },
        { begin: '@(page|font-face)', keywords: { $pattern: i, keyword: '@page @font-face' } },
        {
          begin: '@',
          end: '[{;]',
          returnBegin: !0,
          keywords: { $pattern: /[a-z-]+/, keyword: 'and or not only', attribute: Yt.join(' ') },
          contains: [
            { begin: i, className: 'keyword' },
            { begin: /[a-z-]+(?=:)/, className: 'attribute' },
            a,
            e.QUOTE_STRING_MODE,
            e.APOS_STRING_MODE,
            t.HEXCOLOR,
            t.CSS_NUMBER_MODE,
          ],
        },
        t.FUNCTION_DISPATCH,
      ],
    };
  },
  shell: function (e) {
    return {
      name: 'Shell Session',
      aliases: ['console', 'shellsession'],
      contains: [
        {
          className: 'meta.prompt',
          begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
          starts: { end: /[^\\](?=\s*$)/, subLanguage: 'bash' },
        },
      ],
    };
  },
  sql: function (e) {
    const t = e.regex,
      r = e.COMMENT('--', '$'),
      n = [
        'abs',
        'acos',
        'array_agg',
        'asin',
        'atan',
        'avg',
        'cast',
        'ceil',
        'ceiling',
        'coalesce',
        'corr',
        'cos',
        'cosh',
        'count',
        'covar_pop',
        'covar_samp',
        'cume_dist',
        'dense_rank',
        'deref',
        'element',
        'exp',
        'extract',
        'first_value',
        'floor',
        'json_array',
        'json_arrayagg',
        'json_exists',
        'json_object',
        'json_objectagg',
        'json_query',
        'json_table',
        'json_table_primitive',
        'json_value',
        'lag',
        'last_value',
        'lead',
        'listagg',
        'ln',
        'log',
        'log10',
        'lower',
        'max',
        'min',
        'mod',
        'nth_value',
        'ntile',
        'nullif',
        'percent_rank',
        'percentile_cont',
        'percentile_disc',
        'position',
        'position_regex',
        'power',
        'rank',
        'regr_avgx',
        'regr_avgy',
        'regr_count',
        'regr_intercept',
        'regr_r2',
        'regr_slope',
        'regr_sxx',
        'regr_sxy',
        'regr_syy',
        'row_number',
        'sin',
        'sinh',
        'sqrt',
        'stddev_pop',
        'stddev_samp',
        'substring',
        'substring_regex',
        'sum',
        'tan',
        'tanh',
        'translate',
        'translate_regex',
        'treat',
        'trim',
        'trim_array',
        'unnest',
        'upper',
        'value_of',
        'var_pop',
        'var_samp',
        'width_bucket',
      ],
      i = n,
      a = [
        'abs',
        'acos',
        'all',
        'allocate',
        'alter',
        'and',
        'any',
        'are',
        'array',
        'array_agg',
        'array_max_cardinality',
        'as',
        'asensitive',
        'asin',
        'asymmetric',
        'at',
        'atan',
        'atomic',
        'authorization',
        'avg',
        'begin',
        'begin_frame',
        'begin_partition',
        'between',
        'bigint',
        'binary',
        'blob',
        'boolean',
        'both',
        'by',
        'call',
        'called',
        'cardinality',
        'cascaded',
        'case',
        'cast',
        'ceil',
        'ceiling',
        'char',
        'char_length',
        'character',
        'character_length',
        'check',
        'classifier',
        'clob',
        'close',
        'coalesce',
        'collate',
        'collect',
        'column',
        'commit',
        'condition',
        'connect',
        'constraint',
        'contains',
        'convert',
        'copy',
        'corr',
        'corresponding',
        'cos',
        'cosh',
        'count',
        'covar_pop',
        'covar_samp',
        'create',
        'cross',
        'cube',
        'cume_dist',
        'current',
        'current_catalog',
        'current_date',
        'current_default_transform_group',
        'current_path',
        'current_role',
        'current_row',
        'current_schema',
        'current_time',
        'current_timestamp',
        'current_path',
        'current_role',
        'current_transform_group_for_type',
        'current_user',
        'cursor',
        'cycle',
        'date',
        'day',
        'deallocate',
        'dec',
        'decimal',
        'decfloat',
        'declare',
        'default',
        'define',
        'delete',
        'dense_rank',
        'deref',
        'describe',
        'deterministic',
        'disconnect',
        'distinct',
        'double',
        'drop',
        'dynamic',
        'each',
        'element',
        'else',
        'empty',
        'end',
        'end_frame',
        'end_partition',
        'end-exec',
        'equals',
        'escape',
        'every',
        'except',
        'exec',
        'execute',
        'exists',
        'exp',
        'external',
        'extract',
        'false',
        'fetch',
        'filter',
        'first_value',
        'float',
        'floor',
        'for',
        'foreign',
        'frame_row',
        'free',
        'from',
        'full',
        'function',
        'fusion',
        'get',
        'global',
        'grant',
        'group',
        'grouping',
        'groups',
        'having',
        'hold',
        'hour',
        'identity',
        'in',
        'indicator',
        'initial',
        'inner',
        'inout',
        'insensitive',
        'insert',
        'int',
        'integer',
        'intersect',
        'intersection',
        'interval',
        'into',
        'is',
        'join',
        'json_array',
        'json_arrayagg',
        'json_exists',
        'json_object',
        'json_objectagg',
        'json_query',
        'json_table',
        'json_table_primitive',
        'json_value',
        'lag',
        'language',
        'large',
        'last_value',
        'lateral',
        'lead',
        'leading',
        'left',
        'like',
        'like_regex',
        'listagg',
        'ln',
        'local',
        'localtime',
        'localtimestamp',
        'log',
        'log10',
        'lower',
        'match',
        'match_number',
        'match_recognize',
        'matches',
        'max',
        'member',
        'merge',
        'method',
        'min',
        'minute',
        'mod',
        'modifies',
        'module',
        'month',
        'multiset',
        'national',
        'natural',
        'nchar',
        'nclob',
        'new',
        'no',
        'none',
        'normalize',
        'not',
        'nth_value',
        'ntile',
        'null',
        'nullif',
        'numeric',
        'octet_length',
        'occurrences_regex',
        'of',
        'offset',
        'old',
        'omit',
        'on',
        'one',
        'only',
        'open',
        'or',
        'order',
        'out',
        'outer',
        'over',
        'overlaps',
        'overlay',
        'parameter',
        'partition',
        'pattern',
        'per',
        'percent',
        'percent_rank',
        'percentile_cont',
        'percentile_disc',
        'period',
        'portion',
        'position',
        'position_regex',
        'power',
        'precedes',
        'precision',
        'prepare',
        'primary',
        'procedure',
        'ptf',
        'range',
        'rank',
        'reads',
        'real',
        'recursive',
        'ref',
        'references',
        'referencing',
        'regr_avgx',
        'regr_avgy',
        'regr_count',
        'regr_intercept',
        'regr_r2',
        'regr_slope',
        'regr_sxx',
        'regr_sxy',
        'regr_syy',
        'release',
        'result',
        'return',
        'returns',
        'revoke',
        'right',
        'rollback',
        'rollup',
        'row',
        'row_number',
        'rows',
        'running',
        'savepoint',
        'scope',
        'scroll',
        'search',
        'second',
        'seek',
        'select',
        'sensitive',
        'session_user',
        'set',
        'show',
        'similar',
        'sin',
        'sinh',
        'skip',
        'smallint',
        'some',
        'specific',
        'specifictype',
        'sql',
        'sqlexception',
        'sqlstate',
        'sqlwarning',
        'sqrt',
        'start',
        'static',
        'stddev_pop',
        'stddev_samp',
        'submultiset',
        'subset',
        'substring',
        'substring_regex',
        'succeeds',
        'sum',
        'symmetric',
        'system',
        'system_time',
        'system_user',
        'table',
        'tablesample',
        'tan',
        'tanh',
        'then',
        'time',
        'timestamp',
        'timezone_hour',
        'timezone_minute',
        'to',
        'trailing',
        'translate',
        'translate_regex',
        'translation',
        'treat',
        'trigger',
        'trim',
        'trim_array',
        'true',
        'truncate',
        'uescape',
        'union',
        'unique',
        'unknown',
        'unnest',
        'update',
        'upper',
        'user',
        'using',
        'value',
        'values',
        'value_of',
        'var_pop',
        'var_samp',
        'varbinary',
        'varchar',
        'varying',
        'versioning',
        'when',
        'whenever',
        'where',
        'width_bucket',
        'window',
        'with',
        'within',
        'without',
        'year',
        'add',
        'asc',
        'collation',
        'desc',
        'final',
        'first',
        'last',
        'view',
      ].filter((e) => !n.includes(e)),
      o = {
        match: t.concat(/\b/, t.either(...i), /\s*\(/),
        relevance: 0,
        keywords: { built_in: i },
      };
    function s(e) {
      return t.concat(/\b/, t.either(...e.map((e) => e.replace(/\s+/, '\\s+'))), /\b/);
    }
    const l = {
      scope: 'keyword',
      match: s([
        'create table',
        'insert into',
        'primary key',
        'foreign key',
        'not null',
        'alter table',
        'add constraint',
        'grouping sets',
        'on overflow',
        'character set',
        'respect nulls',
        'ignore nulls',
        'nulls first',
        'nulls last',
        'depth first',
        'breadth first',
      ]),
      relevance: 0,
    };
    return {
      name: 'SQL',
      case_insensitive: !0,
      illegal: /[{}]|<\//,
      keywords: {
        $pattern: /\b[\w\.]+/,
        keyword: (function (e, { exceptions: t, when: r } = {}) {
          const n = r;
          return (
            (t = t || []),
            e.map((e) => (e.match(/\|\d+$/) || t.includes(e) ? e : n(e) ? `${e}|0` : e))
          );
        })(a, { when: (e) => e.length < 3 }),
        literal: ['true', 'false', 'unknown'],
        type: [
          'bigint',
          'binary',
          'blob',
          'boolean',
          'char',
          'character',
          'clob',
          'date',
          'dec',
          'decfloat',
          'decimal',
          'float',
          'int',
          'integer',
          'interval',
          'nchar',
          'nclob',
          'national',
          'numeric',
          'real',
          'row',
          'smallint',
          'time',
          'timestamp',
          'varchar',
          'varying',
          'varbinary',
        ],
        built_in: [
          'current_catalog',
          'current_date',
          'current_default_transform_group',
          'current_path',
          'current_role',
          'current_schema',
          'current_transform_group_for_type',
          'current_user',
          'session_user',
          'system_time',
          'system_user',
          'current_time',
          'localtime',
          'current_timestamp',
          'localtimestamp',
        ],
      },
      contains: [
        {
          scope: 'type',
          match: s(['double precision', 'large object', 'with timezone', 'without timezone']),
        },
        l,
        o,
        { scope: 'variable', match: /@[a-z0-9][a-z0-9_]*/ },
        { scope: 'string', variants: [{ begin: /'/, end: /'/, contains: [{ match: /''/ }] }] },
        { begin: /"/, end: /"/, contains: [{ match: /""/ }] },
        e.C_NUMBER_MODE,
        e.C_BLOCK_COMMENT_MODE,
        r,
        { scope: 'operator', match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/, relevance: 0 },
      ],
    };
  },
  swift: function (e) {
    const t = { match: /\s+/, relevance: 0 },
      r = e.COMMENT('/\\*', '\\*/', { contains: ['self'] }),
      n = [e.C_LINE_COMMENT_MODE, r],
      i = { match: [/\./, nr(...ar, ...or)], className: { 2: 'keyword' } },
      a = { match: rr(/\./, nr(...lr)), relevance: 0 },
      o = lr.filter((e) => 'string' == typeof e).concat(['_|0']),
      s = {
        variants: [
          {
            className: 'keyword',
            match: nr(
              ...lr
                .filter((e) => 'string' != typeof e)
                .concat(sr)
                .map(ir),
              ...or
            ),
          },
        ],
      },
      l = { $pattern: nr(/\b\w+/, /#\w+/), keyword: o.concat(dr), literal: cr },
      c = [i, a, s],
      h = [
        { match: rr(/\./, nr(...ur)), relevance: 0 },
        { className: 'built_in', match: rr(/\b/, nr(...ur), /(?=\()/) },
      ],
      d = { match: /->/, relevance: 0 },
      u = [
        d,
        {
          className: 'operator',
          relevance: 0,
          variants: [{ match: fr }, { match: `\\.(\\.|${gr})+` }],
        },
      ],
      p = '([0-9]_*)+',
      g = '([0-9a-fA-F]_*)+',
      f = {
        className: 'number',
        relevance: 0,
        variants: [
          { match: `\\b(${p})(\\.(${p}))?([eE][+-]?(${p}))?\\b` },
          { match: `\\b0x(${g})(\\.(${g}))?([pP][+-]?(${p}))?\\b` },
          { match: /\b0o([0-7]_*)+\b/ },
          { match: /\b0b([01]_*)+\b/ },
        ],
      },
      m = (e = '') => ({
        className: 'subst',
        variants: [
          { match: rr(/\\/, e, /[0\\tnr"']/) },
          { match: rr(/\\/, e, /u\{[0-9a-fA-F]{1,8}\}/) },
        ],
      }),
      b = (e = '') => ({ className: 'subst', match: rr(/\\/, e, /[\t ]*(?:[\r\n]|\r\n)/) }),
      y = (e = '') => ({
        className: 'subst',
        label: 'interpol',
        begin: rr(/\\/, e, /\(/),
        end: /\)/,
      }),
      x = (e = '') => ({ begin: rr(e, /"""/), end: rr(/"""/, e), contains: [m(e), b(e), y(e)] }),
      k = (e = '') => ({ begin: rr(e, /"/), end: rr(/"/, e), contains: [m(e), y(e)] }),
      C = {
        className: 'string',
        variants: [x(), x('#'), x('##'), x('###'), k(), k('#'), k('##'), k('###')],
      },
      w = [
        e.BACKSLASH_ESCAPE,
        { begin: /\[/, end: /\]/, relevance: 0, contains: [e.BACKSLASH_ESCAPE] },
      ],
      v = { begin: /\/[^\s](?=[^/\n]*\/)/, end: /\//, contains: w },
      _ = (e) => {
        const t = rr(e, /\//),
          r = rr(/\//, e);
        return {
          begin: t,
          end: r,
          contains: [...w, { scope: 'comment', begin: `#(?!.*${r})`, end: /$/ }],
        };
      },
      S = { scope: 'regexp', variants: [_('###'), _('##'), _('#'), v] },
      E = { match: rr(/`/, yr, /`/) },
      D = [
        E,
        { className: 'variable', match: /\$\d+/ },
        { className: 'variable', match: `\\$${br}+` },
      ],
      A = [
        {
          match: /(@|#(un)?)available/,
          scope: 'keyword',
          starts: { contains: [{ begin: /\(/, end: /\)/, keywords: Cr, contains: [...u, f, C] }] },
        },
        { scope: 'keyword', match: rr(/@/, nr(...kr), tr(nr(/\(/, /\s+/))) },
        { scope: 'meta', match: rr(/@/, yr) },
      ],
      T = {
        match: tr(/\b[A-Z]/),
        relevance: 0,
        contains: [
          {
            className: 'type',
            match: rr(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, br, '+'),
          },
          { className: 'type', match: xr, relevance: 0 },
          { match: /[?!]+/, relevance: 0 },
          { match: /\.\.\./, relevance: 0 },
          { match: rr(/\s+&\s+/, tr(xr)), relevance: 0 },
        ],
      },
      F = { begin: /</, end: />/, keywords: l, contains: [...n, ...c, ...A, d, T] };
    T.contains.push(F);
    const B = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: l,
        contains: [
          'self',
          { match: rr(yr, /\s*:/), keywords: '_|0', relevance: 0 },
          ...n,
          S,
          ...c,
          ...h,
          ...u,
          f,
          C,
          ...D,
          ...A,
          T,
        ],
      },
      M = { begin: /</, end: />/, keywords: 'repeat each', contains: [...n, T] },
      N = {
        begin: /\(/,
        end: /\)/,
        keywords: l,
        contains: [
          {
            begin: nr(tr(rr(yr, /\s*:/)), tr(rr(yr, /\s+/, yr, /\s*:/))),
            end: /:/,
            relevance: 0,
            contains: [
              { className: 'keyword', match: /\b_\b/ },
              { className: 'params', match: yr },
            ],
          },
          ...n,
          ...c,
          ...u,
          f,
          C,
          ...A,
          T,
          B,
        ],
        endsParent: !0,
        illegal: /["']/,
      },
      L = {
        match: [/(func|macro)/, /\s+/, nr(E.match, yr, fr)],
        className: { 1: 'keyword', 3: 'title.function' },
        contains: [M, N, t],
        illegal: [/\[/, /%/],
      },
      O = {
        match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/],
        className: { 1: 'keyword' },
        contains: [M, N, t],
        illegal: /\[|%/,
      },
      $ = { match: [/operator/, /\s+/, fr], className: { 1: 'keyword', 3: 'title' } },
      I = {
        begin: [/precedencegroup/, /\s+/, xr],
        className: { 1: 'keyword', 3: 'title' },
        contains: [T],
        keywords: [...hr, ...cr],
        end: /}/,
      },
      R = {
        begin: [/(struct|protocol|class|extension|enum|actor)/, /\s+/, yr, /\s*/],
        beginScope: { 1: 'keyword', 3: 'title.class' },
        keywords: l,
        contains: [
          M,
          ...c,
          {
            begin: /:/,
            end: /\{/,
            keywords: l,
            contains: [{ scope: 'title.class.inherited', match: xr }, ...c],
            relevance: 0,
          },
        ],
      };
    for (const z of C.variants) {
      const e = z.contains.find((e) => 'interpol' === e.label);
      e.keywords = l;
      const t = [...c, ...h, ...u, f, C, ...D];
      e.contains = [...t, { begin: /\(/, end: /\)/, contains: ['self', ...t] }];
    }
    return {
      name: 'Swift',
      keywords: l,
      contains: [
        ...n,
        L,
        O,
        {
          match: [/class\b/, /\s+/, /func\b/, /\s+/, /\b[A-Za-z_][A-Za-z0-9_]*\b/],
          scope: { 1: 'keyword', 3: 'keyword', 5: 'title.function' },
        },
        { match: [/class\b/, /\s+/, /var\b/], scope: { 1: 'keyword', 3: 'keyword' } },
        R,
        $,
        I,
        { beginKeywords: 'import', end: /$/, contains: [...n], relevance: 0 },
        S,
        ...c,
        ...h,
        ...u,
        f,
        C,
        ...D,
        ...A,
        T,
        B,
      ],
    };
  },
  typescript: function (e) {
    const t = e.regex,
      r = (function (e) {
        const t = e.regex,
          r = wr,
          n = '<>',
          i = '</>',
          a = {
            begin: /<[A-Za-z0-9\\._:-]+/,
            end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
            isTrulyOpeningTag: (e, t) => {
              const r = e[0].length + e.index,
                n = e.input[r];
              if ('<' === n || ',' === n) return void t.ignoreMatch();
              let i;
              '>' === n &&
                (((e, { after: t }) => {
                  const r = '</' + e[0].slice(1);
                  return -1 !== e.input.indexOf(r, t);
                })(e, { after: r }) ||
                  t.ignoreMatch());
              const a = e.input.substring(r);
              ((i = a.match(/^\s*=/)) || ((i = a.match(/^\s+extends\s+/)) && 0 === i.index)) &&
                t.ignoreMatch();
            },
          },
          o = { $pattern: wr, keyword: vr, literal: _r, built_in: Tr, 'variable.language': Ar },
          s = '[0-9](_?[0-9])*',
          l = `\\.(${s})`,
          c = '0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*',
          h = {
            className: 'number',
            variants: [
              { begin: `(\\b(${c})((${l})|\\.)?|(${l}))[eE][+-]?(${s})\\b` },
              { begin: `\\b(${c})\\b((${l})\\b|\\.)?|(${l})\\b` },
              { begin: '\\b(0|[1-9](_?[0-9])*)n\\b' },
              { begin: '\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b' },
              { begin: '\\b0[bB][0-1](_?[0-1])*n?\\b' },
              { begin: '\\b0[oO][0-7](_?[0-7])*n?\\b' },
              { begin: '\\b0[0-7]+n?\\b' },
            ],
            relevance: 0,
          },
          d = { className: 'subst', begin: '\\$\\{', end: '\\}', keywords: o, contains: [] },
          u = {
            begin: '.?html`',
            end: '',
            starts: {
              end: '`',
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, d],
              subLanguage: 'xml',
            },
          },
          p = {
            begin: '.?css`',
            end: '',
            starts: {
              end: '`',
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, d],
              subLanguage: 'css',
            },
          },
          g = {
            begin: '.?gql`',
            end: '',
            starts: {
              end: '`',
              returnEnd: !1,
              contains: [e.BACKSLASH_ESCAPE, d],
              subLanguage: 'graphql',
            },
          },
          f = { className: 'string', begin: '`', end: '`', contains: [e.BACKSLASH_ESCAPE, d] },
          m = {
            className: 'comment',
            variants: [
              e.COMMENT(/\/\*\*(?!\/)/, '\\*/', {
                relevance: 0,
                contains: [
                  {
                    begin: '(?=@[A-Za-z]+)',
                    relevance: 0,
                    contains: [
                      { className: 'doctag', begin: '@[A-Za-z]+' },
                      {
                        className: 'type',
                        begin: '\\{',
                        end: '\\}',
                        excludeEnd: !0,
                        excludeBegin: !0,
                        relevance: 0,
                      },
                      {
                        className: 'variable',
                        begin: r + '(?=\\s*(-)|$)',
                        endsParent: !0,
                        relevance: 0,
                      },
                      { begin: /(?=[^\n])\s/, relevance: 0 },
                    ],
                  },
                ],
              }),
              e.C_BLOCK_COMMENT_MODE,
              e.C_LINE_COMMENT_MODE,
            ],
          },
          b = [e.APOS_STRING_MODE, e.QUOTE_STRING_MODE, u, p, g, f, { match: /\$\d+/ }, h];
        d.contains = b.concat({
          begin: /\{/,
          end: /\}/,
          keywords: o,
          contains: ['self'].concat(b),
        });
        const y = [].concat(m, d.contains),
          x = y.concat([
            { begin: /(\s*)\(/, end: /\)/, keywords: o, contains: ['self'].concat(y) },
          ]),
          k = {
            className: 'params',
            begin: /(\s*)\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: o,
            contains: x,
          },
          C = {
            variants: [
              {
                match: [
                  /class/,
                  /\s+/,
                  r,
                  /\s+/,
                  /extends/,
                  /\s+/,
                  t.concat(r, '(', t.concat(/\./, r), ')*'),
                ],
                scope: { 1: 'keyword', 3: 'title.class', 5: 'keyword', 7: 'title.class.inherited' },
              },
              { match: [/class/, /\s+/, r], scope: { 1: 'keyword', 3: 'title.class' } },
            ],
          },
          w = {
            relevance: 0,
            match: t.either(
              /\bJSON/,
              /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
              /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
              /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
            ),
            className: 'title.class',
            keywords: { _: [...Sr, ...Er] },
          },
          v = {
            variants: [
              { match: [/function/, /\s+/, r, /(?=\s*\()/] },
              { match: [/function/, /\s*(?=\()/] },
            ],
            className: { 1: 'keyword', 3: 'title.function' },
            label: 'func.def',
            contains: [k],
            illegal: /%/,
          },
          _ = {
            match: t.concat(
              /\b/,
              ((S = [...Dr, 'super', 'import'].map((e) => `${e}\\s*\\(`)),
              t.concat('(?!', S.join('|'), ')')),
              r,
              t.lookahead(/\s*\(/)
            ),
            className: 'title.function',
            relevance: 0,
          };
        var S;
        const E = {
            begin: t.concat(/\./, t.lookahead(t.concat(r, /(?![0-9A-Za-z$_(])/))),
            end: r,
            excludeBegin: !0,
            keywords: 'prototype',
            className: 'property',
            relevance: 0,
          },
          D = {
            match: [/get|set/, /\s+/, r, /(?=\()/],
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [{ begin: /\(\)/ }, k],
          },
          A =
            '(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|' +
            e.UNDERSCORE_IDENT_RE +
            ')\\s*=>',
          T = {
            match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, t.lookahead(A)],
            keywords: 'async',
            className: { 1: 'keyword', 3: 'title.function' },
            contains: [k],
          };
        return {
          name: 'JavaScript',
          aliases: ['js', 'jsx', 'mjs', 'cjs'],
          keywords: o,
          exports: { PARAMS_CONTAINS: x, CLASS_REFERENCE: w },
          illegal: /#(?![$_A-z])/,
          contains: [
            e.SHEBANG({ label: 'shebang', binary: 'node', relevance: 5 }),
            {
              label: 'use_strict',
              className: 'meta',
              relevance: 10,
              begin: /^\s*['"]use (strict|asm)['"]/,
            },
            e.APOS_STRING_MODE,
            e.QUOTE_STRING_MODE,
            u,
            p,
            g,
            f,
            m,
            { match: /\$\d+/ },
            h,
            w,
            { scope: 'attr', match: r + t.lookahead(':'), relevance: 0 },
            T,
            {
              begin: '(' + e.RE_STARTERS_RE + '|\\b(case|return|throw)\\b)\\s*',
              keywords: 'return throw case',
              relevance: 0,
              contains: [
                m,
                e.REGEXP_MODE,
                {
                  className: 'function',
                  begin: A,
                  returnBegin: !0,
                  end: '\\s*=>',
                  contains: [
                    {
                      className: 'params',
                      variants: [
                        { begin: e.UNDERSCORE_IDENT_RE, relevance: 0 },
                        { className: null, begin: /\(\s*\)/, skip: !0 },
                        {
                          begin: /(\s*)\(/,
                          end: /\)/,
                          excludeBegin: !0,
                          excludeEnd: !0,
                          keywords: o,
                          contains: x,
                        },
                      ],
                    },
                  ],
                },
                { begin: /,/, relevance: 0 },
                { match: /\s+/, relevance: 0 },
                {
                  variants: [
                    { begin: n, end: i },
                    { match: /<[A-Za-z0-9\\._:-]+\s*\/>/ },
                    { begin: a.begin, 'on:begin': a.isTrulyOpeningTag, end: a.end },
                  ],
                  subLanguage: 'xml',
                  contains: [{ begin: a.begin, end: a.end, skip: !0, contains: ['self'] }],
                },
              ],
            },
            v,
            { beginKeywords: 'while if switch catch for' },
            {
              begin:
                '\\b(?!function)' +
                e.UNDERSCORE_IDENT_RE +
                '\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{',
              returnBegin: !0,
              label: 'func.def',
              contains: [k, e.inherit(e.TITLE_MODE, { begin: r, className: 'title.function' })],
            },
            { match: /\.\.\./, relevance: 0 },
            E,
            { match: '\\$' + r, relevance: 0 },
            {
              match: [/\bconstructor(?=\s*\()/],
              className: { 1: 'title.function' },
              contains: [k],
            },
            _,
            { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: 'variable.constant' },
            C,
            D,
            { match: /\$[(.]/ },
          ],
        };
      })(e),
      n = wr,
      i = [
        'any',
        'void',
        'number',
        'boolean',
        'string',
        'object',
        'never',
        'symbol',
        'bigint',
        'unknown',
      ],
      a = {
        begin: [/namespace/, /\s+/, e.IDENT_RE],
        beginScope: { 1: 'keyword', 3: 'title.class' },
      },
      o = {
        beginKeywords: 'interface',
        end: /\{/,
        excludeEnd: !0,
        keywords: { keyword: 'interface extends', built_in: i },
        contains: [r.exports.CLASS_REFERENCE],
      },
      s = {
        $pattern: wr,
        keyword: vr.concat([
          'type',
          'interface',
          'public',
          'private',
          'protected',
          'implements',
          'declare',
          'abstract',
          'readonly',
          'enum',
          'override',
          'satisfies',
        ]),
        literal: _r,
        built_in: Tr.concat(i),
        'variable.language': Ar,
      },
      l = { className: 'meta', begin: '@' + n },
      c = (e, t, r) => {
        const n = e.contains.findIndex((e) => e.label === t);
        if (-1 === n) throw new Error('can not find mode to replace');
        e.contains.splice(n, 1, r);
      };
    (Object.assign(r.keywords, s), r.exports.PARAMS_CONTAINS.push(l));
    const h = r.contains.find((e) => 'attr' === e.scope),
      d = Object.assign({}, h, { match: t.concat(n, t.lookahead(/\s*\?:/)) });
    return (
      r.exports.PARAMS_CONTAINS.push([r.exports.CLASS_REFERENCE, h, d]),
      (r.contains = r.contains.concat([l, a, o, d])),
      c(r, 'shebang', e.SHEBANG()),
      c(r, 'use_strict', { className: 'meta', relevance: 10, begin: /^\s*['"]use strict['"]/ }),
      (r.contains.find((e) => 'func.def' === e.label).relevance = 0),
      Object.assign(r, { name: 'TypeScript', aliases: ['ts', 'tsx', 'mts', 'cts'] }),
      r
    );
  },
  vbnet: function (e) {
    const t = e.regex,
      r = /\d{1,2}\/\d{1,2}\/\d{4}/,
      n = /\d{4}-\d{1,2}-\d{1,2}/,
      i = /(\d|1[012])(:\d+){0,2} *(AM|PM)/,
      a = /\d{1,2}(:\d{1,2}){1,2}/,
      o = {
        className: 'literal',
        variants: [
          { begin: t.concat(/# */, t.either(n, r), / *#/) },
          { begin: t.concat(/# */, a, / *#/) },
          { begin: t.concat(/# */, i, / *#/) },
          { begin: t.concat(/# */, t.either(n, r), / +/, t.either(i, a), / *#/) },
        ],
      },
      s = e.COMMENT(/'''/, /$/, { contains: [{ className: 'doctag', begin: /<\/?/, end: />/ }] }),
      l = e.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] });
    return {
      name: 'Visual Basic .NET',
      aliases: ['vb'],
      case_insensitive: !0,
      classNameAliases: { label: 'symbol' },
      keywords: {
        keyword:
          'addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield',
        built_in:
          'addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort',
        type: 'boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort',
        literal: 'true false nothing',
      },
      illegal: '//|\\{|\\}|endif|gosub|variant|wend|^\\$ ',
      contains: [
        { className: 'string', begin: /"(""|[^/n])"C\b/ },
        { className: 'string', begin: /"/, end: /"/, illegal: /\n/, contains: [{ begin: /""/ }] },
        o,
        {
          className: 'number',
          relevance: 0,
          variants: [
            { begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/ },
            { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ },
            { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ },
            { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ },
            { begin: /&B[01_]+((U?[SIL])|[%&])?/ },
          ],
        },
        { className: 'label', begin: /^\w+:/ },
        s,
        l,
        {
          className: 'meta',
          begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
          end: /$/,
          keywords: {
            keyword: 'const disable else elseif enable end externalsource if region then',
          },
          contains: [l],
        },
      ],
    };
  },
  wasm: function (e) {
    e.regex;
    const t = e.COMMENT(/\(;/, /;\)/);
    return (
      t.contains.push('self'),
      {
        name: 'WebAssembly',
        keywords: {
          $pattern: /[\w.]+/,
          keyword: [
            'anyfunc',
            'block',
            'br',
            'br_if',
            'br_table',
            'call',
            'call_indirect',
            'data',
            'drop',
            'elem',
            'else',
            'end',
            'export',
            'func',
            'global.get',
            'global.set',
            'local.get',
            'local.set',
            'local.tee',
            'get_global',
            'get_local',
            'global',
            'if',
            'import',
            'local',
            'loop',
            'memory',
            'memory.grow',
            'memory.size',
            'module',
            'mut',
            'nop',
            'offset',
            'param',
            'result',
            'return',
            'select',
            'set_global',
            'set_local',
            'start',
            'table',
            'tee_local',
            'then',
            'type',
            'unreachable',
          ],
        },
        contains: [
          e.COMMENT(/;;/, /$/),
          t,
          { match: [/(?:offset|align)/, /\s*/, /=/], className: { 1: 'keyword', 3: 'operator' } },
          { className: 'variable', begin: /\$[\w_]+/ },
          { match: /(\((?!;)|\))+/, className: 'punctuation', relevance: 0 },
          {
            begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/],
            className: { 1: 'keyword', 3: 'title.function' },
          },
          e.QUOTE_STRING_MODE,
          { match: /(i32|i64|f32|f64)(?!\.)/, className: 'type' },
          {
            className: 'keyword',
            match:
              /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/,
          },
          {
            className: 'number',
            relevance: 0,
            match:
              /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
          },
        ],
      }
    );
  },
  xml: function (e) {
    const t = e.regex,
      r = t.concat(/[\p{L}_]/u, t.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u),
      n = { className: 'symbol', begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ },
      i = {
        begin: /\s/,
        contains: [{ className: 'keyword', begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }],
      },
      a = e.inherit(i, { begin: /\(/, end: /\)/ }),
      o = e.inherit(e.APOS_STRING_MODE, { className: 'string' }),
      s = e.inherit(e.QUOTE_STRING_MODE, { className: 'string' }),
      l = {
        endsWithParent: !0,
        illegal: /</,
        relevance: 0,
        contains: [
          { className: 'attr', begin: /[\p{L}0-9._:-]+/u, relevance: 0 },
          {
            begin: /=\s*/,
            relevance: 0,
            contains: [
              {
                className: 'string',
                endsParent: !0,
                variants: [
                  { begin: /"/, end: /"/, contains: [n] },
                  { begin: /'/, end: /'/, contains: [n] },
                  { begin: /[^\s"'=<>`]+/ },
                ],
              },
            ],
          },
        ],
      };
    return {
      name: 'HTML, XML',
      aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist', 'wsf', 'svg'],
      case_insensitive: !0,
      unicodeRegex: !0,
      contains: [
        {
          className: 'meta',
          begin: /<![a-z]/,
          end: />/,
          relevance: 10,
          contains: [
            i,
            s,
            o,
            a,
            {
              begin: /\[/,
              end: /\]/,
              contains: [{ className: 'meta', begin: /<![a-z]/, end: />/, contains: [i, a, s, o] }],
            },
          ],
        },
        e.COMMENT(/<!--/, /-->/, { relevance: 10 }),
        { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 },
        n,
        {
          className: 'meta',
          end: /\?>/,
          variants: [
            { begin: /<\?xml/, relevance: 10, contains: [s] },
            { begin: /<\?[a-z][a-z0-9]+/ },
          ],
        },
        {
          className: 'tag',
          begin: /<style(?=\s|>)/,
          end: />/,
          keywords: { name: 'style' },
          contains: [l],
          starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ['css', 'xml'] },
        },
        {
          className: 'tag',
          begin: /<script(?=\s|>)/,
          end: />/,
          keywords: { name: 'script' },
          contains: [l],
          starts: {
            end: /<\/script>/,
            returnEnd: !0,
            subLanguage: ['javascript', 'handlebars', 'xml'],
          },
        },
        { className: 'tag', begin: /<>|<\/>/ },
        {
          className: 'tag',
          begin: t.concat(/</, t.lookahead(t.concat(r, t.either(/\/>/, />/, /\s/)))),
          end: /\/?>/,
          contains: [{ className: 'name', begin: r, relevance: 0, starts: l }],
        },
        {
          className: 'tag',
          begin: t.concat(/<\//, t.lookahead(t.concat(r, />/))),
          contains: [
            { className: 'name', begin: r, relevance: 0 },
            { begin: />/, relevance: 0, endsParent: !0 },
          ],
        },
      ],
    };
  },
  yaml: function (e) {
    const t = 'true false yes no null',
      r = "[\\w#;/?:@&=+$,.~*'()[\\]]+",
      n = {
        className: 'string',
        relevance: 0,
        variants: [{ begin: /"/, end: /"/ }, { begin: /\S+/ }],
        contains: [
          e.BACKSLASH_ESCAPE,
          {
            className: 'template-variable',
            variants: [
              { begin: /\{\{/, end: /\}\}/ },
              { begin: /%\{/, end: /\}/ },
            ],
          },
        ],
      },
      i = e.inherit(n, {
        variants: [
          { begin: /'/, end: /'/, contains: [{ begin: /''/, relevance: 0 }] },
          { begin: /"/, end: /"/ },
          { begin: /[^\s,{}[\]]+/ },
        ],
      }),
      a = {
        className: 'number',
        begin:
          '\\b[0-9]{4}(-[0-9][0-9]){0,2}([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?(\\.[0-9]*)?([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?\\b',
      },
      o = { end: ',', endsWithParent: !0, excludeEnd: !0, keywords: t, relevance: 0 },
      s = { begin: /\{/, end: /\}/, contains: [o], illegal: '\\n', relevance: 0 },
      l = { begin: '\\[', end: '\\]', contains: [o], illegal: '\\n', relevance: 0 },
      c = [
        {
          className: 'attr',
          variants: [
            { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
            { begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ },
            { begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ },
          ],
        },
        { className: 'meta', begin: '^---\\s*$', relevance: 10 },
        {
          className: 'string',
          begin: '[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*',
        },
        {
          begin: '<%[%=-]?',
          end: '[%-]?%>',
          subLanguage: 'ruby',
          excludeBegin: !0,
          excludeEnd: !0,
          relevance: 0,
        },
        { className: 'type', begin: '!\\w+!' + r },
        { className: 'type', begin: '!<' + r + '>' },
        { className: 'type', begin: '!' + r },
        { className: 'type', begin: '!!' + r },
        { className: 'meta', begin: '&' + e.UNDERSCORE_IDENT_RE + '$' },
        { className: 'meta', begin: '\\*' + e.UNDERSCORE_IDENT_RE + '$' },
        { className: 'bullet', begin: '-(?=[ ]|$)', relevance: 0 },
        e.HASH_COMMENT_MODE,
        { beginKeywords: t, keywords: { literal: t } },
        a,
        { className: 'number', begin: e.C_NUMBER_RE + '\\b', relevance: 0 },
        s,
        l,
        {
          className: 'string',
          relevance: 0,
          begin: /'/,
          end: /'/,
          contains: [{ match: /''/, scope: 'char.escape', relevance: 0 }],
        },
        n,
      ],
      h = [...c];
    return (
      h.pop(),
      h.push(i),
      (o.contains = h),
      { name: 'YAML', case_insensitive: !0, aliases: ['yml'], contains: c }
    );
  },
};
function Br(e) {
  return (
    e instanceof Map
      ? (e.clear =
          e.delete =
          e.set =
            function () {
              throw new Error('map is read-only');
            })
      : e instanceof Set &&
        (e.add =
          e.clear =
          e.delete =
            function () {
              throw new Error('set is read-only');
            }),
    Object.freeze(e),
    Object.getOwnPropertyNames(e).forEach((t) => {
      const r = e[t],
        n = typeof r;
      ('object' !== n && 'function' !== n) || Object.isFrozen(r) || Br(r);
    }),
    e
  );
}
class Mr {
  constructor(e) {
    (void 0 === e.data && (e.data = {}), (this.data = e.data), (this.isMatchIgnored = !1));
  }
  ignoreMatch() {
    this.isMatchIgnored = !0;
  }
}
function Nr(e) {
  return e
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}
function Lr(e, ...t) {
  const r = Object.create(null);
  for (const n in e) r[n] = e[n];
  return (
    t.forEach(function (e) {
      for (const t in e) r[t] = e[t];
    }),
    r
  );
}
const Or = (e) => !!e.scope;
class $r {
  constructor(e, t) {
    ((this.buffer = ''), (this.classPrefix = t.classPrefix), e.walk(this));
  }
  addText(e) {
    this.buffer += Nr(e);
  }
  openNode(e) {
    if (!Or(e)) return;
    const t = ((e, { prefix: t }) => {
      if (e.startsWith('language:')) return e.replace('language:', 'language-');
      if (e.includes('.')) {
        const r = e.split('.');
        return [`${t}${r.shift()}`, ...r.map((e, t) => `${e}${'_'.repeat(t + 1)}`)].join(' ');
      }
      return `${t}${e}`;
    })(e.scope, { prefix: this.classPrefix });
    this.span(t);
  }
  closeNode(e) {
    Or(e) && (this.buffer += '</span>');
  }
  value() {
    return this.buffer;
  }
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
}
const Ir = (e = {}) => {
  const t = { children: [] };
  return (Object.assign(t, e), t);
};
class Rr {
  constructor() {
    ((this.rootNode = Ir()), (this.stack = [this.rootNode]));
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  add(e) {
    this.top.children.push(e);
  }
  openNode(e) {
    const t = Ir({ scope: e });
    (this.add(t), this.stack.push(t));
  }
  closeNode() {
    if (this.stack.length > 1) return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); );
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  static _walk(e, t) {
    return (
      'string' == typeof t
        ? e.addText(t)
        : t.children &&
          (e.openNode(t), t.children.forEach((t) => this._walk(e, t)), e.closeNode(t)),
      e
    );
  }
  static _collapse(e) {
    'string' != typeof e &&
      e.children &&
      (e.children.every((e) => 'string' == typeof e)
        ? (e.children = [e.children.join('')])
        : e.children.forEach((e) => {
            Rr._collapse(e);
          }));
  }
}
class zr extends Rr {
  constructor(e) {
    (super(), (this.options = e));
  }
  addText(e) {
    '' !== e && this.add(e);
  }
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  __addSublanguage(e, t) {
    const r = e.root;
    (t && (r.scope = `language:${t}`), this.add(r));
  }
  toHTML() {
    return new $r(this, this.options).value();
  }
  finalize() {
    return (this.closeAllNodes(), !0);
  }
}
function Pr(e) {
  return e ? ('string' == typeof e ? e : e.source) : null;
}
function jr(e) {
  return Ur('(?=', e, ')');
}
function qr(e) {
  return Ur('(?:', e, ')*');
}
function Wr(e) {
  return Ur('(?:', e, ')?');
}
function Ur(...e) {
  return e.map((e) => Pr(e)).join('');
}
function Hr(...e) {
  const t = (function (e) {
    const t = e[e.length - 1];
    return 'object' == typeof t && t.constructor === Object ? (e.splice(e.length - 1, 1), t) : {};
  })(e);
  return '(' + (t.capture ? '' : '?:') + e.map((e) => Pr(e)).join('|') + ')';
}
function Gr(e) {
  return new RegExp(e.toString() + '|').exec('').length - 1;
}
const Vr = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Zr(e, { joinWith: t }) {
  let r = 0;
  return e
    .map((e) => {
      r += 1;
      const t = r;
      let n = Pr(e),
        i = '';
      for (; n.length > 0; ) {
        const e = Vr.exec(n);
        if (!e) {
          i += n;
          break;
        }
        ((i += n.substring(0, e.index)),
          (n = n.substring(e.index + e[0].length)),
          '\\' === e[0][0] && e[1]
            ? (i += '\\' + String(Number(e[1]) + t))
            : ((i += e[0]), '(' === e[0] && r++));
      }
      return i;
    })
    .map((e) => `(${e})`)
    .join(t);
}
const Kr = '[a-zA-Z]\\w*',
  Yr = '[a-zA-Z_]\\w*',
  Xr = '\\b\\d+(\\.\\d+)?',
  Qr = '(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)',
  Jr = '\\b(0b[01]+)',
  en = { begin: '\\\\[\\s\\S]', relevance: 0 },
  tn = { scope: 'string', begin: "'", end: "'", illegal: '\\n', contains: [en] },
  rn = { scope: 'string', begin: '"', end: '"', illegal: '\\n', contains: [en] },
  nn = function (e, t, r = {}) {
    const n = Lr({ scope: 'comment', begin: e, end: t, contains: [] }, r);
    n.contains.push({
      scope: 'doctag',
      begin: '[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)',
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0,
    });
    const i = Hr(
      'I',
      'a',
      'is',
      'so',
      'us',
      'to',
      'at',
      'if',
      'in',
      'it',
      'on',
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      /[A-Za-z]+[-][a-z]+/,
      /[A-Za-z][a-z]{2,}/
    );
    return (n.contains.push({ begin: Ur(/[ ]+/, '(', i, /[.]?[:]?([.][ ]|[ ])/, '){3}') }), n);
  },
  an = nn('//', '$'),
  on = nn('/\\*', '\\*/'),
  sn = nn('#', '$'),
  ln = { scope: 'number', begin: Xr, relevance: 0 },
  cn = { scope: 'number', begin: Qr, relevance: 0 },
  hn = { scope: 'number', begin: Jr, relevance: 0 },
  dn = {
    scope: 'regexp',
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [en, { begin: /\[/, end: /\]/, relevance: 0, contains: [en] }],
  },
  un = { scope: 'title', begin: Kr, relevance: 0 },
  pn = { scope: 'title', begin: Yr, relevance: 0 },
  gn = { begin: '\\.\\s*' + Yr, relevance: 0 };
var fn = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: tn,
  BACKSLASH_ESCAPE: en,
  BINARY_NUMBER_MODE: hn,
  BINARY_NUMBER_RE: Jr,
  COMMENT: nn,
  C_BLOCK_COMMENT_MODE: on,
  C_LINE_COMMENT_MODE: an,
  C_NUMBER_MODE: cn,
  C_NUMBER_RE: Qr,
  END_SAME_AS_BEGIN: function (e) {
    return Object.assign(e, {
      'on:begin': (e, t) => {
        t.data._beginMatch = e[1];
      },
      'on:end': (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      },
    });
  },
  HASH_COMMENT_MODE: sn,
  IDENT_RE: Kr,
  MATCH_NOTHING_RE: /\b\B/,
  METHOD_GUARD: gn,
  NUMBER_MODE: ln,
  NUMBER_RE: Xr,
  PHRASAL_WORDS_MODE: {
    begin:
      /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/,
  },
  QUOTE_STRING_MODE: rn,
  REGEXP_MODE: dn,
  RE_STARTERS_RE:
    '!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~',
  SHEBANG: (e = {}) => {
    const t = /^#![ ]*\//;
    return (
      e.binary && (e.begin = Ur(t, /.*\b/, e.binary, /\b.*/)),
      Lr(
        {
          scope: 'meta',
          begin: t,
          end: /$/,
          relevance: 0,
          'on:begin': (e, t) => {
            0 !== e.index && t.ignoreMatch();
          },
        },
        e
      )
    );
  },
  TITLE_MODE: un,
  UNDERSCORE_IDENT_RE: Yr,
  UNDERSCORE_TITLE_MODE: pn,
});
function mn(e, t) {
  '.' === e.input[e.index - 1] && t.ignoreMatch();
}
function bn(e, t) {
  void 0 !== e.className && ((e.scope = e.className), delete e.className);
}
function yn(e, t) {
  t &&
    e.beginKeywords &&
    ((e.begin = '\\b(' + e.beginKeywords.split(' ').join('|') + ')(?!\\.)(?=\\b|\\s)'),
    (e.__beforeBegin = mn),
    (e.keywords = e.keywords || e.beginKeywords),
    delete e.beginKeywords,
    void 0 === e.relevance && (e.relevance = 0));
}
function xn(e, t) {
  Array.isArray(e.illegal) && (e.illegal = Hr(...e.illegal));
}
function kn(e, t) {
  if (e.match) {
    if (e.begin || e.end) throw new Error('begin & end are not supported with match');
    ((e.begin = e.match), delete e.match);
  }
}
function Cn(e, t) {
  void 0 === e.relevance && (e.relevance = 1);
}
const wn = (e, t) => {
    if (!e.beforeMatch) return;
    if (e.starts) throw new Error('beforeMatch cannot be used with starts');
    const r = Object.assign({}, e);
    (Object.keys(e).forEach((t) => {
      delete e[t];
    }),
      (e.keywords = r.keywords),
      (e.begin = Ur(r.beforeMatch, jr(r.begin))),
      (e.starts = { relevance: 0, contains: [Object.assign(r, { endsParent: !0 })] }),
      (e.relevance = 0),
      delete r.beforeMatch);
  },
  vn = ['of', 'and', 'for', 'in', 'not', 'or', 'if', 'then', 'parent', 'list', 'value'];
function _n(e, t, r = 'keyword') {
  const n = Object.create(null);
  return (
    'string' == typeof e
      ? i(r, e.split(' '))
      : Array.isArray(e)
        ? i(r, e)
        : Object.keys(e).forEach(function (r) {
            Object.assign(n, _n(e[r], t, r));
          }),
    n
  );
  function i(e, r) {
    (t && (r = r.map((e) => e.toLowerCase())),
      r.forEach(function (t) {
        const r = t.split('|');
        n[r[0]] = [e, Sn(r[0], r[1])];
      }));
  }
}
function Sn(e, t) {
  return t
    ? Number(t)
    : (function (e) {
          return vn.includes(e.toLowerCase());
        })(e)
      ? 0
      : 1;
}
const En = {},
  Dn = (e, t) => {
    En[`${e}/${t}`] || (En[`${e}/${t}`] = !0);
  },
  An = new Error();
function Tn(e, t, { key: r }) {
  let n = 0;
  const i = e[r],
    a = {},
    o = {};
  for (let s = 1; s <= t.length; s++) ((o[s + n] = i[s]), (a[s + n] = !0), (n += Gr(t[s - 1])));
  ((e[r] = o), (e[r]._emit = a), (e[r]._multi = !0));
}
function Fn(e) {
  (!(function (e) {
    e.scope &&
      'object' == typeof e.scope &&
      null !== e.scope &&
      ((e.beginScope = e.scope), delete e.scope);
  })(e),
    'string' == typeof e.beginScope && (e.beginScope = { _wrap: e.beginScope }),
    'string' == typeof e.endScope && (e.endScope = { _wrap: e.endScope }),
    (function (e) {
      if (Array.isArray(e.begin)) {
        if (e.skip || e.excludeBegin || e.returnBegin) throw An;
        if ('object' != typeof e.beginScope || null === e.beginScope) throw An;
        (Tn(e, e.begin, { key: 'beginScope' }), (e.begin = Zr(e.begin, { joinWith: '' })));
      }
    })(e),
    (function (e) {
      if (Array.isArray(e.end)) {
        if (e.skip || e.excludeEnd || e.returnEnd) throw An;
        if ('object' != typeof e.endScope || null === e.endScope) throw An;
        (Tn(e, e.end, { key: 'endScope' }), (e.end = Zr(e.end, { joinWith: '' })));
      }
    })(e));
}
function Bn(e) {
  function t(t, r) {
    return new RegExp(
      Pr(t),
      'm' + (e.case_insensitive ? 'i' : '') + (e.unicodeRegex ? 'u' : '') + (r ? 'g' : '')
    );
  }
  class r {
    constructor() {
      ((this.matchIndexes = {}), (this.regexes = []), (this.matchAt = 1), (this.position = 0));
    }
    addRule(e, t) {
      ((t.position = this.position++),
        (this.matchIndexes[this.matchAt] = t),
        this.regexes.push([t, e]),
        (this.matchAt += Gr(e) + 1));
    }
    compile() {
      0 === this.regexes.length && (this.exec = () => null);
      const e = this.regexes.map((e) => e[1]);
      ((this.matcherRe = t(Zr(e, { joinWith: '|' }), !0)), (this.lastIndex = 0));
    }
    exec(e) {
      this.matcherRe.lastIndex = this.lastIndex;
      const t = this.matcherRe.exec(e);
      if (!t) return null;
      const r = t.findIndex((e, t) => t > 0 && void 0 !== e),
        n = this.matchIndexes[r];
      return (t.splice(0, r), Object.assign(t, n));
    }
  }
  class n {
    constructor() {
      ((this.rules = []),
        (this.multiRegexes = []),
        (this.count = 0),
        (this.lastIndex = 0),
        (this.regexIndex = 0));
    }
    getMatcher(e) {
      if (this.multiRegexes[e]) return this.multiRegexes[e];
      const t = new r();
      return (
        this.rules.slice(e).forEach(([e, r]) => t.addRule(e, r)),
        t.compile(),
        (this.multiRegexes[e] = t),
        t
      );
    }
    resumingScanAtSamePosition() {
      return 0 !== this.regexIndex;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    addRule(e, t) {
      (this.rules.push([e, t]), 'begin' === t.type && this.count++);
    }
    exec(e) {
      const t = this.getMatcher(this.regexIndex);
      t.lastIndex = this.lastIndex;
      let r = t.exec(e);
      if (this.resumingScanAtSamePosition())
        if (r && r.index === this.lastIndex);
        else {
          const t = this.getMatcher(0);
          ((t.lastIndex = this.lastIndex + 1), (r = t.exec(e)));
        }
      return (
        r &&
          ((this.regexIndex += r.position + 1),
          this.regexIndex === this.count && this.considerAll()),
        r
      );
    }
  }
  if (
    (e.compilerExtensions || (e.compilerExtensions = []), e.contains && e.contains.includes('self'))
  )
    throw new Error(
      'ERR: contains `self` is not supported at the top-level of a language.  See documentation.'
    );
  return (
    (e.classNameAliases = Lr(e.classNameAliases || {})),
    (function r(i, a) {
      const o = i;
      if (i.isCompiled) return o;
      ([bn, kn, Fn, wn].forEach((e) => e(i, a)),
        e.compilerExtensions.forEach((e) => e(i, a)),
        (i.__beforeBegin = null),
        [yn, xn, Cn].forEach((e) => e(i, a)),
        (i.isCompiled = !0));
      let s = null;
      return (
        'object' == typeof i.keywords &&
          i.keywords.$pattern &&
          ((i.keywords = Object.assign({}, i.keywords)),
          (s = i.keywords.$pattern),
          delete i.keywords.$pattern),
        (s = s || /\w+/),
        i.keywords && (i.keywords = _n(i.keywords, e.case_insensitive)),
        (o.keywordPatternRe = t(s, !0)),
        a &&
          (i.begin || (i.begin = /\B|\b/),
          (o.beginRe = t(o.begin)),
          i.end || i.endsWithParent || (i.end = /\B|\b/),
          i.end && (o.endRe = t(o.end)),
          (o.terminatorEnd = Pr(o.end) || ''),
          i.endsWithParent &&
            a.terminatorEnd &&
            (o.terminatorEnd += (i.end ? '|' : '') + a.terminatorEnd)),
        i.illegal && (o.illegalRe = t(i.illegal)),
        i.contains || (i.contains = []),
        (i.contains = [].concat(
          ...i.contains.map(function (e) {
            return (function (e) {
              e.variants &&
                !e.cachedVariants &&
                (e.cachedVariants = e.variants.map(function (t) {
                  return Lr(e, { variants: null }, t);
                }));
              if (e.cachedVariants) return e.cachedVariants;
              if (Mn(e)) return Lr(e, { starts: e.starts ? Lr(e.starts) : null });
              if (Object.isFrozen(e)) return Lr(e);
              return e;
            })('self' === e ? i : e);
          })
        )),
        i.contains.forEach(function (e) {
          r(e, o);
        }),
        i.starts && r(i.starts, a),
        (o.matcher = (function (e) {
          const t = new n();
          return (
            e.contains.forEach((e) => t.addRule(e.begin, { rule: e, type: 'begin' })),
            e.terminatorEnd && t.addRule(e.terminatorEnd, { type: 'end' }),
            e.illegal && t.addRule(e.illegal, { type: 'illegal' }),
            t
          );
        })(o)),
        o
      );
    })(e)
  );
}
function Mn(e) {
  return !!e && (e.endsWithParent || Mn(e.starts));
}
class Nn extends Error {
  constructor(e, t) {
    (super(e), (this.name = 'HTMLInjectionError'), (this.html = t));
  }
}
const Ln = Nr,
  On = Lr,
  $n = Symbol('nomatch'),
  In = function (e) {
    const t = Object.create(null),
      r = Object.create(null),
      n = [];
    let i = !0;
    const a = "Could not find the language '{}', did you forget to load/include a language module?",
      o = { disableAutodetect: !0, name: 'Plain text', contains: [] };
    let s = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: 'hljs-',
      cssSelector: 'pre code',
      languages: null,
      __emitter: zr,
    };
    function l(e) {
      return s.noHighlightRe.test(e);
    }
    function c(e, t, r) {
      let n = '',
        i = '';
      ('object' == typeof t
        ? ((n = e), (r = t.ignoreIllegals), (i = t.language))
        : (Dn('10.7.0', 'highlight(lang, code, ...args) has been deprecated.'),
          Dn(
            '10.7.0',
            'Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277'
          ),
          (i = e),
          (n = t)),
        void 0 === r && (r = !0));
      const a = { code: n, language: i };
      y('before:highlight', a);
      const o = a.result ? a.result : h(a.language, a.code, r);
      return ((o.code = a.code), y('after:highlight', o), o);
    }
    function h(e, r, n, o) {
      const l = Object.create(null);
      function c(e, t) {
        return e.keywords[t];
      }
      function u() {
        if (!E.keywords) return void A.addText(T);
        let e = 0;
        E.keywordPatternRe.lastIndex = 0;
        let t = E.keywordPatternRe.exec(T),
          r = '';
        for (; t; ) {
          r += T.substring(e, t.index);
          const n = v.case_insensitive ? t[0].toLowerCase() : t[0],
            i = c(E, n);
          if (i) {
            const [e, a] = i;
            if (
              (A.addText(r),
              (r = ''),
              (l[n] = (l[n] || 0) + 1),
              l[n] <= 7 && (F += a),
              e.startsWith('_'))
            )
              r += t[0];
            else {
              const r = v.classNameAliases[e] || e;
              g(t[0], r);
            }
          } else r += t[0];
          ((e = E.keywordPatternRe.lastIndex), (t = E.keywordPatternRe.exec(T)));
        }
        ((r += T.substring(e)), A.addText(r));
      }
      function p() {
        (null != E.subLanguage
          ? (function () {
              if ('' === T) return;
              let e = null;
              if ('string' == typeof E.subLanguage) {
                if (!t[E.subLanguage]) return void A.addText(T);
                ((e = h(E.subLanguage, T, !0, D[E.subLanguage])), (D[E.subLanguage] = e._top));
              } else e = d(T, E.subLanguage.length ? E.subLanguage : null);
              (E.relevance > 0 && (F += e.relevance), A.__addSublanguage(e._emitter, e.language));
            })()
          : u(),
          (T = ''));
      }
      function g(e, t) {
        '' !== e && (A.startScope(t), A.addText(e), A.endScope());
      }
      function m(e, t) {
        let r = 1;
        const n = t.length - 1;
        for (; r <= n; ) {
          if (!e._emit[r]) {
            r++;
            continue;
          }
          const n = v.classNameAliases[e[r]] || e[r],
            i = t[r];
          (n ? g(i, n) : ((T = i), u(), (T = '')), r++);
        }
      }
      function b(e, t) {
        return (
          e.scope &&
            'string' == typeof e.scope &&
            A.openNode(v.classNameAliases[e.scope] || e.scope),
          e.beginScope &&
            (e.beginScope._wrap
              ? (g(T, v.classNameAliases[e.beginScope._wrap] || e.beginScope._wrap), (T = ''))
              : e.beginScope._multi && (m(e.beginScope, t), (T = ''))),
          (E = Object.create(e, { parent: { value: E } })),
          E
        );
      }
      function y(e, t, r) {
        let n = (function (e, t) {
          const r = e && e.exec(t);
          return r && 0 === r.index;
        })(e.endRe, r);
        if (n) {
          if (e['on:end']) {
            const r = new Mr(e);
            (e['on:end'](t, r), r.isMatchIgnored && (n = !1));
          }
          if (n) {
            for (; e.endsParent && e.parent; ) e = e.parent;
            return e;
          }
        }
        if (e.endsWithParent) return y(e.parent, t, r);
      }
      function x(e) {
        return 0 === E.matcher.regexIndex ? ((T += e[0]), 1) : ((N = !0), 0);
      }
      function k(e) {
        const t = e[0],
          n = r.substring(e.index),
          i = y(E, e, n);
        if (!i) return $n;
        const a = E;
        E.endScope && E.endScope._wrap
          ? (p(), g(t, E.endScope._wrap))
          : E.endScope && E.endScope._multi
            ? (p(), m(E.endScope, e))
            : a.skip
              ? (T += t)
              : (a.returnEnd || a.excludeEnd || (T += t), p(), a.excludeEnd && (T = t));
        do {
          (E.scope && A.closeNode(), E.skip || E.subLanguage || (F += E.relevance), (E = E.parent));
        } while (E !== i.parent);
        return (i.starts && b(i.starts, e), a.returnEnd ? 0 : t.length);
      }
      let C = {};
      function w(t, a) {
        const o = a && a[0];
        if (((T += t), null == o)) return (p(), 0);
        if ('begin' === C.type && 'end' === a.type && C.index === a.index && '' === o) {
          if (((T += r.slice(a.index, a.index + 1)), !i)) {
            const t = new Error(`0 width match regex (${e})`);
            throw ((t.languageName = e), (t.badRule = C.rule), t);
          }
          return 1;
        }
        if (((C = a), 'begin' === a.type))
          return (function (e) {
            const t = e[0],
              r = e.rule,
              n = new Mr(r),
              i = [r.__beforeBegin, r['on:begin']];
            for (const a of i) if (a && (a(e, n), n.isMatchIgnored)) return x(t);
            return (
              r.skip
                ? (T += t)
                : (r.excludeBegin && (T += t), p(), r.returnBegin || r.excludeBegin || (T = t)),
              b(r, e),
              r.returnBegin ? 0 : t.length
            );
          })(a);
        if ('illegal' === a.type && !n) {
          const e = new Error(
            'Illegal lexeme "' + o + '" for mode "' + (E.scope || '<unnamed>') + '"'
          );
          throw ((e.mode = E), e);
        }
        if ('end' === a.type) {
          const e = k(a);
          if (e !== $n) return e;
        }
        if ('illegal' === a.type && '' === o) return ((T += '\n'), 1);
        if (M > 1e5 && M > 3 * a.index) {
          throw new Error('potential infinite loop, way more iterations than matches');
        }
        return ((T += o), o.length);
      }
      const v = f(e);
      if (!v) throw (a.replace('{}', e), new Error('Unknown language: "' + e + '"'));
      const _ = Bn(v);
      let S = '',
        E = o || _;
      const D = {},
        A = new s.__emitter(s);
      !(function () {
        const e = [];
        for (let t = E; t !== v; t = t.parent) t.scope && e.unshift(t.scope);
        e.forEach((e) => A.openNode(e));
      })();
      let T = '',
        F = 0,
        B = 0,
        M = 0,
        N = !1;
      try {
        if (v.__emitTokens) v.__emitTokens(r, A);
        else {
          for (E.matcher.considerAll(); ; ) {
            (M++, N ? (N = !1) : E.matcher.considerAll(), (E.matcher.lastIndex = B));
            const e = E.matcher.exec(r);
            if (!e) break;
            const t = w(r.substring(B, e.index), e);
            B = e.index + t;
          }
          w(r.substring(B));
        }
        return (
          A.finalize(),
          (S = A.toHTML()),
          { language: e, value: S, relevance: F, illegal: !1, _emitter: A, _top: E }
        );
      } catch (L) {
        if (L.message && L.message.includes('Illegal'))
          return {
            language: e,
            value: Ln(r),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: L.message,
              index: B,
              context: r.slice(B - 100, B + 100),
              mode: L.mode,
              resultSoFar: S,
            },
            _emitter: A,
          };
        if (i)
          return {
            language: e,
            value: Ln(r),
            illegal: !1,
            relevance: 0,
            errorRaised: L,
            _emitter: A,
            _top: E,
          };
        throw L;
      }
    }
    function d(e, r) {
      r = r || s.languages || Object.keys(t);
      const n = (function (e) {
          const t = {
            value: Ln(e),
            illegal: !1,
            relevance: 0,
            _top: o,
            _emitter: new s.__emitter(s),
          };
          return (t._emitter.addText(e), t);
        })(e),
        i = r
          .filter(f)
          .filter(b)
          .map((t) => h(t, e, !1));
      i.unshift(n);
      const a = i.sort((e, t) => {
          if (e.relevance !== t.relevance) return t.relevance - e.relevance;
          if (e.language && t.language) {
            if (f(e.language).supersetOf === t.language) return 1;
            if (f(t.language).supersetOf === e.language) return -1;
          }
          return 0;
        }),
        [l, c] = a,
        d = l;
      return ((d.secondBest = c), d);
    }
    function u(e) {
      let t = null;
      const n = (function (e) {
        let t = e.className + ' ';
        t += e.parentNode ? e.parentNode.className : '';
        const r = s.languageDetectRe.exec(t);
        if (r) {
          const e = f(r[1]);
          return (e || a.replace('{}', r[1]), e ? r[1] : 'no-highlight');
        }
        return t.split(/\s+/).find((e) => l(e) || f(e));
      })(e);
      if (l(n)) return;
      if ((y('before:highlightElement', { el: e, language: n }), e.dataset.highlighted)) return;
      if (e.children.length > 0 && (s.ignoreUnescapedHTML, s.throwUnescapedHTML)) {
        throw new Nn('One of your code blocks includes unescaped HTML.', e.innerHTML);
      }
      t = e;
      const i = t.textContent,
        o = n ? c(i, { language: n, ignoreIllegals: !0 }) : d(i);
      ((e.innerHTML = o.value),
        (e.dataset.highlighted = 'yes'),
        (function (e, t, n) {
          const i = (t && r[t]) || n;
          (e.classList.add('hljs'), e.classList.add(`language-${i}`));
        })(e, n, o.language),
        (e.result = { language: o.language, re: o.relevance, relevance: o.relevance }),
        o.secondBest &&
          (e.secondBest = { language: o.secondBest.language, relevance: o.secondBest.relevance }),
        y('after:highlightElement', { el: e, result: o, text: i }));
    }
    let p = !1;
    function g() {
      if ('loading' === document.readyState)
        return (
          p ||
            window.addEventListener(
              'DOMContentLoaded',
              function () {
                g();
              },
              !1
            ),
          void (p = !0)
        );
      document.querySelectorAll(s.cssSelector).forEach(u);
    }
    function f(e) {
      return ((e = (e || '').toLowerCase()), t[e] || t[r[e]]);
    }
    function m(e, { languageName: t }) {
      ('string' == typeof e && (e = [e]),
        e.forEach((e) => {
          r[e.toLowerCase()] = t;
        }));
    }
    function b(e) {
      const t = f(e);
      return t && !t.disableAutodetect;
    }
    function y(e, t) {
      const r = e;
      n.forEach(function (e) {
        e[r] && e[r](t);
      });
    }
    (Object.assign(e, {
      highlight: c,
      highlightAuto: d,
      highlightAll: g,
      highlightElement: u,
      highlightBlock: function (e) {
        return (
          Dn('10.7.0', 'highlightBlock will be removed entirely in v12.0'),
          Dn('10.7.0', 'Please use highlightElement now.'),
          u(e)
        );
      },
      configure: function (e) {
        s = On(s, e);
      },
      initHighlighting: () => {
        (g(), Dn('10.6.0', 'initHighlighting() deprecated.  Use highlightAll() now.'));
      },
      initHighlightingOnLoad: function () {
        (g(), Dn('10.6.0', 'initHighlightingOnLoad() deprecated.  Use highlightAll() now.'));
      },
      registerLanguage: function (r, n) {
        let a = null;
        try {
          a = n(e);
        } catch (s) {
          if (("Language definition for '{}' could not be registered.".replace('{}', r), !i))
            throw s;
          a = o;
        }
        (a.name || (a.name = r),
          (t[r] = a),
          (a.rawDefinition = n.bind(null, e)),
          a.aliases && m(a.aliases, { languageName: r }));
      },
      unregisterLanguage: function (e) {
        delete t[e];
        for (const t of Object.keys(r)) r[t] === e && delete r[t];
      },
      listLanguages: function () {
        return Object.keys(t);
      },
      getLanguage: f,
      registerAliases: m,
      autoDetection: b,
      inherit: On,
      addPlugin: function (e) {
        (!(function (e) {
          (e['before:highlightBlock'] &&
            !e['before:highlightElement'] &&
            (e['before:highlightElement'] = (t) => {
              e['before:highlightBlock'](Object.assign({ block: t.el }, t));
            }),
            e['after:highlightBlock'] &&
              !e['after:highlightElement'] &&
              (e['after:highlightElement'] = (t) => {
                e['after:highlightBlock'](Object.assign({ block: t.el }, t));
              }));
        })(e),
          n.push(e));
      },
      removePlugin: function (e) {
        const t = n.indexOf(e);
        -1 !== t && n.splice(t, 1);
      },
    }),
      (e.debugMode = function () {
        i = !1;
      }),
      (e.safeMode = function () {
        i = !0;
      }),
      (e.versionString = '11.11.1'),
      (e.regex = { concat: Ur, lookahead: jr, either: Hr, optional: Wr, anyNumberOfTimes: qr }));
    for (const x in fn) 'object' == typeof fn[x] && Br(fn[x]);
    return (Object.assign(e, fn), e);
  },
  Rn = In({});
Rn.newInstance = () => In({});
var zn = Rn;
((Rn.HighlightJS = Rn), (Rn.default = Rn));
const Pn = k(zn),
  jn = {};
class qn {
  constructor(e) {
    ((this.options = e),
      (this.root = { type: 'root', children: [], data: { language: void 0, relevance: 0 } }),
      (this.stack = [this.root]));
  }
  addText(e) {
    if ('' === e) return;
    const t = this.stack[this.stack.length - 1],
      r = t.children[t.children.length - 1];
    r && 'text' === r.type ? (r.value += e) : t.children.push({ type: 'text', value: e });
  }
  startScope(e) {
    this.openNode(String(e));
  }
  endScope() {
    this.closeNode();
  }
  __addSublanguage(e, t) {
    const r = this.stack[this.stack.length - 1],
      n = e.root.children;
    t
      ? r.children.push({
          type: 'element',
          tagName: 'span',
          properties: { className: [t] },
          children: n,
        })
      : r.children.push(...n);
  }
  openNode(e) {
    const t = this,
      r = {
        type: 'element',
        tagName: 'span',
        properties: {
          className: e.split('.').map(function (e, r) {
            return r ? e + '_'.repeat(r) : t.options.classPrefix + e;
          }),
        },
        children: [],
      };
    (this.stack[this.stack.length - 1].children.push(r), this.stack.push(r));
  }
  closeNode() {
    this.stack.pop();
  }
  finalize() {}
  toHTML() {
    return '';
  }
}
const Wn = {};
function Un(e) {
  const t = e || Wn,
    r = t.aliases,
    n = t.detect || !1,
    i = t.languages || Fr,
    a = t.plainText,
    o = t.prefix,
    s = t.subset;
  let l = 'hljs';
  const c = (function (e) {
    const t = Pn.newInstance();
    return (
      e && i(e),
      {
        highlight: r,
        highlightAuto: function (e, i) {
          const a = (i || jn).subset || n();
          let o,
            s = -1,
            l = 0;
          for (; ++s < a.length; ) {
            const n = a[s];
            if (!t.getLanguage(n)) continue;
            const c = r(n, e, i);
            c.data &&
              void 0 !== c.data.relevance &&
              c.data.relevance > l &&
              ((l = c.data.relevance), (o = c));
          }
          return o || { type: 'root', children: [], data: { language: void 0, relevance: l } };
        },
        listLanguages: n,
        register: i,
        registerAlias: function (e, r) {
          if ('string' == typeof e)
            t.registerAliases('string' == typeof r ? r : [...r], { languageName: e });
          else {
            let r;
            for (r in e)
              if (Object.hasOwn(e, r)) {
                const n = e[r];
                t.registerAliases('string' == typeof n ? n : [...n], { languageName: r });
              }
          }
        },
        registered: function (e) {
          return Boolean(t.getLanguage(e));
        },
      }
    );
    function r(e, r, n) {
      const i = n || jn,
        a = 'string' == typeof i.prefix ? i.prefix : 'hljs-';
      if (!t.getLanguage(e)) throw new Error('Unknown language: `' + e + '` is not registered');
      t.configure({ __emitter: qn, classPrefix: a });
      const o = t.highlight(r, { ignoreIllegals: !0, language: e });
      if (o.errorRaised)
        throw new Error('Could not highlight with `Highlight.js`', { cause: o.errorRaised });
      const s = o._emitter.root,
        l = s.data;
      return ((l.language = o.language), (l.relevance = o.relevance), s);
    }
    function n() {
      return t.listLanguages();
    }
    function i(e, r) {
      if ('string' == typeof e) t.registerLanguage(e, r);
      else {
        let r;
        for (r in e) Object.hasOwn(e, r) && t.registerLanguage(r, e[r]);
      }
    }
  })(i);
  if ((r && c.registerAlias(r), o)) {
    const e = o.indexOf('-');
    l = -1 === e ? o : o.slice(0, e);
  }
  return function (e, t) {
    ae(e, 'element', function (e, r, i) {
      if ('code' !== e.tagName || !i || 'element' !== i.type || 'pre' !== i.tagName) return;
      const h = (function (e) {
        const t = e.properties.className;
        let r,
          n = -1;
        if (!Array.isArray(t)) return;
        for (; ++n < t.length; ) {
          const e = String(t[n]);
          if ('no-highlight' === e || 'nohighlight' === e) return !1;
          (r || 'lang-' !== e.slice(0, 5) || (r = e.slice(5)),
            r || 'language-' !== e.slice(0, 9) || (r = e.slice(9)));
        }
        return r;
      })(e);
      if (!1 === h || (!h && !n) || (h && a && a.includes(h))) return;
      (Array.isArray(e.properties.className) || (e.properties.className = []),
        e.properties.className.includes(l) || e.properties.className.unshift(l));
      const d = (function (e, t) {
        const r = t || {},
          n = 'children' in e ? e.children : [],
          i = mt(e),
          a = kt(e, { whitespace: r.whitespace || 'normal' }),
          o = [];
        ('text' !== e.type && 'comment' !== e.type) ||
          o.push(...yt(e, { breakBefore: !0, breakAfter: !0 }));
        let s = -1;
        for (; ++s < n.length; )
          o.push(
            ...bt(n[s], e, {
              whitespace: a,
              breakBefore: s ? void 0 : i,
              breakAfter: s < n.length - 1 ? dt(n[s + 1]) : i,
            })
          );
        const l = [];
        let c;
        for (s = -1; ++s < o.length; ) {
          const e = o[s];
          'number' == typeof e
            ? void 0 !== c && e > c && (c = e)
            : e && (void 0 !== c && c > -1 && l.push('\n'.repeat(c) || ' '), (c = -1), l.push(e));
        }
        return l.join('');
      })(e, { whitespace: 'pre' });
      let u;
      try {
        u = h ? c.highlight(h, d, { prefix: o }) : c.highlightAuto(d, { prefix: o, subset: s });
      } catch (p) {
        const r = p;
        if (h && /Unknown language/.test(r.message))
          return void t.message('Cannot highlight as `' + h + '`, it’s not registered', {
            ancestors: [i, e],
            cause: r,
            place: e.position,
            ruleId: 'missing-language',
            source: 'rehype-highlight',
          });
        throw r;
      }
      (!h &&
        u.data &&
        u.data.language &&
        e.properties.className.push('language-' + u.data.language),
        u.children.length > 0 && (e.children = u.children));
    });
  };
}
const Hn =
    /[\0-\x1F!-,\.\/:-@\[-\^`\{-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02C2-\u02C5\u02D2-\u02DF\u02E5-\u02EB\u02ED\u02EF-\u02FF\u0375\u0378\u0379\u037E\u0380-\u0385\u0387\u038B\u038D\u03A2\u03F6\u0482\u0530\u0557\u0558\u055A-\u055F\u0589-\u0590\u05BE\u05C0\u05C3\u05C6\u05C8-\u05CF\u05EB-\u05EE\u05F3-\u060F\u061B-\u061F\u066A-\u066D\u06D4\u06DD\u06DE\u06E9\u06FD\u06FE\u0700-\u070F\u074B\u074C\u07B2-\u07BF\u07F6-\u07F9\u07FB\u07FC\u07FE\u07FF\u082E-\u083F\u085C-\u085F\u086B-\u089F\u08B5\u08C8-\u08D2\u08E2\u0964\u0965\u0970\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09F2-\u09FB\u09FD\u09FF\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF0-\u0AF8\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B54\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B70\u0B72-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BF0-\u0BFF\u0C0D\u0C11\u0C29\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5B-\u0C5F\u0C64\u0C65\u0C70-\u0C7F\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0CFF\u0D0D\u0D11\u0D45\u0D49\u0D4F-\u0D53\u0D58-\u0D5E\u0D64\u0D65\u0D70-\u0D79\u0D80\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DE5\u0DF0\u0DF1\u0DF4-\u0E00\u0E3B-\u0E3F\u0E4F\u0E5A-\u0E80\u0E83\u0E85\u0E8B\u0EA4\u0EA6\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F01-\u0F17\u0F1A-\u0F1F\u0F2A-\u0F34\u0F36\u0F38\u0F3A-\u0F3D\u0F48\u0F6D-\u0F70\u0F85\u0F98\u0FBD-\u0FC5\u0FC7-\u0FFF\u104A-\u104F\u109E\u109F\u10C6\u10C8-\u10CC\u10CE\u10CF\u10FB\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u1360-\u137F\u1390-\u139F\u13F6\u13F7\u13FE-\u1400\u166D\u166E\u1680\u169B-\u169F\u16EB-\u16ED\u16F9-\u16FF\u170D\u1715-\u171F\u1735-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17D4-\u17D6\u17D8-\u17DB\u17DE\u17DF\u17EA-\u180A\u180E\u180F\u181A-\u181F\u1879-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191F\u192C-\u192F\u193C-\u1945\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DA-\u19FF\u1A1C-\u1A1F\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1AA6\u1AA8-\u1AAF\u1AC1-\u1AFF\u1B4C-\u1B4F\u1B5A-\u1B6A\u1B74-\u1B7F\u1BF4-\u1BFF\u1C38-\u1C3F\u1C4A-\u1C4C\u1C7E\u1C7F\u1C89-\u1C8F\u1CBB\u1CBC\u1CC0-\u1CCF\u1CD3\u1CFB-\u1CFF\u1DFA\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FBD\u1FBF-\u1FC1\u1FC5\u1FCD-\u1FCF\u1FD4\u1FD5\u1FDC-\u1FDF\u1FED-\u1FF1\u1FF5\u1FFD-\u203E\u2041-\u2053\u2055-\u2070\u2072-\u207E\u2080-\u208F\u209D-\u20CF\u20F1-\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u214F-\u215F\u2189-\u24B5\u24EA-\u2BFF\u2C2F\u2C5F\u2CE5-\u2CEA\u2CF4-\u2CFF\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D70-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E00-\u2E2E\u2E30-\u3004\u3008-\u3020\u3030\u3036\u3037\u303D-\u3040\u3097\u3098\u309B\u309C\u30A0\u30FB\u3100-\u3104\u3130\u318F-\u319F\u31C0-\u31EF\u3200-\u33FF\u4DC0-\u4DFF\u9FFD-\u9FFF\uA48D-\uA4CF\uA4FE\uA4FF\uA60D-\uA60F\uA62C-\uA63F\uA673\uA67E\uA6F2-\uA716\uA720\uA721\uA789\uA78A\uA7C0\uA7C1\uA7CB-\uA7F4\uA828-\uA82B\uA82D-\uA83F\uA874-\uA87F\uA8C6-\uA8CF\uA8DA-\uA8DF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA954-\uA95F\uA97D-\uA97F\uA9C1-\uA9CE\uA9DA-\uA9DF\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A-\uAA5F\uAA77-\uAA79\uAAC3-\uAADA\uAADE\uAADF\uAAF0\uAAF1\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F\uAB5B\uAB6A-\uAB6F\uABEB\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uD7FF\uE000-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB29\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBB2-\uFBD2\uFD3E-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFC-\uFDFF\uFE10-\uFE1F\uFE30-\uFE32\uFE35-\uFE4C\uFE50-\uFE6F\uFE75\uFEFD-\uFF0F\uFF1A-\uFF20\uFF3B-\uFF3E\uFF40\uFF5B-\uFF65\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFFF]|\uD800[\uDC0C\uDC27\uDC3B\uDC3E\uDC4E\uDC4F\uDC5E-\uDC7F\uDCFB-\uDD3F\uDD75-\uDDFC\uDDFE-\uDE7F\uDE9D-\uDE9F\uDED1-\uDEDF\uDEE1-\uDEFF\uDF20-\uDF2C\uDF4B-\uDF4F\uDF7B-\uDF7F\uDF9E\uDF9F\uDFC4-\uDFC7\uDFD0\uDFD6-\uDFFF]|\uD801[\uDC9E\uDC9F\uDCAA-\uDCAF\uDCD4-\uDCD7\uDCFC-\uDCFF\uDD28-\uDD2F\uDD64-\uDDFF\uDF37-\uDF3F\uDF56-\uDF5F\uDF68-\uDFFF]|\uD802[\uDC06\uDC07\uDC09\uDC36\uDC39-\uDC3B\uDC3D\uDC3E\uDC56-\uDC5F\uDC77-\uDC7F\uDC9F-\uDCDF\uDCF3\uDCF6-\uDCFF\uDD16-\uDD1F\uDD3A-\uDD7F\uDDB8-\uDDBD\uDDC0-\uDDFF\uDE04\uDE07-\uDE0B\uDE14\uDE18\uDE36\uDE37\uDE3B-\uDE3E\uDE40-\uDE5F\uDE7D-\uDE7F\uDE9D-\uDEBF\uDEC8\uDEE7-\uDEFF\uDF36-\uDF3F\uDF56-\uDF5F\uDF73-\uDF7F\uDF92-\uDFFF]|\uD803[\uDC49-\uDC7F\uDCB3-\uDCBF\uDCF3-\uDCFF\uDD28-\uDD2F\uDD3A-\uDE7F\uDEAA\uDEAD-\uDEAF\uDEB2-\uDEFF\uDF1D-\uDF26\uDF28-\uDF2F\uDF51-\uDFAF\uDFC5-\uDFDF\uDFF7-\uDFFF]|\uD804[\uDC47-\uDC65\uDC70-\uDC7E\uDCBB-\uDCCF\uDCE9-\uDCEF\uDCFA-\uDCFF\uDD35\uDD40-\uDD43\uDD48-\uDD4F\uDD74\uDD75\uDD77-\uDD7F\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDFF\uDE12\uDE38-\uDE3D\uDE3F-\uDE7F\uDE87\uDE89\uDE8E\uDE9E\uDEA9-\uDEAF\uDEEB-\uDEEF\uDEFA-\uDEFF\uDF04\uDF0D\uDF0E\uDF11\uDF12\uDF29\uDF31\uDF34\uDF3A\uDF45\uDF46\uDF49\uDF4A\uDF4E\uDF4F\uDF51-\uDF56\uDF58-\uDF5C\uDF64\uDF65\uDF6D-\uDF6F\uDF75-\uDFFF]|\uD805[\uDC4B-\uDC4F\uDC5A-\uDC5D\uDC62-\uDC7F\uDCC6\uDCC8-\uDCCF\uDCDA-\uDD7F\uDDB6\uDDB7\uDDC1-\uDDD7\uDDDE-\uDDFF\uDE41-\uDE43\uDE45-\uDE4F\uDE5A-\uDE7F\uDEB9-\uDEBF\uDECA-\uDEFF\uDF1B\uDF1C\uDF2C-\uDF2F\uDF3A-\uDFFF]|\uD806[\uDC3B-\uDC9F\uDCEA-\uDCFE\uDD07\uDD08\uDD0A\uDD0B\uDD14\uDD17\uDD36\uDD39\uDD3A\uDD44-\uDD4F\uDD5A-\uDD9F\uDDA8\uDDA9\uDDD8\uDDD9\uDDE2\uDDE5-\uDDFF\uDE3F-\uDE46\uDE48-\uDE4F\uDE9A-\uDE9C\uDE9E-\uDEBF\uDEF9-\uDFFF]|\uD807[\uDC09\uDC37\uDC41-\uDC4F\uDC5A-\uDC71\uDC90\uDC91\uDCA8\uDCB7-\uDCFF\uDD07\uDD0A\uDD37-\uDD39\uDD3B\uDD3E\uDD48-\uDD4F\uDD5A-\uDD5F\uDD66\uDD69\uDD8F\uDD92\uDD99-\uDD9F\uDDAA-\uDEDF\uDEF7-\uDFAF\uDFB1-\uDFFF]|\uD808[\uDF9A-\uDFFF]|\uD809[\uDC6F-\uDC7F\uDD44-\uDFFF]|[\uD80A\uD80B\uD80E-\uD810\uD812-\uD819\uD824-\uD82B\uD82D\uD82E\uD830-\uD833\uD837\uD839\uD83D\uD83F\uD87B-\uD87D\uD87F\uD885-\uDB3F\uDB41-\uDBFF][\uDC00-\uDFFF]|\uD80D[\uDC2F-\uDFFF]|\uD811[\uDE47-\uDFFF]|\uD81A[\uDE39-\uDE3F\uDE5F\uDE6A-\uDECF\uDEEE\uDEEF\uDEF5-\uDEFF\uDF37-\uDF3F\uDF44-\uDF4F\uDF5A-\uDF62\uDF78-\uDF7C\uDF90-\uDFFF]|\uD81B[\uDC00-\uDE3F\uDE80-\uDEFF\uDF4B-\uDF4E\uDF88-\uDF8E\uDFA0-\uDFDF\uDFE2\uDFE5-\uDFEF\uDFF2-\uDFFF]|\uD821[\uDFF8-\uDFFF]|\uD823[\uDCD6-\uDCFF\uDD09-\uDFFF]|\uD82C[\uDD1F-\uDD4F\uDD53-\uDD63\uDD68-\uDD6F\uDEFC-\uDFFF]|\uD82F[\uDC6B-\uDC6F\uDC7D-\uDC7F\uDC89-\uDC8F\uDC9A-\uDC9C\uDC9F-\uDFFF]|\uD834[\uDC00-\uDD64\uDD6A-\uDD6C\uDD73-\uDD7A\uDD83\uDD84\uDD8C-\uDDA9\uDDAE-\uDE41\uDE45-\uDFFF]|\uD835[\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDEC1\uDEDB\uDEFB\uDF15\uDF35\uDF4F\uDF6F\uDF89\uDFA9\uDFC3\uDFCC\uDFCD]|\uD836[\uDC00-\uDDFF\uDE37-\uDE3A\uDE6D-\uDE74\uDE76-\uDE83\uDE85-\uDE9A\uDEA0\uDEB0-\uDFFF]|\uD838[\uDC07\uDC19\uDC1A\uDC22\uDC25\uDC2B-\uDCFF\uDD2D-\uDD2F\uDD3E\uDD3F\uDD4A-\uDD4D\uDD4F-\uDEBF\uDEFA-\uDFFF]|\uD83A[\uDCC5-\uDCCF\uDCD7-\uDCFF\uDD4C-\uDD4F\uDD5A-\uDFFF]|\uD83B[\uDC00-\uDDFF\uDE04\uDE20\uDE23\uDE25\uDE26\uDE28\uDE33\uDE38\uDE3A\uDE3C-\uDE41\uDE43-\uDE46\uDE48\uDE4A\uDE4C\uDE50\uDE53\uDE55\uDE56\uDE58\uDE5A\uDE5C\uDE5E\uDE60\uDE63\uDE65\uDE66\uDE6B\uDE73\uDE78\uDE7D\uDE7F\uDE8A\uDE9C-\uDEA0\uDEA4\uDEAA\uDEBC-\uDFFF]|\uD83C[\uDC00-\uDD2F\uDD4A-\uDD4F\uDD6A-\uDD6F\uDD8A-\uDFFF]|\uD83E[\uDC00-\uDFEF\uDFFA-\uDFFF]|\uD869[\uDEDE-\uDEFF]|\uD86D[\uDF35-\uDF3F]|\uD86E[\uDC1E\uDC1F]|\uD873[\uDEA2-\uDEAF]|\uD87A[\uDFE1-\uDFFF]|\uD87E[\uDE1E-\uDFFF]|\uD884[\uDF4B-\uDFFF]|\uDB40[\uDC00-\uDCFF\uDDF0-\uDFFF]/g,
  Gn = Object.hasOwnProperty;
function Vn(e) {
  return 'text' === e.type ? e.value : 'children' in e ? Zn(e) : '';
}
function Zn(e) {
  let t = -1;
  const r = [];
  for (; ++t < e.children.length; ) r[t] = Vn(e.children[t]);
  return r.join('');
}
const Kn = {},
  Yn = new (class {
    constructor() {
      (this.occurrences, this.reset());
    }
    slug(e, t) {
      const r = this;
      let n = (function (e, t) {
        if ('string' != typeof e) return '';
        t || (e = e.toLowerCase());
        return e.replace(Hn, '').replace(/ /g, '-');
      })(e, !0 === t);
      const i = n;
      for (; Gn.call(r.occurrences, n); ) (r.occurrences[i]++, (n = i + '-' + r.occurrences[i]));
      return ((r.occurrences[n] = 0), n);
    }
    reset() {
      this.occurrences = Object.create(null);
    }
  })();
function Xn(e) {
  const t = (e || Kn).prefix || '';
  return function (e) {
    (Yn.reset(),
      ae(e, 'element', function (e) {
        (function (e) {
          const t = 'element' === e.type ? e.tagName.toLowerCase() : '',
            r = 2 === t.length && 104 === t.charCodeAt(0) ? t.charCodeAt(1) : 0;
          return r > 48 && r < 55 ? r - 48 : void 0;
        })(e) &&
          !e.properties.id &&
          (e.properties.id =
            t +
            Yn.slug(
              (function (e) {
                return 'children' in e ? Zn(e) : 'value' in e ? e.value : '';
              })(e)
            ));
      }));
  };
}
function Qn({ content: e, headings: t, sticky: r = !0, className: n = '' }) {
  const [i, a] = C.useState(t || []),
    [o, s] = C.useState('');
  if (
    (C.useEffect(() => {
      if (e && !t) {
        const t = /^(#{1,6})\s+(.+)$/gm,
          r = [];
        let n;
        for (; null !== (n = t.exec(e)); ) {
          const e = n[1].length,
            t = n[2].trim(),
            i = t
              .toLowerCase()
              .replace(/[^\w\s-]/g, '')
              .replace(/\s+/g, '-');
          r.push({ id: i, text: t, level: e });
        }
        a(r);
      }
    }, [e, t]),
    C.useEffect(() => {
      if (0 === i.length) return;
      const e = new IntersectionObserver(
        (e) => {
          e.forEach((e) => {
            e.isIntersecting && s(e.target.id);
          });
        },
        { rootMargin: '-80px 0px -80% 0px', threshold: 1 }
      );
      return (
        i.forEach(({ id: t }) => {
          const r = document.getElementById(t);
          r && e.observe(r);
        }),
        () => e.disconnect()
      );
    }, [i]),
    0 === i.length)
  )
    return null;
  const l = r ? 'sticky top-24 max-h-[calc(100vh-7rem)] overflow-y-auto' : '';
  return u.jsxs('nav', {
    className: `w-64 ${l} ${n}`,
    'aria-label': 'Table of Contents',
    children: [
      u.jsxs('div', {
        className: 'flex items-center gap-2 mb-4 pb-2 border-b border-border',
        children: [
          u.jsx(p, { className: 'h-4 w-4 text-muted-foreground' }),
          u.jsx('h4', {
            className: 'text-sm font-semibold text-foreground',
            children: 'On This Page',
          }),
        ],
      }),
      u.jsx('ul', {
        className: 'space-y-2 text-sm',
        children: i.map(({ id: e, text: t, level: r }) => {
          const n = o === e,
            i = 12 * (r - 1);
          return u.jsx(
            'li',
            {
              style: { paddingLeft: `${i}px` },
              className: 'transition-all duration-200',
              children: u.jsx('a', {
                href: `#${e}`,
                className: `\n                  block py-1 px-2 rounded transition-colors\n                  ${n ? 'text-primary font-medium bg-primary/10' : 'text-muted-foreground hover:text-foreground hover:bg-muted'}\n                `,
                onClick: (t) => {
                  t.preventDefault();
                  const r = document.getElementById(e);
                  if (r) {
                    const t = -80,
                      n = r.getBoundingClientRect().top + window.pageYOffset + t;
                    (window.scrollTo({ top: n, behavior: 'smooth' }),
                      window.history.pushState(null, '', `#${e}`),
                      s(e));
                  }
                },
                children: t,
              }),
            },
            e
          );
        }),
      }),
    ],
  });
}
function Jn({
  children: e,
  className: t = '',
  language: r,
  inline: n = !1,
  showLineNumbers: i = !1,
  showCopyButton: a = !0,
}) {
  const [o, s] = C.useState(!1),
    l = String(e || ''),
    c = r || (null == t ? void 0 : t.replace(/language-/, '')) || '';
  if (n)
    return u.jsx('code', {
      className:
        'bg-muted px-1.5 py-0.5 rounded text-sm font-mono text-foreground border border-border',
      children: l,
    });
  const h = l.includes('\n') || l.length > 80,
    d = l.split('\n').filter((e, t, r) => t !== r.length - 1 || '' !== e.trim());
  return u.jsxs('div', {
    className: 'relative group my-4',
    children: [
      h &&
        a &&
        u.jsxs('div', {
          className:
            'flex items-center justify-between px-4 py-2 bg-muted/50 border border-border rounded-t-lg',
          children: [
            c &&
              u.jsx('span', {
                className: 'text-xs font-medium text-muted-foreground uppercase tracking-wide',
                children: c,
              }),
            !c && u.jsx('span', {}),
            u.jsx('button', {
              onClick: async () => {
                try {
                  (await navigator.clipboard.writeText(l), s(!0), setTimeout(() => s(!1), 2e3));
                } catch (e) {}
              },
              className:
                'flex items-center gap-1.5 px-2 py-1 text-xs rounded hover:bg-muted transition-colors text-muted-foreground hover:text-foreground',
              title: 'Copy code',
              children: o
                ? u.jsxs(u.Fragment, {
                    children: [
                      u.jsx(g, { className: 'h-3 w-3' }),
                      u.jsx('span', { children: 'Copied!' }),
                    ],
                  })
                : u.jsxs(u.Fragment, {
                    children: [
                      u.jsx(f, { className: 'h-3 w-3' }),
                      u.jsx('span', { children: 'Copy' }),
                    ],
                  }),
            }),
          ],
        }),
      u.jsx('pre', {
        className:
          'bg-muted border border-border p-4 overflow-x-auto ' +
          (h && a ? 'rounded-b-lg border-t-0' : 'rounded-lg'),
        children: u.jsx('code', {
          className: `${t} block text-sm font-mono`,
          children: i
            ? u.jsx('table', {
                className: 'w-full border-collapse',
                children: u.jsx('tbody', {
                  children: d.map((e, t) =>
                    u.jsxs(
                      'tr',
                      {
                        children: [
                          u.jsx('td', {
                            className: 'pr-4 text-right text-muted-foreground select-none w-8',
                            children: t + 1,
                          }),
                          u.jsx('td', { className: 'text-foreground', children: e }),
                        ],
                      },
                      t
                    )
                  ),
                }),
              })
            : l,
        }),
      }),
    ],
  });
}
var ei = {
    name: 'mermaid',
    version: '11.12.2',
    description:
      'Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.',
    type: 'module',
    module: './dist/mermaid.core.mjs',
    types: './dist/mermaid.d.ts',
    exports: {
      '.': {
        types: './dist/mermaid.d.ts',
        import: './dist/mermaid.core.mjs',
        default: './dist/mermaid.core.mjs',
      },
      './*': './*',
    },
    keywords: [
      'diagram',
      'markdown',
      'flowchart',
      'sequence diagram',
      'gantt',
      'class diagram',
      'git graph',
      'mindmap',
      'packet diagram',
      'c4 diagram',
      'er diagram',
      'pie chart',
      'pie diagram',
      'quadrant chart',
      'requirement diagram',
      'graph',
    ],
    scripts: {
      clean: 'rimraf dist',
      dev: 'pnpm -w dev',
      'docs:code':
        'typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup',
      'docs:build':
        'rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts',
      'docs:verify': 'pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify',
      'docs:pre:vitepress':
        'pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts',
      'docs:build:vitepress':
        'pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing',
      'docs:dev':
        'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
      'docs:dev:docker':
        'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
      'docs:serve': 'pnpm docs:build:vitepress && vitepress serve src/vitepress',
      'docs:spellcheck': 'cspell "src/docs/**/*.md"',
      'docs:release-version': 'tsx scripts/update-release-version.mts',
      'docs:verify-version': 'tsx scripts/update-release-version.mts --verify',
      'types:build-config': 'tsx scripts/create-types-from-json-schema.mts',
      'types:verify-config': 'tsx scripts/create-types-from-json-schema.mts --verify',
      checkCircle: 'npx madge --circular ./src',
      prepublishOnly: 'pnpm docs:verify-version',
    },
    repository: { type: 'git', url: 'https://github.com/mermaid-js/mermaid' },
    author: 'Knut Sveidqvist',
    license: 'MIT',
    standard: { ignore: ['**/parser/*.js', 'dist/**/*.js', 'cypress/**/*.js'], globals: ['page'] },
    dependencies: {
      '@braintree/sanitize-url': '^7.1.1',
      '@iconify/utils': '^3.0.1',
      '@mermaid-js/parser': 'workspace:^',
      '@types/d3': '^7.4.3',
      cytoscape: '^3.29.3',
      'cytoscape-cose-bilkent': '^4.1.0',
      'cytoscape-fcose': '^2.2.0',
      d3: '^7.9.0',
      'd3-sankey': '^0.12.3',
      'dagre-d3-es': '7.0.13',
      dayjs: '^1.11.18',
      dompurify: '^3.2.5',
      katex: '^0.16.22',
      khroma: '^2.1.0',
      'lodash-es': '^4.17.21',
      marked: '^16.2.1',
      roughjs: '^4.6.6',
      stylis: '^4.3.6',
      'ts-dedent': '^2.2.0',
      uuid: '^11.1.0',
    },
    devDependencies: {
      '@adobe/jsonschema2md': '^8.0.5',
      '@iconify/types': '^2.0.0',
      '@types/cytoscape': '^3.21.9',
      '@types/cytoscape-fcose': '^2.2.4',
      '@types/d3-sankey': '^0.12.4',
      '@types/d3-scale': '^4.0.9',
      '@types/d3-scale-chromatic': '^3.1.0',
      '@types/d3-selection': '^3.0.11',
      '@types/d3-shape': '^3.1.7',
      '@types/jsdom': '^21.1.7',
      '@types/katex': '^0.16.7',
      '@types/lodash-es': '^4.17.12',
      '@types/micromatch': '^4.0.9',
      '@types/stylis': '^4.2.7',
      '@types/uuid': '^10.0.0',
      ajv: '^8.17.1',
      canvas: '^3.1.2',
      chokidar: '3.6.0',
      concurrently: '^9.1.2',
      'csstree-validator': '^4.0.1',
      globby: '^14.1.0',
      jison: '^0.4.18',
      'js-base64': '^3.7.8',
      jsdom: '^26.1.0',
      'json-schema-to-typescript': '^15.0.4',
      micromatch: '^4.0.8',
      'path-browserify': '^1.0.1',
      prettier: '^3.5.3',
      remark: '^15.0.1',
      'remark-frontmatter': '^5.0.0',
      'remark-gfm': '^4.0.1',
      rimraf: '^6.0.1',
      'start-server-and-test': '^2.0.13',
      'type-fest': '^4.35.0',
      typedoc: '^0.28.12',
      'typedoc-plugin-markdown': '^4.8.1',
      typescript: '~5.7.3',
      'unist-util-flatmap': '^1.0.0',
      'unist-util-visit': '^5.0.0',
      vitepress: '^1.6.4',
      'vitepress-plugin-search': '1.0.4-alpha.22',
    },
    files: ['dist/', 'README.md'],
    publishConfig: { access: 'public' },
  },
  ti = { exports: {} };
const ri = k(
  (ti.exports = (function () {
    var e = 1e3,
      t = 6e4,
      r = 36e5,
      n = 'millisecond',
      i = 'second',
      a = 'minute',
      o = 'hour',
      s = 'day',
      l = 'week',
      c = 'month',
      h = 'quarter',
      d = 'year',
      u = 'date',
      p = 'Invalid Date',
      g =
        /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
      f = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
      m = {
        name: 'en',
        weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        months:
          'January_February_March_April_May_June_July_August_September_October_November_December'.split(
            '_'
          ),
        ordinal: function (e) {
          var t = ['th', 'st', 'nd', 'rd'],
            r = e % 100;
          return '[' + e + (t[(r - 20) % 10] || t[r] || t[0]) + ']';
        },
      },
      b = function (e, t, r) {
        var n = String(e);
        return !n || n.length >= t ? e : '' + Array(t + 1 - n.length).join(r) + e;
      },
      y = {
        s: b,
        z: function (e) {
          var t = -e.utcOffset(),
            r = Math.abs(t),
            n = Math.floor(r / 60),
            i = r % 60;
          return (t <= 0 ? '+' : '-') + b(n, 2, '0') + ':' + b(i, 2, '0');
        },
        m: function e(t, r) {
          if (t.date() < r.date()) return -e(r, t);
          var n = 12 * (r.year() - t.year()) + (r.month() - t.month()),
            i = t.clone().add(n, c),
            a = r - i < 0,
            o = t.clone().add(n + (a ? -1 : 1), c);
          return +(-(n + (r - i) / (a ? i - o : o - i)) || 0);
        },
        a: function (e) {
          return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
        },
        p: function (e) {
          return (
            { M: c, y: d, w: l, d: s, D: u, h: o, m: a, s: i, ms: n, Q: h }[e] ||
            String(e || '')
              .toLowerCase()
              .replace(/s$/, '')
          );
        },
        u: function (e) {
          return void 0 === e;
        },
      },
      x = 'en',
      k = {};
    k[x] = m;
    var C = '$isDayjsObject',
      w = function (e) {
        return e instanceof E || !(!e || !e[C]);
      },
      v = function e(t, r, n) {
        var i;
        if (!t) return x;
        if ('string' == typeof t) {
          var a = t.toLowerCase();
          (k[a] && (i = a), r && ((k[a] = r), (i = a)));
          var o = t.split('-');
          if (!i && o.length > 1) return e(o[0]);
        } else {
          var s = t.name;
          ((k[s] = t), (i = s));
        }
        return (!n && i && (x = i), i || (!n && x));
      },
      _ = function (e, t) {
        if (w(e)) return e.clone();
        var r = 'object' == typeof t ? t : {};
        return ((r.date = e), (r.args = arguments), new E(r));
      },
      S = y;
    ((S.l = v),
      (S.i = w),
      (S.w = function (e, t) {
        return _(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset });
      }));
    var E = (function () {
        function m(e) {
          ((this.$L = v(e.locale, null, !0)),
            this.parse(e),
            (this.$x = this.$x || e.x || {}),
            (this[C] = !0));
        }
        var b = m.prototype;
        return (
          (b.parse = function (e) {
            ((this.$d = (function (e) {
              var t = e.date,
                r = e.utc;
              if (null === t) return new Date(NaN);
              if (S.u(t)) return new Date();
              if (t instanceof Date) return new Date(t);
              if ('string' == typeof t && !/Z$/i.test(t)) {
                var n = t.match(g);
                if (n) {
                  var i = n[2] - 1 || 0,
                    a = (n[7] || '0').substring(0, 3);
                  return r
                    ? new Date(Date.UTC(n[1], i, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, a))
                    : new Date(n[1], i, n[3] || 1, n[4] || 0, n[5] || 0, n[6] || 0, a);
                }
              }
              return new Date(t);
            })(e)),
              this.init());
          }),
          (b.init = function () {
            var e = this.$d;
            ((this.$y = e.getFullYear()),
              (this.$M = e.getMonth()),
              (this.$D = e.getDate()),
              (this.$W = e.getDay()),
              (this.$H = e.getHours()),
              (this.$m = e.getMinutes()),
              (this.$s = e.getSeconds()),
              (this.$ms = e.getMilliseconds()));
          }),
          (b.$utils = function () {
            return S;
          }),
          (b.isValid = function () {
            return !(this.$d.toString() === p);
          }),
          (b.isSame = function (e, t) {
            var r = _(e);
            return this.startOf(t) <= r && r <= this.endOf(t);
          }),
          (b.isAfter = function (e, t) {
            return _(e) < this.startOf(t);
          }),
          (b.isBefore = function (e, t) {
            return this.endOf(t) < _(e);
          }),
          (b.$g = function (e, t, r) {
            return S.u(e) ? this[t] : this.set(r, e);
          }),
          (b.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }),
          (b.valueOf = function () {
            return this.$d.getTime();
          }),
          (b.startOf = function (e, t) {
            var r = this,
              n = !!S.u(t) || t,
              h = S.p(e),
              p = function (e, t) {
                var i = S.w(r.$u ? Date.UTC(r.$y, t, e) : new Date(r.$y, t, e), r);
                return n ? i : i.endOf(s);
              },
              g = function (e, t) {
                return S.w(
                  r
                    .toDate()
                    [e].apply(r.toDate('s'), (n ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(t)),
                  r
                );
              },
              f = this.$W,
              m = this.$M,
              b = this.$D,
              y = 'set' + (this.$u ? 'UTC' : '');
            switch (h) {
              case d:
                return n ? p(1, 0) : p(31, 11);
              case c:
                return n ? p(1, m) : p(0, m + 1);
              case l:
                var x = this.$locale().weekStart || 0,
                  k = (f < x ? f + 7 : f) - x;
                return p(n ? b - k : b + (6 - k), m);
              case s:
              case u:
                return g(y + 'Hours', 0);
              case o:
                return g(y + 'Minutes', 1);
              case a:
                return g(y + 'Seconds', 2);
              case i:
                return g(y + 'Milliseconds', 3);
              default:
                return this.clone();
            }
          }),
          (b.endOf = function (e) {
            return this.startOf(e, !1);
          }),
          (b.$set = function (e, t) {
            var r,
              l = S.p(e),
              h = 'set' + (this.$u ? 'UTC' : ''),
              p = ((r = {}),
              (r[s] = h + 'Date'),
              (r[u] = h + 'Date'),
              (r[c] = h + 'Month'),
              (r[d] = h + 'FullYear'),
              (r[o] = h + 'Hours'),
              (r[a] = h + 'Minutes'),
              (r[i] = h + 'Seconds'),
              (r[n] = h + 'Milliseconds'),
              r)[l],
              g = l === s ? this.$D + (t - this.$W) : t;
            if (l === c || l === d) {
              var f = this.clone().set(u, 1);
              (f.$d[p](g), f.init(), (this.$d = f.set(u, Math.min(this.$D, f.daysInMonth())).$d));
            } else p && this.$d[p](g);
            return (this.init(), this);
          }),
          (b.set = function (e, t) {
            return this.clone().$set(e, t);
          }),
          (b.get = function (e) {
            return this[S.p(e)]();
          }),
          (b.add = function (n, h) {
            var u,
              p = this;
            n = Number(n);
            var g = S.p(h),
              f = function (e) {
                var t = _(p);
                return S.w(t.date(t.date() + Math.round(e * n)), p);
              };
            if (g === c) return this.set(c, this.$M + n);
            if (g === d) return this.set(d, this.$y + n);
            if (g === s) return f(1);
            if (g === l) return f(7);
            var m = ((u = {}), (u[a] = t), (u[o] = r), (u[i] = e), u)[g] || 1,
              b = this.$d.getTime() + n * m;
            return S.w(b, this);
          }),
          (b.subtract = function (e, t) {
            return this.add(-1 * e, t);
          }),
          (b.format = function (e) {
            var t = this,
              r = this.$locale();
            if (!this.isValid()) return r.invalidDate || p;
            var n = e || 'YYYY-MM-DDTHH:mm:ssZ',
              i = S.z(this),
              a = this.$H,
              o = this.$m,
              s = this.$M,
              l = r.weekdays,
              c = r.months,
              h = r.meridiem,
              d = function (e, r, i, a) {
                return (e && (e[r] || e(t, n))) || i[r].slice(0, a);
              },
              u = function (e) {
                return S.s(a % 12 || 12, e, '0');
              },
              g =
                h ||
                function (e, t, r) {
                  var n = e < 12 ? 'AM' : 'PM';
                  return r ? n.toLowerCase() : n;
                };
            return n.replace(f, function (e, n) {
              return (
                n ||
                (function (e) {
                  switch (e) {
                    case 'YY':
                      return String(t.$y).slice(-2);
                    case 'YYYY':
                      return S.s(t.$y, 4, '0');
                    case 'M':
                      return s + 1;
                    case 'MM':
                      return S.s(s + 1, 2, '0');
                    case 'MMM':
                      return d(r.monthsShort, s, c, 3);
                    case 'MMMM':
                      return d(c, s);
                    case 'D':
                      return t.$D;
                    case 'DD':
                      return S.s(t.$D, 2, '0');
                    case 'd':
                      return String(t.$W);
                    case 'dd':
                      return d(r.weekdaysMin, t.$W, l, 2);
                    case 'ddd':
                      return d(r.weekdaysShort, t.$W, l, 3);
                    case 'dddd':
                      return l[t.$W];
                    case 'H':
                      return String(a);
                    case 'HH':
                      return S.s(a, 2, '0');
                    case 'h':
                      return u(1);
                    case 'hh':
                      return u(2);
                    case 'a':
                      return g(a, o, !0);
                    case 'A':
                      return g(a, o, !1);
                    case 'm':
                      return String(o);
                    case 'mm':
                      return S.s(o, 2, '0');
                    case 's':
                      return String(t.$s);
                    case 'ss':
                      return S.s(t.$s, 2, '0');
                    case 'SSS':
                      return S.s(t.$ms, 3, '0');
                    case 'Z':
                      return i;
                  }
                  return null;
                })(e) ||
                i.replace(':', '')
              );
            });
          }),
          (b.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }),
          (b.diff = function (n, u, p) {
            var g,
              f = this,
              m = S.p(u),
              b = _(n),
              y = (b.utcOffset() - this.utcOffset()) * t,
              x = this - b,
              k = function () {
                return S.m(f, b);
              };
            switch (m) {
              case d:
                g = k() / 12;
                break;
              case c:
                g = k();
                break;
              case h:
                g = k() / 3;
                break;
              case l:
                g = (x - y) / 6048e5;
                break;
              case s:
                g = (x - y) / 864e5;
                break;
              case o:
                g = x / r;
                break;
              case a:
                g = x / t;
                break;
              case i:
                g = x / e;
                break;
              default:
                g = x;
            }
            return p ? g : S.a(g);
          }),
          (b.daysInMonth = function () {
            return this.endOf(c).$D;
          }),
          (b.$locale = function () {
            return k[this.$L];
          }),
          (b.locale = function (e, t) {
            if (!e) return this.$L;
            var r = this.clone(),
              n = v(e, t, !0);
            return (n && (r.$L = n), r);
          }),
          (b.clone = function () {
            return S.w(this.$d, this);
          }),
          (b.toDate = function () {
            return new Date(this.valueOf());
          }),
          (b.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }),
          (b.toISOString = function () {
            return this.$d.toISOString();
          }),
          (b.toString = function () {
            return this.$d.toUTCString();
          }),
          m
        );
      })(),
      D = E.prototype;
    return (
      (_.prototype = D),
      [
        ['$ms', n],
        ['$s', i],
        ['$m', a],
        ['$H', o],
        ['$W', s],
        ['$M', c],
        ['$y', d],
        ['$D', u],
      ].forEach(function (e) {
        D[e[1]] = function (t) {
          return this.$g(t, e[0], e[1]);
        };
      }),
      (_.extend = function (e, t) {
        return (e.$i || (e(t, E, _), (e.$i = !0)), _);
      }),
      (_.locale = v),
      (_.isDayjs = w),
      (_.unix = function (e) {
        return _(1e3 * e);
      }),
      (_.en = k[x]),
      (_.Ls = k),
      (_.p = {}),
      _
    );
  })())
);
var ni = Object.defineProperty,
  ii = (e, t) => ni(e, 'name', { value: t, configurable: !0 }),
  ai = (e, t) => {
    for (var r in t) ni(e, r, { get: t[r], enumerable: !0 });
  },
  oi = { trace: 0, debug: 1, info: 2, warn: 3, error: 4, fatal: 5 },
  si = {
    trace: ii((...e) => {}, 'trace'),
    debug: ii((...e) => {}, 'debug'),
    info: ii((...e) => {}, 'info'),
    warn: ii((...e) => {}, 'warn'),
    error: ii((...e) => {}, 'error'),
    fatal: ii((...e) => {}, 'fatal'),
  },
  li = ii(function (e = 'fatal') {
    let t = oi.fatal;
    ('string' == typeof e ? e.toLowerCase() in oi && (t = oi[e]) : 'number' == typeof e && (t = e),
      (si.trace = () => {}),
      (si.debug = () => {}),
      (si.info = () => {}),
      (si.warn = () => {}),
      (si.error = () => {}),
      (si.fatal = () => {}),
      t <= oi.fatal && (si.fatal = (console.error, function () {}.bind())),
      t <= oi.error && (si.error = (console.error, function () {}.bind())),
      t <= oi.warn && (si.warn = (console.warn, function () {}.bind())),
      t <= oi.info && (si.info = (console.info, function () {}.bind())),
      t <= oi.debug && (si.debug = (console.debug, function () {}.bind())),
      t <= oi.trace && (si.trace = (console.debug, function () {}.bind())));
  }, 'setLogLevel');
const ci = {
    min: { r: 0, g: 0, b: 0, s: 0, l: 0, a: 0 },
    max: { r: 255, g: 255, b: 255, h: 360, s: 100, l: 100, a: 1 },
    clamp: {
      r: (e) => (e >= 255 ? 255 : e < 0 ? 0 : e),
      g: (e) => (e >= 255 ? 255 : e < 0 ? 0 : e),
      b: (e) => (e >= 255 ? 255 : e < 0 ? 0 : e),
      h: (e) => e % 360,
      s: (e) => (e >= 100 ? 100 : e < 0 ? 0 : e),
      l: (e) => (e >= 100 ? 100 : e < 0 ? 0 : e),
      a: (e) => (e >= 1 ? 1 : e < 0 ? 0 : e),
    },
    toLinear: (e) => {
      const t = e / 255;
      return e > 0.03928 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92;
    },
    hue2rgb: (e, t, r) => (
      r < 0 && (r += 1),
      r > 1 && (r -= 1),
      r < 1 / 6 ? e + 6 * (t - e) * r : r < 0.5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
    ),
    hsl2rgb: ({ h: e, s: t, l: r }, n) => {
      if (!t) return 2.55 * r;
      ((e /= 360), (t /= 100));
      const i = (r /= 100) < 0.5 ? r * (1 + t) : r + t - r * t,
        a = 2 * r - i;
      switch (n) {
        case 'r':
          return 255 * ci.hue2rgb(a, i, e + 1 / 3);
        case 'g':
          return 255 * ci.hue2rgb(a, i, e);
        case 'b':
          return 255 * ci.hue2rgb(a, i, e - 1 / 3);
      }
    },
    rgb2hsl: ({ r: e, g: t, b: r }, n) => {
      ((e /= 255), (t /= 255), (r /= 255));
      const i = Math.max(e, t, r),
        a = Math.min(e, t, r),
        o = (i + a) / 2;
      if ('l' === n) return 100 * o;
      if (i === a) return 0;
      const s = i - a;
      if ('s' === n) return 100 * (o > 0.5 ? s / (2 - i - a) : s / (i + a));
      switch (i) {
        case e:
          return 60 * ((t - r) / s + (t < r ? 6 : 0));
        case t:
          return 60 * ((r - e) / s + 2);
        case r:
          return 60 * ((e - t) / s + 4);
        default:
          return -1;
      }
    },
  },
  hi = {
    channel: ci,
    lang: {
      clamp: (e, t, r) => (t > r ? Math.min(t, Math.max(r, e)) : Math.min(r, Math.max(t, e))),
      round: (e) => Math.round(1e10 * e) / 1e10,
    },
    unit: {
      dec2hex: (e) => {
        const t = Math.round(e).toString(16);
        return t.length > 1 ? t : `0${t}`;
      },
    },
  },
  di = {};
for (let Uw = 0; Uw <= 255; Uw++) di[Uw] = hi.unit.dec2hex(Uw);
const ui = 0,
  pi = 1,
  gi = 2;
class fi {
  constructor() {
    this.type = ui;
  }
  get() {
    return this.type;
  }
  set(e) {
    if (this.type && this.type !== e)
      throw new Error('Cannot change both RGB and HSL channels at the same time');
    this.type = e;
  }
  reset() {
    this.type = ui;
  }
  is(e) {
    return this.type === e;
  }
}
const mi = new (class {
    constructor(e, t) {
      ((this.color = t), (this.changed = !1), (this.data = e), (this.type = new fi()));
    }
    set(e, t) {
      return ((this.color = t), (this.changed = !1), (this.data = e), (this.type.type = ui), this);
    }
    _ensureHSL() {
      const e = this.data,
        { h: t, s: r, l: n } = e;
      (void 0 === t && (e.h = hi.channel.rgb2hsl(e, 'h')),
        void 0 === r && (e.s = hi.channel.rgb2hsl(e, 's')),
        void 0 === n && (e.l = hi.channel.rgb2hsl(e, 'l')));
    }
    _ensureRGB() {
      const e = this.data,
        { r: t, g: r, b: n } = e;
      (void 0 === t && (e.r = hi.channel.hsl2rgb(e, 'r')),
        void 0 === r && (e.g = hi.channel.hsl2rgb(e, 'g')),
        void 0 === n && (e.b = hi.channel.hsl2rgb(e, 'b')));
    }
    get r() {
      const e = this.data,
        t = e.r;
      return this.type.is(gi) || void 0 === t ? (this._ensureHSL(), hi.channel.hsl2rgb(e, 'r')) : t;
    }
    get g() {
      const e = this.data,
        t = e.g;
      return this.type.is(gi) || void 0 === t ? (this._ensureHSL(), hi.channel.hsl2rgb(e, 'g')) : t;
    }
    get b() {
      const e = this.data,
        t = e.b;
      return this.type.is(gi) || void 0 === t ? (this._ensureHSL(), hi.channel.hsl2rgb(e, 'b')) : t;
    }
    get h() {
      const e = this.data,
        t = e.h;
      return this.type.is(pi) || void 0 === t ? (this._ensureRGB(), hi.channel.rgb2hsl(e, 'h')) : t;
    }
    get s() {
      const e = this.data,
        t = e.s;
      return this.type.is(pi) || void 0 === t ? (this._ensureRGB(), hi.channel.rgb2hsl(e, 's')) : t;
    }
    get l() {
      const e = this.data,
        t = e.l;
      return this.type.is(pi) || void 0 === t ? (this._ensureRGB(), hi.channel.rgb2hsl(e, 'l')) : t;
    }
    get a() {
      return this.data.a;
    }
    set r(e) {
      (this.type.set(pi), (this.changed = !0), (this.data.r = e));
    }
    set g(e) {
      (this.type.set(pi), (this.changed = !0), (this.data.g = e));
    }
    set b(e) {
      (this.type.set(pi), (this.changed = !0), (this.data.b = e));
    }
    set h(e) {
      (this.type.set(gi), (this.changed = !0), (this.data.h = e));
    }
    set s(e) {
      (this.type.set(gi), (this.changed = !0), (this.data.s = e));
    }
    set l(e) {
      (this.type.set(gi), (this.changed = !0), (this.data.l = e));
    }
    set a(e) {
      ((this.changed = !0), (this.data.a = e));
    }
  })({ r: 0, g: 0, b: 0, a: 0 }, 'transparent'),
  bi = {
    re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
    parse: (e) => {
      if (35 !== e.charCodeAt(0)) return;
      const t = e.match(bi.re);
      if (!t) return;
      const r = t[1],
        n = parseInt(r, 16),
        i = r.length,
        a = i % 4 == 0,
        o = i > 4,
        s = o ? 1 : 17,
        l = o ? 8 : 4,
        c = a ? 0 : -1,
        h = o ? 255 : 15;
      return mi.set(
        {
          r: ((n >> (l * (c + 3))) & h) * s,
          g: ((n >> (l * (c + 2))) & h) * s,
          b: ((n >> (l * (c + 1))) & h) * s,
          a: a ? ((n & h) * s) / 255 : 1,
        },
        e
      );
    },
    stringify: (e) => {
      const { r: t, g: r, b: n, a: i } = e;
      return i < 1
        ? `#${di[Math.round(t)]}${di[Math.round(r)]}${di[Math.round(n)]}${di[Math.round(255 * i)]}`
        : `#${di[Math.round(t)]}${di[Math.round(r)]}${di[Math.round(n)]}`;
    },
  },
  yi = {
    re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
    hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
    _hue2deg: (e) => {
      const t = e.match(yi.hueRe);
      if (t) {
        const [, e, r] = t;
        switch (r) {
          case 'grad':
            return hi.channel.clamp.h(0.9 * parseFloat(e));
          case 'rad':
            return hi.channel.clamp.h((180 * parseFloat(e)) / Math.PI);
          case 'turn':
            return hi.channel.clamp.h(360 * parseFloat(e));
        }
      }
      return hi.channel.clamp.h(parseFloat(e));
    },
    parse: (e) => {
      const t = e.charCodeAt(0);
      if (104 !== t && 72 !== t) return;
      const r = e.match(yi.re);
      if (!r) return;
      const [, n, i, a, o, s] = r;
      return mi.set(
        {
          h: yi._hue2deg(n),
          s: hi.channel.clamp.s(parseFloat(i)),
          l: hi.channel.clamp.l(parseFloat(a)),
          a: o ? hi.channel.clamp.a(s ? parseFloat(o) / 100 : parseFloat(o)) : 1,
        },
        e
      );
    },
    stringify: (e) => {
      const { h: t, s: r, l: n, a: i } = e;
      return i < 1
        ? `hsla(${hi.lang.round(t)}, ${hi.lang.round(r)}%, ${hi.lang.round(n)}%, ${i})`
        : `hsl(${hi.lang.round(t)}, ${hi.lang.round(r)}%, ${hi.lang.round(n)}%)`;
    },
  },
  xi = {
    colors: {
      aliceblue: '#f0f8ff',
      antiquewhite: '#faebd7',
      aqua: '#00ffff',
      aquamarine: '#7fffd4',
      azure: '#f0ffff',
      beige: '#f5f5dc',
      bisque: '#ffe4c4',
      black: '#000000',
      blanchedalmond: '#ffebcd',
      blue: '#0000ff',
      blueviolet: '#8a2be2',
      brown: '#a52a2a',
      burlywood: '#deb887',
      cadetblue: '#5f9ea0',
      chartreuse: '#7fff00',
      chocolate: '#d2691e',
      coral: '#ff7f50',
      cornflowerblue: '#6495ed',
      cornsilk: '#fff8dc',
      crimson: '#dc143c',
      cyanaqua: '#00ffff',
      darkblue: '#00008b',
      darkcyan: '#008b8b',
      darkgoldenrod: '#b8860b',
      darkgray: '#a9a9a9',
      darkgreen: '#006400',
      darkgrey: '#a9a9a9',
      darkkhaki: '#bdb76b',
      darkmagenta: '#8b008b',
      darkolivegreen: '#556b2f',
      darkorange: '#ff8c00',
      darkorchid: '#9932cc',
      darkred: '#8b0000',
      darksalmon: '#e9967a',
      darkseagreen: '#8fbc8f',
      darkslateblue: '#483d8b',
      darkslategray: '#2f4f4f',
      darkslategrey: '#2f4f4f',
      darkturquoise: '#00ced1',
      darkviolet: '#9400d3',
      deeppink: '#ff1493',
      deepskyblue: '#00bfff',
      dimgray: '#696969',
      dimgrey: '#696969',
      dodgerblue: '#1e90ff',
      firebrick: '#b22222',
      floralwhite: '#fffaf0',
      forestgreen: '#228b22',
      fuchsia: '#ff00ff',
      gainsboro: '#dcdcdc',
      ghostwhite: '#f8f8ff',
      gold: '#ffd700',
      goldenrod: '#daa520',
      gray: '#808080',
      green: '#008000',
      greenyellow: '#adff2f',
      grey: '#808080',
      honeydew: '#f0fff0',
      hotpink: '#ff69b4',
      indianred: '#cd5c5c',
      indigo: '#4b0082',
      ivory: '#fffff0',
      khaki: '#f0e68c',
      lavender: '#e6e6fa',
      lavenderblush: '#fff0f5',
      lawngreen: '#7cfc00',
      lemonchiffon: '#fffacd',
      lightblue: '#add8e6',
      lightcoral: '#f08080',
      lightcyan: '#e0ffff',
      lightgoldenrodyellow: '#fafad2',
      lightgray: '#d3d3d3',
      lightgreen: '#90ee90',
      lightgrey: '#d3d3d3',
      lightpink: '#ffb6c1',
      lightsalmon: '#ffa07a',
      lightseagreen: '#20b2aa',
      lightskyblue: '#87cefa',
      lightslategray: '#778899',
      lightslategrey: '#778899',
      lightsteelblue: '#b0c4de',
      lightyellow: '#ffffe0',
      lime: '#00ff00',
      limegreen: '#32cd32',
      linen: '#faf0e6',
      magenta: '#ff00ff',
      maroon: '#800000',
      mediumaquamarine: '#66cdaa',
      mediumblue: '#0000cd',
      mediumorchid: '#ba55d3',
      mediumpurple: '#9370db',
      mediumseagreen: '#3cb371',
      mediumslateblue: '#7b68ee',
      mediumspringgreen: '#00fa9a',
      mediumturquoise: '#48d1cc',
      mediumvioletred: '#c71585',
      midnightblue: '#191970',
      mintcream: '#f5fffa',
      mistyrose: '#ffe4e1',
      moccasin: '#ffe4b5',
      navajowhite: '#ffdead',
      navy: '#000080',
      oldlace: '#fdf5e6',
      olive: '#808000',
      olivedrab: '#6b8e23',
      orange: '#ffa500',
      orangered: '#ff4500',
      orchid: '#da70d6',
      palegoldenrod: '#eee8aa',
      palegreen: '#98fb98',
      paleturquoise: '#afeeee',
      palevioletred: '#db7093',
      papayawhip: '#ffefd5',
      peachpuff: '#ffdab9',
      peru: '#cd853f',
      pink: '#ffc0cb',
      plum: '#dda0dd',
      powderblue: '#b0e0e6',
      purple: '#800080',
      rebeccapurple: '#663399',
      red: '#ff0000',
      rosybrown: '#bc8f8f',
      royalblue: '#4169e1',
      saddlebrown: '#8b4513',
      salmon: '#fa8072',
      sandybrown: '#f4a460',
      seagreen: '#2e8b57',
      seashell: '#fff5ee',
      sienna: '#a0522d',
      silver: '#c0c0c0',
      skyblue: '#87ceeb',
      slateblue: '#6a5acd',
      slategray: '#708090',
      slategrey: '#708090',
      snow: '#fffafa',
      springgreen: '#00ff7f',
      tan: '#d2b48c',
      teal: '#008080',
      thistle: '#d8bfd8',
      transparent: '#00000000',
      turquoise: '#40e0d0',
      violet: '#ee82ee',
      wheat: '#f5deb3',
      white: '#ffffff',
      whitesmoke: '#f5f5f5',
      yellow: '#ffff00',
      yellowgreen: '#9acd32',
    },
    parse: (e) => {
      e = e.toLowerCase();
      const t = xi.colors[e];
      if (t) return bi.parse(t);
    },
    stringify: (e) => {
      const t = bi.stringify(e);
      for (const r in xi.colors) if (xi.colors[r] === t) return r;
    },
  },
  ki = {
    re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
    parse: (e) => {
      const t = e.charCodeAt(0);
      if (114 !== t && 82 !== t) return;
      const r = e.match(ki.re);
      if (!r) return;
      const [, n, i, a, o, s, l, c, h] = r;
      return mi.set(
        {
          r: hi.channel.clamp.r(i ? 2.55 * parseFloat(n) : parseFloat(n)),
          g: hi.channel.clamp.g(o ? 2.55 * parseFloat(a) : parseFloat(a)),
          b: hi.channel.clamp.b(l ? 2.55 * parseFloat(s) : parseFloat(s)),
          a: c ? hi.channel.clamp.a(h ? parseFloat(c) / 100 : parseFloat(c)) : 1,
        },
        e
      );
    },
    stringify: (e) => {
      const { r: t, g: r, b: n, a: i } = e;
      return i < 1
        ? `rgba(${hi.lang.round(t)}, ${hi.lang.round(r)}, ${hi.lang.round(n)}, ${hi.lang.round(i)})`
        : `rgb(${hi.lang.round(t)}, ${hi.lang.round(r)}, ${hi.lang.round(n)})`;
    },
  },
  Ci = {
    format: { keyword: xi, hex: bi, rgb: ki, rgba: ki, hsl: yi, hsla: yi },
    parse: (e) => {
      if ('string' != typeof e) return e;
      const t = bi.parse(e) || ki.parse(e) || yi.parse(e) || xi.parse(e);
      if (t) return t;
      throw new Error(`Unsupported color format: "${e}"`);
    },
    stringify: (e) =>
      !e.changed && e.color
        ? e.color
        : e.type.is(gi) || void 0 === e.data.r
          ? yi.stringify(e)
          : e.a < 1 || !Number.isInteger(e.r) || !Number.isInteger(e.g) || !Number.isInteger(e.b)
            ? ki.stringify(e)
            : bi.stringify(e),
  },
  wi = (e, t) => {
    const r = Ci.parse(e);
    for (const n in t) r[n] = hi.channel.clamp[n](t[n]);
    return Ci.stringify(r);
  },
  vi = (e, t, r = 0, n = 1) => {
    if ('number' != typeof e) return wi(e, { a: t });
    const i = mi.set({
      r: hi.channel.clamp.r(e),
      g: hi.channel.clamp.g(t),
      b: hi.channel.clamp.b(r),
      a: hi.channel.clamp.a(n),
    });
    return Ci.stringify(i);
  },
  _i = (e) =>
    ((e) => {
      const { r: t, g: r, b: n } = Ci.parse(e),
        i =
          0.2126 * hi.channel.toLinear(t) +
          0.7152 * hi.channel.toLinear(r) +
          0.0722 * hi.channel.toLinear(n);
      return hi.lang.round(i);
    })(e) >= 0.5,
  Si = (e) => !_i(e),
  Ei = (e, t, r) => {
    const n = Ci.parse(e),
      i = n[t],
      a = hi.channel.clamp[t](i + r);
    return (i !== a && (n[t] = a), Ci.stringify(n));
  },
  Di = (e, t) => Ei(e, 'l', t),
  Ai = (e, t) => Ei(e, 'l', -t),
  Ti = (e, t) => {
    const r = Ci.parse(e),
      n = {};
    for (const i in t) t[i] && (n[i] = r[i] + t[i]);
    return wi(e, n);
  },
  Fi = (e, t = 100) => {
    const r = Ci.parse(e);
    return (
      (r.r = 255 - r.r),
      (r.g = 255 - r.g),
      (r.b = 255 - r.b),
      ((e, t, r = 50) => {
        const { r: n, g: i, b: a, a: o } = Ci.parse(e),
          { r: s, g: l, b: c, a: h } = Ci.parse(t),
          d = r / 100,
          u = 2 * d - 1,
          p = o - h,
          g = ((u * p === -1 ? u : (u + p) / (1 + u * p)) + 1) / 2,
          f = 1 - g;
        return vi(n * g + s * f, i * g + l * f, a * g + c * f, o * d + h * (1 - d));
      })(r, e, t)
    );
  },
  {
    entries: Bi,
    setPrototypeOf: Mi,
    isFrozen: Ni,
    getPrototypeOf: Li,
    getOwnPropertyDescriptor: Oi,
  } = Object;
let { freeze: $i, seal: Ii, create: Ri } = Object,
  { apply: zi, construct: Pi } = 'undefined' != typeof Reflect && Reflect;
($i ||
  ($i = function (e) {
    return e;
  }),
  Ii ||
    (Ii = function (e) {
      return e;
    }),
  zi ||
    (zi = function (e, t) {
      for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++)
        n[i - 2] = arguments[i];
      return e.apply(t, n);
    }),
  Pi ||
    (Pi = function (e) {
      for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
        r[n - 1] = arguments[n];
      return new e(...r);
    }));
const ji = ra(Array.prototype.forEach),
  qi = ra(Array.prototype.lastIndexOf),
  Wi = ra(Array.prototype.pop),
  Ui = ra(Array.prototype.push),
  Hi = ra(Array.prototype.splice),
  Gi = ra(String.prototype.toLowerCase),
  Vi = ra(String.prototype.toString),
  Zi = ra(String.prototype.match),
  Ki = ra(String.prototype.replace),
  Yi = ra(String.prototype.indexOf),
  Xi = ra(String.prototype.trim),
  Qi = ra(Object.prototype.hasOwnProperty),
  Ji = ra(RegExp.prototype.test),
  ea =
    ((ta = TypeError),
    function () {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
      return Pi(ta, t);
    });
var ta;
function ra(e) {
  return function (t) {
    t instanceof RegExp && (t.lastIndex = 0);
    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      n[i - 1] = arguments[i];
    return zi(e, t, n);
  };
}
function na(e, t) {
  let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Gi;
  Mi && Mi(e, null);
  let n = t.length;
  for (; n--; ) {
    let i = t[n];
    if ('string' == typeof i) {
      const e = r(i);
      e !== i && (Ni(t) || (t[n] = e), (i = e));
    }
    e[i] = !0;
  }
  return e;
}
function ia(e) {
  for (let t = 0; t < e.length; t++) {
    Qi(e, t) || (e[t] = null);
  }
  return e;
}
function aa(e) {
  const t = Ri(null);
  for (const [r, n] of Bi(e)) {
    Qi(e, r) &&
      (Array.isArray(n)
        ? (t[r] = ia(n))
        : n && 'object' == typeof n && n.constructor === Object
          ? (t[r] = aa(n))
          : (t[r] = n));
  }
  return t;
}
function oa(e, t) {
  for (; null !== e; ) {
    const r = Oi(e, t);
    if (r) {
      if (r.get) return ra(r.get);
      if ('function' == typeof r.value) return ra(r.value);
    }
    e = Li(e);
  }
  return function () {
    return null;
  };
}
const sa = $i([
    'a',
    'abbr',
    'acronym',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'bdi',
    'bdo',
    'big',
    'blink',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'center',
    'cite',
    'code',
    'col',
    'colgroup',
    'content',
    'data',
    'datalist',
    'dd',
    'decorator',
    'del',
    'details',
    'dfn',
    'dialog',
    'dir',
    'div',
    'dl',
    'dt',
    'element',
    'em',
    'fieldset',
    'figcaption',
    'figure',
    'font',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meter',
    'nav',
    'nobr',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'search',
    'section',
    'select',
    'shadow',
    'slot',
    'small',
    'source',
    'spacer',
    'span',
    'strike',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'tr',
    'track',
    'tt',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
  ]),
  la = $i([
    'svg',
    'a',
    'altglyph',
    'altglyphdef',
    'altglyphitem',
    'animatecolor',
    'animatemotion',
    'animatetransform',
    'circle',
    'clippath',
    'defs',
    'desc',
    'ellipse',
    'enterkeyhint',
    'exportparts',
    'filter',
    'font',
    'g',
    'glyph',
    'glyphref',
    'hkern',
    'image',
    'inputmode',
    'line',
    'lineargradient',
    'marker',
    'mask',
    'metadata',
    'mpath',
    'part',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialgradient',
    'rect',
    'stop',
    'style',
    'switch',
    'symbol',
    'text',
    'textpath',
    'title',
    'tref',
    'tspan',
    'view',
    'vkern',
  ]),
  ca = $i([
    'feBlend',
    'feColorMatrix',
    'feComponentTransfer',
    'feComposite',
    'feConvolveMatrix',
    'feDiffuseLighting',
    'feDisplacementMap',
    'feDistantLight',
    'feDropShadow',
    'feFlood',
    'feFuncA',
    'feFuncB',
    'feFuncG',
    'feFuncR',
    'feGaussianBlur',
    'feImage',
    'feMerge',
    'feMergeNode',
    'feMorphology',
    'feOffset',
    'fePointLight',
    'feSpecularLighting',
    'feSpotLight',
    'feTile',
    'feTurbulence',
  ]),
  ha = $i([
    'animate',
    'color-profile',
    'cursor',
    'discard',
    'font-face',
    'font-face-format',
    'font-face-name',
    'font-face-src',
    'font-face-uri',
    'foreignobject',
    'hatch',
    'hatchpath',
    'mesh',
    'meshgradient',
    'meshpatch',
    'meshrow',
    'missing-glyph',
    'script',
    'set',
    'solidcolor',
    'unknown',
    'use',
  ]),
  da = $i([
    'math',
    'menclose',
    'merror',
    'mfenced',
    'mfrac',
    'mglyph',
    'mi',
    'mlabeledtr',
    'mmultiscripts',
    'mn',
    'mo',
    'mover',
    'mpadded',
    'mphantom',
    'mroot',
    'mrow',
    'ms',
    'mspace',
    'msqrt',
    'mstyle',
    'msub',
    'msup',
    'msubsup',
    'mtable',
    'mtd',
    'mtext',
    'mtr',
    'munder',
    'munderover',
    'mprescripts',
  ]),
  ua = $i([
    'maction',
    'maligngroup',
    'malignmark',
    'mlongdiv',
    'mscarries',
    'mscarry',
    'msgroup',
    'mstack',
    'msline',
    'msrow',
    'semantics',
    'annotation',
    'annotation-xml',
    'mprescripts',
    'none',
  ]),
  pa = $i(['#text']),
  ga = $i([
    'accept',
    'action',
    'align',
    'alt',
    'autocapitalize',
    'autocomplete',
    'autopictureinpicture',
    'autoplay',
    'background',
    'bgcolor',
    'border',
    'capture',
    'cellpadding',
    'cellspacing',
    'checked',
    'cite',
    'class',
    'clear',
    'color',
    'cols',
    'colspan',
    'controls',
    'controlslist',
    'coords',
    'crossorigin',
    'datetime',
    'decoding',
    'default',
    'dir',
    'disabled',
    'disablepictureinpicture',
    'disableremoteplayback',
    'download',
    'draggable',
    'enctype',
    'enterkeyhint',
    'exportparts',
    'face',
    'for',
    'headers',
    'height',
    'hidden',
    'high',
    'href',
    'hreflang',
    'id',
    'inert',
    'inputmode',
    'integrity',
    'ismap',
    'kind',
    'label',
    'lang',
    'list',
    'loading',
    'loop',
    'low',
    'max',
    'maxlength',
    'media',
    'method',
    'min',
    'minlength',
    'multiple',
    'muted',
    'name',
    'nonce',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'optimum',
    'part',
    'pattern',
    'placeholder',
    'playsinline',
    'popover',
    'popovertarget',
    'popovertargetaction',
    'poster',
    'preload',
    'pubdate',
    'radiogroup',
    'readonly',
    'rel',
    'required',
    'rev',
    'reversed',
    'role',
    'rows',
    'rowspan',
    'spellcheck',
    'scope',
    'selected',
    'shape',
    'size',
    'sizes',
    'slot',
    'span',
    'srclang',
    'start',
    'src',
    'srcset',
    'step',
    'style',
    'summary',
    'tabindex',
    'title',
    'translate',
    'type',
    'usemap',
    'valign',
    'value',
    'width',
    'wrap',
    'xmlns',
    'slot',
  ]),
  fa = $i([
    'accent-height',
    'accumulate',
    'additive',
    'alignment-baseline',
    'amplitude',
    'ascent',
    'attributename',
    'attributetype',
    'azimuth',
    'basefrequency',
    'baseline-shift',
    'begin',
    'bias',
    'by',
    'class',
    'clip',
    'clippathunits',
    'clip-path',
    'clip-rule',
    'color',
    'color-interpolation',
    'color-interpolation-filters',
    'color-profile',
    'color-rendering',
    'cx',
    'cy',
    'd',
    'dx',
    'dy',
    'diffuseconstant',
    'direction',
    'display',
    'divisor',
    'dur',
    'edgemode',
    'elevation',
    'end',
    'exponent',
    'fill',
    'fill-opacity',
    'fill-rule',
    'filter',
    'filterunits',
    'flood-color',
    'flood-opacity',
    'font-family',
    'font-size',
    'font-size-adjust',
    'font-stretch',
    'font-style',
    'font-variant',
    'font-weight',
    'fx',
    'fy',
    'g1',
    'g2',
    'glyph-name',
    'glyphref',
    'gradientunits',
    'gradienttransform',
    'height',
    'href',
    'id',
    'image-rendering',
    'in',
    'in2',
    'intercept',
    'k',
    'k1',
    'k2',
    'k3',
    'k4',
    'kerning',
    'keypoints',
    'keysplines',
    'keytimes',
    'lang',
    'lengthadjust',
    'letter-spacing',
    'kernelmatrix',
    'kernelunitlength',
    'lighting-color',
    'local',
    'marker-end',
    'marker-mid',
    'marker-start',
    'markerheight',
    'markerunits',
    'markerwidth',
    'maskcontentunits',
    'maskunits',
    'max',
    'mask',
    'mask-type',
    'media',
    'method',
    'mode',
    'min',
    'name',
    'numoctaves',
    'offset',
    'operator',
    'opacity',
    'order',
    'orient',
    'orientation',
    'origin',
    'overflow',
    'paint-order',
    'path',
    'pathlength',
    'patterncontentunits',
    'patterntransform',
    'patternunits',
    'points',
    'preservealpha',
    'preserveaspectratio',
    'primitiveunits',
    'r',
    'rx',
    'ry',
    'radius',
    'refx',
    'refy',
    'repeatcount',
    'repeatdur',
    'restart',
    'result',
    'rotate',
    'scale',
    'seed',
    'shape-rendering',
    'slope',
    'specularconstant',
    'specularexponent',
    'spreadmethod',
    'startoffset',
    'stddeviation',
    'stitchtiles',
    'stop-color',
    'stop-opacity',
    'stroke-dasharray',
    'stroke-dashoffset',
    'stroke-linecap',
    'stroke-linejoin',
    'stroke-miterlimit',
    'stroke-opacity',
    'stroke',
    'stroke-width',
    'style',
    'surfacescale',
    'systemlanguage',
    'tabindex',
    'tablevalues',
    'targetx',
    'targety',
    'transform',
    'transform-origin',
    'text-anchor',
    'text-decoration',
    'text-rendering',
    'textlength',
    'type',
    'u1',
    'u2',
    'unicode',
    'values',
    'viewbox',
    'visibility',
    'version',
    'vert-adv-y',
    'vert-origin-x',
    'vert-origin-y',
    'width',
    'word-spacing',
    'wrap',
    'writing-mode',
    'xchannelselector',
    'ychannelselector',
    'x',
    'x1',
    'x2',
    'xmlns',
    'y',
    'y1',
    'y2',
    'z',
    'zoomandpan',
  ]),
  ma = $i([
    'accent',
    'accentunder',
    'align',
    'bevelled',
    'close',
    'columnsalign',
    'columnlines',
    'columnspan',
    'denomalign',
    'depth',
    'dir',
    'display',
    'displaystyle',
    'encoding',
    'fence',
    'frame',
    'height',
    'href',
    'id',
    'largeop',
    'length',
    'linethickness',
    'lspace',
    'lquote',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'numalign',
    'open',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'rquote',
    'scriptlevel',
    'scriptminsize',
    'scriptsizemultiplier',
    'selection',
    'separator',
    'separators',
    'stretchy',
    'subscriptshift',
    'supscriptshift',
    'symmetric',
    'voffset',
    'width',
    'xmlns',
  ]),
  ba = $i(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']),
  ya = Ii(/\{\{[\w\W]*|[\w\W]*\}\}/gm),
  xa = Ii(/<%[\w\W]*|[\w\W]*%>/gm),
  ka = Ii(/\$\{[\w\W]*/gm),
  Ca = Ii(/^data-[\-\w.\u00B7-\uFFFF]+$/),
  wa = Ii(/^aria-[\-\w]+$/),
  va = Ii(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  ),
  _a = Ii(/^(?:\w+script|data):/i),
  Sa = Ii(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),
  Ea = Ii(/^html$/i),
  Da = Ii(/^[a-z][.\w]*(-[.\w]+)+$/i);
var Aa = Object.freeze({
  __proto__: null,
  ARIA_ATTR: wa,
  ATTR_WHITESPACE: Sa,
  CUSTOM_ELEMENT: Da,
  DATA_ATTR: Ca,
  DOCTYPE_NAME: Ea,
  ERB_EXPR: xa,
  IS_ALLOWED_URI: va,
  IS_SCRIPT_OR_DATA: _a,
  MUSTACHE_EXPR: ya,
  TMPLIT_EXPR: ka,
});
const Ta = 1,
  Fa = 3,
  Ba = 7,
  Ma = 8,
  Na = 9;
var La,
  Oa = (function e() {
    let t =
      arguments.length > 0 && void 0 !== arguments[0]
        ? arguments[0]
        : 'undefined' == typeof window
          ? null
          : window;
    const r = (t) => e(t);
    if (
      ((r.version = '3.3.1'),
      (r.removed = []),
      !t || !t.document || t.document.nodeType !== Na || !t.Element)
    )
      return ((r.isSupported = !1), r);
    let { document: n } = t;
    const i = n,
      a = i.currentScript,
      {
        DocumentFragment: o,
        HTMLTemplateElement: s,
        Node: l,
        Element: c,
        NodeFilter: h,
        NamedNodeMap: d = t.NamedNodeMap || t.MozNamedAttrMap,
        HTMLFormElement: u,
        DOMParser: p,
        trustedTypes: g,
      } = t,
      f = c.prototype,
      m = oa(f, 'cloneNode'),
      b = oa(f, 'remove'),
      y = oa(f, 'nextSibling'),
      x = oa(f, 'childNodes'),
      k = oa(f, 'parentNode');
    if ('function' == typeof s) {
      const e = n.createElement('template');
      e.content && e.content.ownerDocument && (n = e.content.ownerDocument);
    }
    let C,
      w = '';
    const {
        implementation: v,
        createNodeIterator: _,
        createDocumentFragment: S,
        getElementsByTagName: E,
      } = n,
      { importNode: D } = i;
    let A = {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: [],
    };
    r.isSupported =
      'function' == typeof Bi && 'function' == typeof k && v && void 0 !== v.createHTMLDocument;
    const {
      MUSTACHE_EXPR: T,
      ERB_EXPR: F,
      TMPLIT_EXPR: B,
      DATA_ATTR: M,
      ARIA_ATTR: N,
      IS_SCRIPT_OR_DATA: L,
      ATTR_WHITESPACE: O,
      CUSTOM_ELEMENT: $,
    } = Aa;
    let { IS_ALLOWED_URI: I } = Aa,
      R = null;
    const z = na({}, [...sa, ...la, ...ca, ...da, ...pa]);
    let P = null;
    const j = na({}, [...ga, ...fa, ...ma, ...ba]);
    let q = Object.seal(
        Ri(null, {
          tagNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          attributeNameCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
          allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1,
          },
        })
      ),
      W = null,
      U = null;
    const H = Object.seal(
      Ri(null, {
        tagCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
        attributeCheck: { writable: !0, configurable: !1, enumerable: !0, value: null },
      })
    );
    let G = !0,
      V = !0,
      Z = !1,
      K = !0,
      Y = !1,
      X = !0,
      Q = !1,
      J = !1,
      ee = !1,
      te = !1,
      re = !1,
      ne = !1,
      ie = !0,
      ae = !1,
      oe = !0,
      se = !1,
      le = {},
      ce = null;
    const he = na({}, [
      'annotation-xml',
      'audio',
      'colgroup',
      'desc',
      'foreignobject',
      'head',
      'iframe',
      'math',
      'mi',
      'mn',
      'mo',
      'ms',
      'mtext',
      'noembed',
      'noframes',
      'noscript',
      'plaintext',
      'script',
      'style',
      'svg',
      'template',
      'thead',
      'title',
      'video',
      'xmp',
    ]);
    let de = null;
    const ue = na({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    let pe = null;
    const ge = na({}, [
        'alt',
        'class',
        'for',
        'id',
        'label',
        'name',
        'pattern',
        'placeholder',
        'role',
        'summary',
        'title',
        'value',
        'style',
        'xmlns',
      ]),
      fe = 'http://www.w3.org/1998/Math/MathML',
      me = 'http://www.w3.org/2000/svg',
      be = 'http://www.w3.org/1999/xhtml';
    let ye = be,
      xe = !1,
      ke = null;
    const Ce = na({}, [fe, me, be], Vi);
    let we = na({}, ['mi', 'mo', 'mn', 'ms', 'mtext']),
      ve = na({}, ['annotation-xml']);
    const _e = na({}, ['title', 'style', 'font', 'a', 'script']);
    let Se = null;
    const Ee = ['application/xhtml+xml', 'text/html'];
    let De = null,
      Ae = null;
    const Te = n.createElement('form'),
      Fe = function (e) {
        return e instanceof RegExp || e instanceof Function;
      },
      Be = function () {
        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        if (!Ae || Ae !== e) {
          if (
            ((e && 'object' == typeof e) || (e = {}),
            (e = aa(e)),
            (Se = -1 === Ee.indexOf(e.PARSER_MEDIA_TYPE) ? 'text/html' : e.PARSER_MEDIA_TYPE),
            (De = 'application/xhtml+xml' === Se ? Vi : Gi),
            (R = Qi(e, 'ALLOWED_TAGS') ? na({}, e.ALLOWED_TAGS, De) : z),
            (P = Qi(e, 'ALLOWED_ATTR') ? na({}, e.ALLOWED_ATTR, De) : j),
            (ke = Qi(e, 'ALLOWED_NAMESPACES') ? na({}, e.ALLOWED_NAMESPACES, Vi) : Ce),
            (pe = Qi(e, 'ADD_URI_SAFE_ATTR') ? na(aa(ge), e.ADD_URI_SAFE_ATTR, De) : ge),
            (de = Qi(e, 'ADD_DATA_URI_TAGS') ? na(aa(ue), e.ADD_DATA_URI_TAGS, De) : ue),
            (ce = Qi(e, 'FORBID_CONTENTS') ? na({}, e.FORBID_CONTENTS, De) : he),
            (W = Qi(e, 'FORBID_TAGS') ? na({}, e.FORBID_TAGS, De) : aa({})),
            (U = Qi(e, 'FORBID_ATTR') ? na({}, e.FORBID_ATTR, De) : aa({})),
            (le = !!Qi(e, 'USE_PROFILES') && e.USE_PROFILES),
            (G = !1 !== e.ALLOW_ARIA_ATTR),
            (V = !1 !== e.ALLOW_DATA_ATTR),
            (Z = e.ALLOW_UNKNOWN_PROTOCOLS || !1),
            (K = !1 !== e.ALLOW_SELF_CLOSE_IN_ATTR),
            (Y = e.SAFE_FOR_TEMPLATES || !1),
            (X = !1 !== e.SAFE_FOR_XML),
            (Q = e.WHOLE_DOCUMENT || !1),
            (te = e.RETURN_DOM || !1),
            (re = e.RETURN_DOM_FRAGMENT || !1),
            (ne = e.RETURN_TRUSTED_TYPE || !1),
            (ee = e.FORCE_BODY || !1),
            (ie = !1 !== e.SANITIZE_DOM),
            (ae = e.SANITIZE_NAMED_PROPS || !1),
            (oe = !1 !== e.KEEP_CONTENT),
            (se = e.IN_PLACE || !1),
            (I = e.ALLOWED_URI_REGEXP || va),
            (ye = e.NAMESPACE || be),
            (we = e.MATHML_TEXT_INTEGRATION_POINTS || we),
            (ve = e.HTML_INTEGRATION_POINTS || ve),
            (q = e.CUSTOM_ELEMENT_HANDLING || {}),
            e.CUSTOM_ELEMENT_HANDLING &&
              Fe(e.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
              (q.tagNameCheck = e.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
            e.CUSTOM_ELEMENT_HANDLING &&
              Fe(e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
              (q.attributeNameCheck = e.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
            e.CUSTOM_ELEMENT_HANDLING &&
              'boolean' == typeof e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&
              (q.allowCustomizedBuiltInElements =
                e.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
            Y && (V = !1),
            re && (te = !0),
            le &&
              ((R = na({}, pa)),
              (P = []),
              !0 === le.html && (na(R, sa), na(P, ga)),
              !0 === le.svg && (na(R, la), na(P, fa), na(P, ba)),
              !0 === le.svgFilters && (na(R, ca), na(P, fa), na(P, ba)),
              !0 === le.mathMl && (na(R, da), na(P, ma), na(P, ba))),
            e.ADD_TAGS &&
              ('function' == typeof e.ADD_TAGS
                ? (H.tagCheck = e.ADD_TAGS)
                : (R === z && (R = aa(R)), na(R, e.ADD_TAGS, De))),
            e.ADD_ATTR &&
              ('function' == typeof e.ADD_ATTR
                ? (H.attributeCheck = e.ADD_ATTR)
                : (P === j && (P = aa(P)), na(P, e.ADD_ATTR, De))),
            e.ADD_URI_SAFE_ATTR && na(pe, e.ADD_URI_SAFE_ATTR, De),
            e.FORBID_CONTENTS && (ce === he && (ce = aa(ce)), na(ce, e.FORBID_CONTENTS, De)),
            e.ADD_FORBID_CONTENTS &&
              (ce === he && (ce = aa(ce)), na(ce, e.ADD_FORBID_CONTENTS, De)),
            oe && (R['#text'] = !0),
            Q && na(R, ['html', 'head', 'body']),
            R.table && (na(R, ['tbody']), delete W.tbody),
            e.TRUSTED_TYPES_POLICY)
          ) {
            if ('function' != typeof e.TRUSTED_TYPES_POLICY.createHTML)
              throw ea(
                'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.'
              );
            if ('function' != typeof e.TRUSTED_TYPES_POLICY.createScriptURL)
              throw ea(
                'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.'
              );
            ((C = e.TRUSTED_TYPES_POLICY), (w = C.createHTML('')));
          } else
            (void 0 === C &&
              (C = (function (e, t) {
                if ('object' != typeof e || 'function' != typeof e.createPolicy) return null;
                let r = null;
                const n = 'data-tt-policy-suffix';
                t && t.hasAttribute(n) && (r = t.getAttribute(n));
                const i = 'dompurify' + (r ? '#' + r : '');
                try {
                  return e.createPolicy(i, { createHTML: (e) => e, createScriptURL: (e) => e });
                } catch (a) {
                  return null;
                }
              })(g, a)),
              null !== C && 'string' == typeof w && (w = C.createHTML('')));
          ($i && $i(e), (Ae = e));
        }
      },
      Me = na({}, [...la, ...ca, ...ha]),
      Ne = na({}, [...da, ...ua]),
      Le = function (e) {
        Ui(r.removed, { element: e });
        try {
          k(e).removeChild(e);
        } catch (t) {
          b(e);
        }
      },
      Oe = function (e, t) {
        try {
          Ui(r.removed, { attribute: t.getAttributeNode(e), from: t });
        } catch (n) {
          Ui(r.removed, { attribute: null, from: t });
        }
        if ((t.removeAttribute(e), 'is' === e))
          if (te || re)
            try {
              Le(t);
            } catch (n) {}
          else
            try {
              t.setAttribute(e, '');
            } catch (n) {}
      },
      $e = function (e) {
        let t = null,
          r = null;
        if (ee) e = '<remove></remove>' + e;
        else {
          const t = Zi(e, /^[\r\n\t ]+/);
          r = t && t[0];
        }
        'application/xhtml+xml' === Se &&
          ye === be &&
          (e =
            '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
            e +
            '</body></html>');
        const i = C ? C.createHTML(e) : e;
        if (ye === be)
          try {
            t = new p().parseFromString(i, Se);
          } catch (o) {}
        if (!t || !t.documentElement) {
          t = v.createDocument(ye, 'template', null);
          try {
            t.documentElement.innerHTML = xe ? w : i;
          } catch (o) {}
        }
        const a = t.body || t.documentElement;
        return (
          e && r && a.insertBefore(n.createTextNode(r), a.childNodes[0] || null),
          ye === be ? E.call(t, Q ? 'html' : 'body')[0] : Q ? t.documentElement : a
        );
      },
      Ie = function (e) {
        return _.call(
          e.ownerDocument || e,
          e,
          h.SHOW_ELEMENT |
            h.SHOW_COMMENT |
            h.SHOW_TEXT |
            h.SHOW_PROCESSING_INSTRUCTION |
            h.SHOW_CDATA_SECTION,
          null
        );
      },
      Re = function (e) {
        return (
          e instanceof u &&
          ('string' != typeof e.nodeName ||
            'string' != typeof e.textContent ||
            'function' != typeof e.removeChild ||
            !(e.attributes instanceof d) ||
            'function' != typeof e.removeAttribute ||
            'function' != typeof e.setAttribute ||
            'string' != typeof e.namespaceURI ||
            'function' != typeof e.insertBefore ||
            'function' != typeof e.hasChildNodes)
        );
      },
      ze = function (e) {
        return 'function' == typeof l && e instanceof l;
      };
    function Pe(e, t, n) {
      ji(e, (e) => {
        e.call(r, t, n, Ae);
      });
    }
    const je = function (e) {
        let t = null;
        if ((Pe(A.beforeSanitizeElements, e, null), Re(e))) return (Le(e), !0);
        const n = De(e.nodeName);
        if (
          (Pe(A.uponSanitizeElement, e, { tagName: n, allowedTags: R }),
          X &&
            e.hasChildNodes() &&
            !ze(e.firstElementChild) &&
            Ji(/<[/\w!]/g, e.innerHTML) &&
            Ji(/<[/\w!]/g, e.textContent))
        )
          return (Le(e), !0);
        if (e.nodeType === Ba) return (Le(e), !0);
        if (X && e.nodeType === Ma && Ji(/<[/\w]/g, e.data)) return (Le(e), !0);
        if (!(H.tagCheck instanceof Function && H.tagCheck(n)) && (!R[n] || W[n])) {
          if (!W[n] && We(n)) {
            if (q.tagNameCheck instanceof RegExp && Ji(q.tagNameCheck, n)) return !1;
            if (q.tagNameCheck instanceof Function && q.tagNameCheck(n)) return !1;
          }
          if (oe && !ce[n]) {
            const t = k(e) || e.parentNode,
              r = x(e) || e.childNodes;
            if (r && t) {
              for (let n = r.length - 1; n >= 0; --n) {
                const i = m(r[n], !0);
                ((i.__removalCount = (e.__removalCount || 0) + 1), t.insertBefore(i, y(e)));
              }
            }
          }
          return (Le(e), !0);
        }
        return e instanceof c &&
          !(function (e) {
            let t = k(e);
            (t && t.tagName) || (t = { namespaceURI: ye, tagName: 'template' });
            const r = Gi(e.tagName),
              n = Gi(t.tagName);
            return (
              !!ke[e.namespaceURI] &&
              (e.namespaceURI === me
                ? t.namespaceURI === be
                  ? 'svg' === r
                  : t.namespaceURI === fe
                    ? 'svg' === r && ('annotation-xml' === n || we[n])
                    : Boolean(Me[r])
                : e.namespaceURI === fe
                  ? t.namespaceURI === be
                    ? 'math' === r
                    : t.namespaceURI === me
                      ? 'math' === r && ve[n]
                      : Boolean(Ne[r])
                  : e.namespaceURI === be
                    ? !(t.namespaceURI === me && !ve[n]) &&
                      !(t.namespaceURI === fe && !we[n]) &&
                      !Ne[r] &&
                      (_e[r] || !Me[r])
                    : !('application/xhtml+xml' !== Se || !ke[e.namespaceURI]))
            );
          })(e)
          ? (Le(e), !0)
          : ('noscript' !== n && 'noembed' !== n && 'noframes' !== n) ||
              !Ji(/<\/no(script|embed|frames)/i, e.innerHTML)
            ? (Y &&
                e.nodeType === Fa &&
                ((t = e.textContent),
                ji([T, F, B], (e) => {
                  t = Ki(t, e, ' ');
                }),
                e.textContent !== t &&
                  (Ui(r.removed, { element: e.cloneNode() }), (e.textContent = t))),
              Pe(A.afterSanitizeElements, e, null),
              !1)
            : (Le(e), !0);
      },
      qe = function (e, t, r) {
        if (ie && ('id' === t || 'name' === t) && (r in n || r in Te)) return !1;
        if (V && !U[t] && Ji(M, t));
        else if (G && Ji(N, t));
        else if (H.attributeCheck instanceof Function && H.attributeCheck(t, e));
        else if (!P[t] || U[t]) {
          if (
            !(
              (We(e) &&
                ((q.tagNameCheck instanceof RegExp && Ji(q.tagNameCheck, e)) ||
                  (q.tagNameCheck instanceof Function && q.tagNameCheck(e))) &&
                ((q.attributeNameCheck instanceof RegExp && Ji(q.attributeNameCheck, t)) ||
                  (q.attributeNameCheck instanceof Function && q.attributeNameCheck(t, e)))) ||
              ('is' === t &&
                q.allowCustomizedBuiltInElements &&
                ((q.tagNameCheck instanceof RegExp && Ji(q.tagNameCheck, r)) ||
                  (q.tagNameCheck instanceof Function && q.tagNameCheck(r))))
            )
          )
            return !1;
        } else if (pe[t]);
        else if (Ji(I, Ki(r, O, '')));
        else if (
          ('src' !== t && 'xlink:href' !== t && 'href' !== t) ||
          'script' === e ||
          0 !== Yi(r, 'data:') ||
          !de[e]
        ) {
          if (Z && !Ji(L, Ki(r, O, '')));
          else if (r) return !1;
        } else;
        return !0;
      },
      We = function (e) {
        return 'annotation-xml' !== e && Zi(e, $);
      },
      Ue = function (e) {
        Pe(A.beforeSanitizeAttributes, e, null);
        const { attributes: t } = e;
        if (!t || Re(e)) return;
        const n = {
          attrName: '',
          attrValue: '',
          keepAttr: !0,
          allowedAttributes: P,
          forceKeepAttr: void 0,
        };
        let i = t.length;
        for (; i--; ) {
          const o = t[i],
            { name: s, namespaceURI: l, value: c } = o,
            h = De(s),
            d = c;
          let u = 'value' === s ? d : Xi(d);
          if (
            ((n.attrName = h),
            (n.attrValue = u),
            (n.keepAttr = !0),
            (n.forceKeepAttr = void 0),
            Pe(A.uponSanitizeAttribute, e, n),
            (u = n.attrValue),
            !ae || ('id' !== h && 'name' !== h) || (Oe(s, e), (u = 'user-content-' + u)),
            X && Ji(/((--!?|])>)|<\/(style|title|textarea)/i, u))
          ) {
            Oe(s, e);
            continue;
          }
          if ('attributename' === h && Zi(u, 'href')) {
            Oe(s, e);
            continue;
          }
          if (n.forceKeepAttr) continue;
          if (!n.keepAttr) {
            Oe(s, e);
            continue;
          }
          if (!K && Ji(/\/>/i, u)) {
            Oe(s, e);
            continue;
          }
          Y &&
            ji([T, F, B], (e) => {
              u = Ki(u, e, ' ');
            });
          const p = De(e.nodeName);
          if (qe(p, h, u)) {
            if (C && 'object' == typeof g && 'function' == typeof g.getAttributeType)
              if (l);
              else
                switch (g.getAttributeType(p, h)) {
                  case 'TrustedHTML':
                    u = C.createHTML(u);
                    break;
                  case 'TrustedScriptURL':
                    u = C.createScriptURL(u);
                }
            if (u !== d)
              try {
                (l ? e.setAttributeNS(l, s, u) : e.setAttribute(s, u),
                  Re(e) ? Le(e) : Wi(r.removed));
              } catch (a) {
                Oe(s, e);
              }
          } else Oe(s, e);
        }
        Pe(A.afterSanitizeAttributes, e, null);
      },
      He = function e(t) {
        let r = null;
        const n = Ie(t);
        for (Pe(A.beforeSanitizeShadowDOM, t, null); (r = n.nextNode()); )
          (Pe(A.uponSanitizeShadowNode, r, null),
            je(r),
            Ue(r),
            r.content instanceof o && e(r.content));
        Pe(A.afterSanitizeShadowDOM, t, null);
      };
    return (
      (r.sanitize = function (e) {
        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          n = null,
          a = null,
          s = null,
          c = null;
        if (((xe = !e), xe && (e = '\x3c!--\x3e'), 'string' != typeof e && !ze(e))) {
          if ('function' != typeof e.toString) throw ea('toString is not a function');
          if ('string' != typeof (e = e.toString())) throw ea('dirty is not a string, aborting');
        }
        if (!r.isSupported) return e;
        if ((J || Be(t), (r.removed = []), 'string' == typeof e && (se = !1), se)) {
          if (e.nodeName) {
            const t = De(e.nodeName);
            if (!R[t] || W[t]) throw ea('root node is forbidden and cannot be sanitized in-place');
          }
        } else if (e instanceof l)
          ((n = $e('\x3c!----\x3e')),
            (a = n.ownerDocument.importNode(e, !0)),
            (a.nodeType === Ta && 'BODY' === a.nodeName) || 'HTML' === a.nodeName
              ? (n = a)
              : n.appendChild(a));
        else {
          if (!te && !Y && !Q && -1 === e.indexOf('<')) return C && ne ? C.createHTML(e) : e;
          if (((n = $e(e)), !n)) return te ? null : ne ? w : '';
        }
        n && ee && Le(n.firstChild);
        const h = Ie(se ? e : n);
        for (; (s = h.nextNode()); ) (je(s), Ue(s), s.content instanceof o && He(s.content));
        if (se) return e;
        if (te) {
          if (re) for (c = S.call(n.ownerDocument); n.firstChild; ) c.appendChild(n.firstChild);
          else c = n;
          return ((P.shadowroot || P.shadowrootmode) && (c = D.call(i, c, !0)), c);
        }
        let d = Q ? n.outerHTML : n.innerHTML;
        return (
          Q &&
            R['!doctype'] &&
            n.ownerDocument &&
            n.ownerDocument.doctype &&
            n.ownerDocument.doctype.name &&
            Ji(Ea, n.ownerDocument.doctype.name) &&
            (d = '<!DOCTYPE ' + n.ownerDocument.doctype.name + '>\n' + d),
          Y &&
            ji([T, F, B], (e) => {
              d = Ki(d, e, ' ');
            }),
          C && ne ? C.createHTML(d) : d
        );
      }),
      (r.setConfig = function () {
        (Be(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}), (J = !0));
      }),
      (r.clearConfig = function () {
        ((Ae = null), (J = !1));
      }),
      (r.isValidAttribute = function (e, t, r) {
        Ae || Be({});
        const n = De(e),
          i = De(t);
        return qe(n, i, r);
      }),
      (r.addHook = function (e, t) {
        'function' == typeof t && Ui(A[e], t);
      }),
      (r.removeHook = function (e, t) {
        if (void 0 !== t) {
          const r = qi(A[e], t);
          return -1 === r ? void 0 : Hi(A[e], r, 1)[0];
        }
        return Wi(A[e]);
      }),
      (r.removeHooks = function (e) {
        A[e] = [];
      }),
      (r.removeAllHooks = function () {
        A = {
          afterSanitizeAttributes: [],
          afterSanitizeElements: [],
          afterSanitizeShadowDOM: [],
          beforeSanitizeAttributes: [],
          beforeSanitizeElements: [],
          beforeSanitizeShadowDOM: [],
          uponSanitizeAttribute: [],
          uponSanitizeElement: [],
          uponSanitizeShadowNode: [],
        };
      }),
      r
    );
  })(),
  $a = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s,
  Ia = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi,
  Ra = /\s*%%.*\n/gm,
  za =
    ((e = class extends Error {
      constructor(e) {
        (super(e), (this.name = 'UnknownDiagramError'));
      }
    }),
    ii(e, 'UnknownDiagramError'),
    e),
  Pa = {},
  ja = ii(function (e, t) {
    e = e.replace($a, '').replace(Ia, '').replace(Ra, '\n');
    for (const [r, { detector: n }] of Object.entries(Pa)) {
      if (n(e, t)) return r;
    }
    throw new za(`No diagram type detected matching given configuration for text: ${e}`);
  }, 'detectType'),
  qa = ii((...e) => {
    for (const { id: t, detector: r, loader: n } of e) Wa(t, r, n);
  }, 'registerLazyLoadedDiagrams'),
  Wa = ii((e, t, r) => {
    (Pa[e] && si.warn(`Detector with key ${e} already exists. Overwriting.`),
      (Pa[e] = { detector: t, loader: r }),
      si.debug(`Detector with key ${e} added${r ? ' with loader' : ''}`));
  }, 'addDetector'),
  Ua = ii((e) => Pa[e].loader, 'getDiagramLoader'),
  Ha = ii((e, t, { depth: r = 2, clobber: n = !1 } = {}) => {
    const i = { depth: r, clobber: n };
    return Array.isArray(t) && !Array.isArray(e)
      ? (t.forEach((t) => Ha(e, t, i)), e)
      : Array.isArray(t) && Array.isArray(e)
        ? (t.forEach((t) => {
            e.includes(t) || e.push(t);
          }),
          e)
        : void 0 === e || r <= 0
          ? null != e && 'object' == typeof e && 'object' == typeof t
            ? Object.assign(e, t)
            : t
          : (void 0 !== t &&
              'object' == typeof e &&
              'object' == typeof t &&
              Object.keys(t).forEach((i) => {
                'object' != typeof t[i] || (void 0 !== e[i] && 'object' != typeof e[i])
                  ? (n || ('object' != typeof e[i] && 'object' != typeof t[i])) && (e[i] = t[i])
                  : (void 0 === e[i] && (e[i] = Array.isArray(t[i]) ? [] : {}),
                    (e[i] = Ha(e[i], t[i], { depth: r - 1, clobber: n })));
              }),
            e);
  }, 'assignWithDepth'),
  Ga = Ha,
  Va = '#ffffff',
  Za = '#f2f2f2',
  Ka = ii((e, t) => Ti(e, t ? { s: -40, l: 10 } : { s: -40, l: -10 }), 'mkBorder'),
  Ya =
    (ii(
      (t = class {
        constructor() {
          ((this.background = '#f4f4f4'),
            (this.primaryColor = '#fff4dd'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = '#333'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'));
        }
        updateColors() {
          var e, t, r, n, i, a, o, s, l, c, h, d, u, p, g, f, m, b, y, x, k;
          if (
            ((this.primaryTextColor = this.primaryTextColor || (this.darkMode ? '#eee' : '#333')),
            (this.secondaryColor = this.secondaryColor || Ti(this.primaryColor, { h: -120 })),
            (this.tertiaryColor = this.tertiaryColor || Ti(this.primaryColor, { h: 180, l: 5 })),
            (this.primaryBorderColor =
              this.primaryBorderColor || Ka(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor =
              this.secondaryBorderColor || Ka(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor =
              this.tertiaryBorderColor || Ka(this.tertiaryColor, this.darkMode)),
            (this.noteBorderColor = this.noteBorderColor || Ka(this.noteBkgColor, this.darkMode)),
            (this.noteBkgColor = this.noteBkgColor || '#fff5ad'),
            (this.noteTextColor = this.noteTextColor || '#333'),
            (this.secondaryTextColor = this.secondaryTextColor || Fi(this.secondaryColor)),
            (this.tertiaryTextColor = this.tertiaryTextColor || Fi(this.tertiaryColor)),
            (this.lineColor = this.lineColor || Fi(this.background)),
            (this.arrowheadColor = this.arrowheadColor || Fi(this.background)),
            (this.textColor = this.textColor || this.primaryTextColor),
            (this.border2 = this.border2 || this.tertiaryBorderColor),
            (this.nodeBkg = this.nodeBkg || this.primaryColor),
            (this.mainBkg = this.mainBkg || this.primaryColor),
            (this.nodeBorder = this.nodeBorder || this.primaryBorderColor),
            (this.clusterBkg = this.clusterBkg || this.tertiaryColor),
            (this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor),
            (this.defaultLinkColor = this.defaultLinkColor || this.lineColor),
            (this.titleColor = this.titleColor || this.tertiaryTextColor),
            (this.edgeLabelBackground =
              this.edgeLabelBackground ||
              (this.darkMode ? Ai(this.secondaryColor, 30) : this.secondaryColor)),
            (this.nodeTextColor = this.nodeTextColor || this.primaryTextColor),
            (this.actorBorder = this.actorBorder || this.primaryBorderColor),
            (this.actorBkg = this.actorBkg || this.mainBkg),
            (this.actorTextColor = this.actorTextColor || this.primaryTextColor),
            (this.actorLineColor = this.actorLineColor || this.actorBorder),
            (this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg),
            (this.signalColor = this.signalColor || this.textColor),
            (this.signalTextColor = this.signalTextColor || this.textColor),
            (this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder),
            (this.labelTextColor = this.labelTextColor || this.actorTextColor),
            (this.loopTextColor = this.loopTextColor || this.actorTextColor),
            (this.activationBorderColor =
              this.activationBorderColor || Ai(this.secondaryColor, 10)),
            (this.activationBkgColor = this.activationBkgColor || this.secondaryColor),
            (this.sequenceNumberColor = this.sequenceNumberColor || Fi(this.lineColor)),
            (this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor),
            (this.altSectionBkgColor = this.altSectionBkgColor || 'white'),
            (this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor),
            (this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor),
            (this.excludeBkgColor = this.excludeBkgColor || '#eeeeee'),
            (this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor),
            (this.taskBkgColor = this.taskBkgColor || this.primaryColor),
            (this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor),
            (this.activeTaskBkgColor = this.activeTaskBkgColor || Di(this.primaryColor, 23)),
            (this.gridColor = this.gridColor || 'lightgrey'),
            (this.doneTaskBkgColor = this.doneTaskBkgColor || 'lightgrey'),
            (this.doneTaskBorderColor = this.doneTaskBorderColor || 'grey'),
            (this.critBorderColor = this.critBorderColor || '#ff8888'),
            (this.critBkgColor = this.critBkgColor || 'red'),
            (this.todayLineColor = this.todayLineColor || 'red'),
            (this.vertLineColor = this.vertLineColor || 'navy'),
            (this.taskTextColor = this.taskTextColor || this.textColor),
            (this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor),
            (this.taskTextLightColor = this.taskTextLightColor || this.textColor),
            (this.taskTextColor = this.taskTextColor || this.primaryTextColor),
            (this.taskTextDarkColor = this.taskTextDarkColor || this.textColor),
            (this.taskTextClickableColor = this.taskTextClickableColor || '#003163'),
            (this.personBorder = this.personBorder || this.primaryBorderColor),
            (this.personBkg = this.personBkg || this.mainBkg),
            this.darkMode
              ? ((this.rowOdd = this.rowOdd || Ai(this.mainBkg, 5) || '#ffffff'),
                (this.rowEven = this.rowEven || Ai(this.mainBkg, 10)))
              : ((this.rowOdd = this.rowOdd || Di(this.mainBkg, 75) || '#ffffff'),
                (this.rowEven = this.rowEven || Di(this.mainBkg, 5))),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || this.tertiaryColor),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.specialStateColor = this.lineColor),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || Ti(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || Ti(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || Ti(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || Ti(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || Ti(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || Ti(this.primaryColor, { h: 210, l: 150 })),
            (this.cScale9 = this.cScale9 || Ti(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || Ti(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || Ti(this.primaryColor, { h: 330 })),
            this.darkMode)
          )
            for (let w = 0; w < this.THEME_COLOR_LIMIT; w++)
              this['cScale' + w] = Ai(this['cScale' + w], 75);
          else
            for (let w = 0; w < this.THEME_COLOR_LIMIT; w++)
              this['cScale' + w] = Ai(this['cScale' + w], 25);
          for (let w = 0; w < this.THEME_COLOR_LIMIT; w++)
            this['cScaleInv' + w] = this['cScaleInv' + w] || Fi(this['cScale' + w]);
          for (let w = 0; w < this.THEME_COLOR_LIMIT; w++)
            this.darkMode
              ? (this['cScalePeer' + w] = this['cScalePeer' + w] || Di(this['cScale' + w], 10))
              : (this['cScalePeer' + w] = this['cScalePeer' + w] || Ai(this['cScale' + w], 10));
          this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
          for (let w = 0; w < this.THEME_COLOR_LIMIT; w++)
            this['cScaleLabel' + w] = this['cScaleLabel' + w] || this.scaleLabelColor;
          const C = this.darkMode ? -4 : -1;
          for (let w = 0; w < 5; w++)
            ((this['surface' + w] =
              this['surface' + w] || Ti(this.mainBkg, { h: 180, s: -15, l: C * (5 + 3 * w) })),
              (this['surfacePeer' + w] =
                this['surfacePeer' + w] ||
                Ti(this.mainBkg, { h: 180, s: -15, l: C * (8 + 3 * w) })));
          ((this.classText = this.classText || this.textColor),
            (this.fillType0 = this.fillType0 || this.primaryColor),
            (this.fillType1 = this.fillType1 || this.secondaryColor),
            (this.fillType2 = this.fillType2 || Ti(this.primaryColor, { h: 64 })),
            (this.fillType3 = this.fillType3 || Ti(this.secondaryColor, { h: 64 })),
            (this.fillType4 = this.fillType4 || Ti(this.primaryColor, { h: -64 })),
            (this.fillType5 = this.fillType5 || Ti(this.secondaryColor, { h: -64 })),
            (this.fillType6 = this.fillType6 || Ti(this.primaryColor, { h: 128 })),
            (this.fillType7 = this.fillType7 || Ti(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || Ti(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || Ti(this.secondaryColor, { l: -10 })),
            (this.pie6 = this.pie6 || Ti(this.tertiaryColor, { l: -10 })),
            (this.pie7 = this.pie7 || Ti(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 = this.pie8 || Ti(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || Ti(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 = this.pie10 || Ti(this.primaryColor, { h: 60, l: -20 })),
            (this.pie11 = this.pie11 || Ti(this.primaryColor, { h: -60, l: -20 })),
            (this.pie12 = this.pie12 || Ti(this.primaryColor, { h: 120, l: -10 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.radar = {
              axisColor: (null == (e = this.radar) ? void 0 : e.axisColor) || this.lineColor,
              axisStrokeWidth: (null == (t = this.radar) ? void 0 : t.axisStrokeWidth) || 2,
              axisLabelFontSize: (null == (r = this.radar) ? void 0 : r.axisLabelFontSize) || 12,
              curveOpacity: (null == (n = this.radar) ? void 0 : n.curveOpacity) || 0.5,
              curveStrokeWidth: (null == (i = this.radar) ? void 0 : i.curveStrokeWidth) || 2,
              graticuleColor: (null == (a = this.radar) ? void 0 : a.graticuleColor) || '#DEDEDE',
              graticuleStrokeWidth:
                (null == (o = this.radar) ? void 0 : o.graticuleStrokeWidth) || 1,
              graticuleOpacity: (null == (s = this.radar) ? void 0 : s.graticuleOpacity) || 0.3,
              legendBoxSize: (null == (l = this.radar) ? void 0 : l.legendBoxSize) || 12,
              legendFontSize: (null == (c = this.radar) ? void 0 : c.legendFontSize) || 12,
            }),
            (this.archEdgeColor = this.archEdgeColor || '#777'),
            (this.archEdgeArrowColor = this.archEdgeArrowColor || '#777'),
            (this.archEdgeWidth = this.archEdgeWidth || '3'),
            (this.archGroupBorderColor = this.archGroupBorderColor || '#000'),
            (this.archGroupBorderWidth = this.archGroupBorderWidth || '2px'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill || Ti(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill || Ti(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill || Ti(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill || Ti(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill || Ti(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill || Ti(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Si(this.quadrant1Fill)
                ? Di(this.quadrant1Fill)
                : Ai(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor:
                (null == (h = this.xyChart) ? void 0 : h.backgroundColor) || this.background,
              titleColor:
                (null == (d = this.xyChart) ? void 0 : d.titleColor) || this.primaryTextColor,
              xAxisTitleColor:
                (null == (u = this.xyChart) ? void 0 : u.xAxisTitleColor) || this.primaryTextColor,
              xAxisLabelColor:
                (null == (p = this.xyChart) ? void 0 : p.xAxisLabelColor) || this.primaryTextColor,
              xAxisTickColor:
                (null == (g = this.xyChart) ? void 0 : g.xAxisTickColor) || this.primaryTextColor,
              xAxisLineColor:
                (null == (f = this.xyChart) ? void 0 : f.xAxisLineColor) || this.primaryTextColor,
              yAxisTitleColor:
                (null == (m = this.xyChart) ? void 0 : m.yAxisTitleColor) || this.primaryTextColor,
              yAxisLabelColor:
                (null == (b = this.xyChart) ? void 0 : b.yAxisLabelColor) || this.primaryTextColor,
              yAxisTickColor:
                (null == (y = this.xyChart) ? void 0 : y.yAxisTickColor) || this.primaryTextColor,
              yAxisLineColor:
                (null == (x = this.xyChart) ? void 0 : x.yAxisLineColor) || this.primaryTextColor,
              plotColorPalette:
                (null == (k = this.xyChart) ? void 0 : k.plotColorPalette) ||
                '#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground ||
              (this.darkMode ? Ai(this.secondaryColor, 30) : this.secondaryColor)),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || Ti(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || Ti(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || Ti(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || Ti(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || Ti(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Di(this.git0, 25)),
                (this.git1 = Di(this.git1, 25)),
                (this.git2 = Di(this.git2, 25)),
                (this.git3 = Di(this.git3, 25)),
                (this.git4 = Di(this.git4, 25)),
                (this.git5 = Di(this.git5, 25)),
                (this.git6 = Di(this.git6, 25)),
                (this.git7 = Di(this.git7, 25)))
              : ((this.git0 = Ai(this.git0, 25)),
                (this.git1 = Ai(this.git1, 25)),
                (this.git2 = Ai(this.git2, 25)),
                (this.git3 = Ai(this.git3, 25)),
                (this.git4 = Ai(this.git4, 25)),
                (this.git5 = Ai(this.git5, 25)),
                (this.git6 = Ai(this.git6, 25)),
                (this.git7 = Ai(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Fi(this.git0)),
            (this.gitInv1 = this.gitInv1 || Fi(this.git1)),
            (this.gitInv2 = this.gitInv2 || Fi(this.git2)),
            (this.gitInv3 = this.gitInv3 || Fi(this.git3)),
            (this.gitInv4 = this.gitInv4 || Fi(this.git4)),
            (this.gitInv5 = this.gitInv5 || Fi(this.git5)),
            (this.gitInv6 = this.gitInv6 || Fi(this.git6)),
            (this.gitInv7 = this.gitInv7 || Fi(this.git7)),
            (this.branchLabelColor =
              this.branchLabelColor || (this.darkMode ? 'black' : this.labelTextColor)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Va),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Za));
        }
        calculate(e) {
          if ('object' != typeof e) return void this.updateColors();
          const t = Object.keys(e);
          (t.forEach((t) => {
            this[t] = e[t];
          }),
            this.updateColors(),
            t.forEach((t) => {
              this[t] = e[t];
            }));
        }
      }),
      'Theme'
    ),
    t),
  Xa = ii((e) => {
    const t = new Ya();
    return (t.calculate(e), t);
  }, 'getThemeVariables'),
  Qa =
    (ii(
      (r = class {
        constructor() {
          ((this.background = '#333'),
            (this.primaryColor = '#1f2020'),
            (this.secondaryColor = Di(this.primaryColor, 16)),
            (this.tertiaryColor = Ti(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = Fi(this.background)),
            (this.secondaryBorderColor = Ka(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = Ka(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Fi(this.primaryColor)),
            (this.secondaryTextColor = Fi(this.secondaryColor)),
            (this.tertiaryTextColor = Fi(this.tertiaryColor)),
            (this.lineColor = Fi(this.background)),
            (this.textColor = Fi(this.background)),
            (this.mainBkg = '#1f2020'),
            (this.secondBkg = 'calculated'),
            (this.mainContrastColor = 'lightgrey'),
            (this.darkTextColor = Di(Fi('#323D47'), 10)),
            (this.lineColor = 'calculated'),
            (this.border1 = '#ccc'),
            (this.border2 = vi(255, 255, 255, 0.25)),
            (this.arrowheadColor = 'calculated'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.labelBackground = '#181818'),
            (this.textColor = '#ccc'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = '#F9FFFE'),
            (this.edgeLabelBackground = 'calculated'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'calculated'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = 'calculated'),
            (this.activationBkgColor = 'calculated'),
            (this.sequenceNumberColor = 'black'),
            (this.sectionBkgColor = Ai('#EAE8D9', 30)),
            (this.altSectionBkgColor = 'calculated'),
            (this.sectionBkgColor2 = '#EAE8D9'),
            (this.excludeBkgColor = Ai(this.sectionBkgColor, 10)),
            (this.taskBorderColor = vi(255, 255, 255, 70)),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextLightColor = 'calculated'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = vi(255, 255, 255, 50)),
            (this.activeTaskBkgColor = '#81B1DB'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#E83737'),
            (this.critBkgColor = '#E83737'),
            (this.taskTextDarkColor = 'calculated'),
            (this.todayLineColor = '#DB5757'),
            (this.vertLineColor = '#00BFFF'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = this.rowOdd || Di(this.mainBkg, 5) || '#ffffff'),
            (this.rowEven = this.rowEven || Ai(this.mainBkg, 10)),
            (this.labelColor = 'calculated'),
            (this.errorBkgColor = '#a44141'),
            (this.errorTextColor = '#ddd'));
        }
        updateColors() {
          var e, t, r, n, i, a, o, s, l, c, h, d, u, p, g, f, m, b, y, x, k;
          ((this.secondBkg = Di(this.mainBkg, 16)),
            (this.lineColor = this.mainContrastColor),
            (this.arrowheadColor = this.mainContrastColor),
            (this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.edgeLabelBackground = Di(this.labelBackground, 25)),
            (this.actorBorder = this.border1),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.mainContrastColor),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.mainContrastColor),
            (this.signalTextColor = this.mainContrastColor),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.mainContrastColor),
            (this.loopTextColor = this.mainContrastColor),
            (this.noteBorderColor = this.secondaryBorderColor),
            (this.noteBkgColor = this.secondBkg),
            (this.noteTextColor = this.secondaryTextColor),
            (this.activationBorderColor = this.border1),
            (this.activationBkgColor = this.secondBkg),
            (this.altSectionBkgColor = this.background),
            (this.taskBkgColor = Di(this.mainBkg, 23)),
            (this.taskTextColor = this.darkTextColor),
            (this.taskTextLightColor = this.mainContrastColor),
            (this.taskTextOutsideColor = this.taskTextLightColor),
            (this.gridColor = this.mainContrastColor),
            (this.doneTaskBkgColor = this.mainContrastColor),
            (this.taskTextDarkColor = this.darkTextColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#555'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = '#f4f4f4'),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = Ti(this.primaryColor, { h: 64 })),
            (this.fillType3 = Ti(this.secondaryColor, { h: 64 })),
            (this.fillType4 = Ti(this.primaryColor, { h: -64 })),
            (this.fillType5 = Ti(this.secondaryColor, { h: -64 })),
            (this.fillType6 = Ti(this.primaryColor, { h: 128 })),
            (this.fillType7 = Ti(this.secondaryColor, { h: 128 })),
            (this.cScale1 = this.cScale1 || '#0b0000'),
            (this.cScale2 = this.cScale2 || '#4d1037'),
            (this.cScale3 = this.cScale3 || '#3f5258'),
            (this.cScale4 = this.cScale4 || '#4f2f1b'),
            (this.cScale5 = this.cScale5 || '#6e0a0a'),
            (this.cScale6 = this.cScale6 || '#3b0048'),
            (this.cScale7 = this.cScale7 || '#995a01'),
            (this.cScale8 = this.cScale8 || '#154706'),
            (this.cScale9 = this.cScale9 || '#161722'),
            (this.cScale10 = this.cScale10 || '#00296f'),
            (this.cScale11 = this.cScale11 || '#01629c'),
            (this.cScale12 = this.cScale12 || '#010029'),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || Ti(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || Ti(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || Ti(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || Ti(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || Ti(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || Ti(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || Ti(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || Ti(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || Ti(this.primaryColor, { h: 330 })));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleInv' + C] = this['cScaleInv' + C] || Fi(this['cScale' + C]);
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScalePeer' + C] = this['cScalePeer' + C] || Di(this['cScale' + C], 10);
          for (let C = 0; C < 5; C++)
            ((this['surface' + C] =
              this['surface' + C] || Ti(this.mainBkg, { h: 30, s: -30, l: -(4 * C - 10) })),
              (this['surfacePeer' + C] =
                this['surfacePeer' + C] || Ti(this.mainBkg, { h: 30, s: -30, l: -(4 * C - 7) })));
          this.scaleLabelColor =
            this.scaleLabelColor || (this.darkMode ? 'black' : this.labelTextColor);
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleLabel' + C] = this['cScaleLabel' + C] || this.scaleLabelColor;
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++) this['pie' + C] = this['cScale' + C];
          ((this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill || Ti(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill || Ti(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill || Ti(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill || Ti(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill || Ti(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill || Ti(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Si(this.quadrant1Fill)
                ? Di(this.quadrant1Fill)
                : Ai(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor:
                (null == (e = this.xyChart) ? void 0 : e.backgroundColor) || this.background,
              titleColor:
                (null == (t = this.xyChart) ? void 0 : t.titleColor) || this.primaryTextColor,
              xAxisTitleColor:
                (null == (r = this.xyChart) ? void 0 : r.xAxisTitleColor) || this.primaryTextColor,
              xAxisLabelColor:
                (null == (n = this.xyChart) ? void 0 : n.xAxisLabelColor) || this.primaryTextColor,
              xAxisTickColor:
                (null == (i = this.xyChart) ? void 0 : i.xAxisTickColor) || this.primaryTextColor,
              xAxisLineColor:
                (null == (a = this.xyChart) ? void 0 : a.xAxisLineColor) || this.primaryTextColor,
              yAxisTitleColor:
                (null == (o = this.xyChart) ? void 0 : o.yAxisTitleColor) || this.primaryTextColor,
              yAxisLabelColor:
                (null == (s = this.xyChart) ? void 0 : s.yAxisLabelColor) || this.primaryTextColor,
              yAxisTickColor:
                (null == (l = this.xyChart) ? void 0 : l.yAxisTickColor) || this.primaryTextColor,
              yAxisLineColor:
                (null == (c = this.xyChart) ? void 0 : c.yAxisLineColor) || this.primaryTextColor,
              plotColorPalette:
                (null == (h = this.xyChart) ? void 0 : h.plotColorPalette) ||
                '#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22',
            }),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.background,
            }),
            (this.radar = {
              axisColor: (null == (d = this.radar) ? void 0 : d.axisColor) || this.lineColor,
              axisStrokeWidth: (null == (u = this.radar) ? void 0 : u.axisStrokeWidth) || 2,
              axisLabelFontSize: (null == (p = this.radar) ? void 0 : p.axisLabelFontSize) || 12,
              curveOpacity: (null == (g = this.radar) ? void 0 : g.curveOpacity) || 0.5,
              curveStrokeWidth: (null == (f = this.radar) ? void 0 : f.curveStrokeWidth) || 2,
              graticuleColor: (null == (m = this.radar) ? void 0 : m.graticuleColor) || '#DEDEDE',
              graticuleStrokeWidth:
                (null == (b = this.radar) ? void 0 : b.graticuleStrokeWidth) || 1,
              graticuleOpacity: (null == (y = this.radar) ? void 0 : y.graticuleOpacity) || 0.3,
              legendBoxSize: (null == (x = this.radar) ? void 0 : x.legendBoxSize) || 12,
              legendFontSize: (null == (k = this.radar) ? void 0 : k.legendFontSize) || 12,
            }),
            (this.classText = this.primaryTextColor),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground ||
              (this.darkMode ? Ai(this.secondaryColor, 30) : this.secondaryColor)),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = Di(this.secondaryColor, 20)),
            (this.git1 = Di(this.pie2 || this.secondaryColor, 20)),
            (this.git2 = Di(this.pie3 || this.tertiaryColor, 20)),
            (this.git3 = Di(this.pie4 || Ti(this.primaryColor, { h: -30 }), 20)),
            (this.git4 = Di(this.pie5 || Ti(this.primaryColor, { h: -60 }), 20)),
            (this.git5 = Di(this.pie6 || Ti(this.primaryColor, { h: -90 }), 10)),
            (this.git6 = Di(this.pie7 || Ti(this.primaryColor, { h: 60 }), 10)),
            (this.git7 = Di(this.pie8 || Ti(this.primaryColor, { h: 120 }), 20)),
            (this.gitInv0 = this.gitInv0 || Fi(this.git0)),
            (this.gitInv1 = this.gitInv1 || Fi(this.git1)),
            (this.gitInv2 = this.gitInv2 || Fi(this.git2)),
            (this.gitInv3 = this.gitInv3 || Fi(this.git3)),
            (this.gitInv4 = this.gitInv4 || Fi(this.git4)),
            (this.gitInv5 = this.gitInv5 || Fi(this.git5)),
            (this.gitInv6 = this.gitInv6 || Fi(this.git6)),
            (this.gitInv7 = this.gitInv7 || Fi(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Fi(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Fi(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || Di(this.background, 12)),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || Di(this.background, 2)),
            (this.nodeBorder = this.nodeBorder || '#999'));
        }
        calculate(e) {
          if ('object' != typeof e) return void this.updateColors();
          const t = Object.keys(e);
          (t.forEach((t) => {
            this[t] = e[t];
          }),
            this.updateColors(),
            t.forEach((t) => {
              this[t] = e[t];
            }));
        }
      }),
      'Theme'
    ),
    r),
  Ja = ii((e) => {
    const t = new Qa();
    return (t.calculate(e), t);
  }, 'getThemeVariables'),
  eo =
    (ii(
      (n = class {
        constructor() {
          ((this.background = '#f4f4f4'),
            (this.primaryColor = '#ECECFF'),
            (this.secondaryColor = Ti(this.primaryColor, { h: 120 })),
            (this.secondaryColor = '#ffffde'),
            (this.tertiaryColor = Ti(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = Ka(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = Ka(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = Ka(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Fi(this.primaryColor)),
            (this.secondaryTextColor = Fi(this.secondaryColor)),
            (this.tertiaryTextColor = Fi(this.tertiaryColor)),
            (this.lineColor = Fi(this.background)),
            (this.textColor = Fi(this.background)),
            (this.background = 'white'),
            (this.mainBkg = '#ECECFF'),
            (this.secondBkg = '#ffffde'),
            (this.lineColor = '#333333'),
            (this.border1 = '#9370DB'),
            (this.border2 = '#aaaa33'),
            (this.arrowheadColor = '#333333'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.labelBackground = 'rgba(232,232,232, 0.8)'),
            (this.textColor = '#333'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = 'calculated'),
            (this.edgeLabelBackground = 'calculated'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'black'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = 'calculated'),
            (this.altSectionBkgColor = 'calculated'),
            (this.sectionBkgColor2 = 'calculated'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextLightColor = 'calculated'),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = 'calculated'),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.taskTextClickableColor = 'calculated'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'calculated'),
            (this.critBorderColor = 'calculated'),
            (this.critBkgColor = 'calculated'),
            (this.todayLineColor = 'calculated'),
            (this.vertLineColor = 'calculated'),
            (this.sectionBkgColor = vi(102, 102, 255, 0.49)),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = '#fff400'),
            (this.taskBorderColor = '#534fbc'),
            (this.taskBkgColor = '#8a90dd'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'black'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = '#534fbc'),
            (this.activeTaskBkgColor = '#bfc7ff'),
            (this.gridColor = 'lightgrey'),
            (this.doneTaskBkgColor = 'lightgrey'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#ff8888'),
            (this.critBkgColor = 'red'),
            (this.todayLineColor = 'red'),
            (this.vertLineColor = 'navy'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = 'calculated'),
            (this.rowEven = 'calculated'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222'),
            this.updateColors());
        }
        updateColors() {
          var e, t, r, n, i, a, o, s, l, c, h, d, u, p, g, f, m, b, y, x, k;
          ((this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || Ti(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || Ti(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || Ti(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || Ti(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || Ti(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || Ti(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || Ti(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || Ti(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || Ti(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 = this.cScalePeer1 || Ai(this.secondaryColor, 45)),
            (this.cScalePeer2 = this.cScalePeer2 || Ai(this.tertiaryColor, 40)));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            ((this['cScale' + C] = Ai(this['cScale' + C], 10)),
              (this['cScalePeer' + C] = this['cScalePeer' + C] || Ai(this['cScale' + C], 25)));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleInv' + C] = this['cScaleInv' + C] || Ti(this['cScale' + C], { h: 180 });
          for (let C = 0; C < 5; C++)
            ((this['surface' + C] =
              this['surface' + C] || Ti(this.mainBkg, { h: 30, l: -(5 + 5 * C) })),
              (this['surfacePeer' + C] =
                this['surfacePeer' + C] || Ti(this.mainBkg, { h: 30, l: -(7 + 5 * C) })));
          if (
            ((this.scaleLabelColor =
              'calculated' !== this.scaleLabelColor && this.scaleLabelColor
                ? this.scaleLabelColor
                : this.labelTextColor),
            'calculated' !== this.labelTextColor)
          ) {
            ((this.cScaleLabel0 = this.cScaleLabel0 || Fi(this.labelTextColor)),
              (this.cScaleLabel3 = this.cScaleLabel3 || Fi(this.labelTextColor)));
            for (let e = 0; e < this.THEME_COLOR_LIMIT; e++)
              this['cScaleLabel' + e] = this['cScaleLabel' + e] || this.labelTextColor;
          }
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.textColor),
            (this.edgeLabelBackground = this.labelBackground),
            (this.actorBorder = Di(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.signalColor = this.textColor),
            (this.signalTextColor = this.textColor),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd = this.rowOdd || Di(this.primaryColor, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || Di(this.primaryColor, 1)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f0f0f0'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = Ti(this.primaryColor, { h: 64 })),
            (this.fillType3 = Ti(this.secondaryColor, { h: 64 })),
            (this.fillType4 = Ti(this.primaryColor, { h: -64 })),
            (this.fillType5 = Ti(this.secondaryColor, { h: -64 })),
            (this.fillType6 = Ti(this.primaryColor, { h: 128 })),
            (this.fillType7 = Ti(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || Ti(this.tertiaryColor, { l: -40 })),
            (this.pie4 = this.pie4 || Ti(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || Ti(this.secondaryColor, { l: -30 })),
            (this.pie6 = this.pie6 || Ti(this.tertiaryColor, { l: -20 })),
            (this.pie7 = this.pie7 || Ti(this.primaryColor, { h: 60, l: -20 })),
            (this.pie8 = this.pie8 || Ti(this.primaryColor, { h: -60, l: -40 })),
            (this.pie9 = this.pie9 || Ti(this.primaryColor, { h: 120, l: -40 })),
            (this.pie10 = this.pie10 || Ti(this.primaryColor, { h: 60, l: -40 })),
            (this.pie11 = this.pie11 || Ti(this.primaryColor, { h: -90, l: -40 })),
            (this.pie12 = this.pie12 || Ti(this.primaryColor, { h: 120, l: -30 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill || Ti(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill || Ti(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill || Ti(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill || Ti(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill || Ti(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill || Ti(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Si(this.quadrant1Fill)
                ? Di(this.quadrant1Fill)
                : Ai(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.radar = {
              axisColor: (null == (e = this.radar) ? void 0 : e.axisColor) || this.lineColor,
              axisStrokeWidth: (null == (t = this.radar) ? void 0 : t.axisStrokeWidth) || 2,
              axisLabelFontSize: (null == (r = this.radar) ? void 0 : r.axisLabelFontSize) || 12,
              curveOpacity: (null == (n = this.radar) ? void 0 : n.curveOpacity) || 0.5,
              curveStrokeWidth: (null == (i = this.radar) ? void 0 : i.curveStrokeWidth) || 2,
              graticuleColor: (null == (a = this.radar) ? void 0 : a.graticuleColor) || '#DEDEDE',
              graticuleStrokeWidth:
                (null == (o = this.radar) ? void 0 : o.graticuleStrokeWidth) || 1,
              graticuleOpacity: (null == (s = this.radar) ? void 0 : s.graticuleOpacity) || 0.3,
              legendBoxSize: (null == (l = this.radar) ? void 0 : l.legendBoxSize) || 12,
              legendFontSize: (null == (c = this.radar) ? void 0 : c.legendFontSize) || 12,
            }),
            (this.xyChart = {
              backgroundColor:
                (null == (h = this.xyChart) ? void 0 : h.backgroundColor) || this.background,
              titleColor:
                (null == (d = this.xyChart) ? void 0 : d.titleColor) || this.primaryTextColor,
              xAxisTitleColor:
                (null == (u = this.xyChart) ? void 0 : u.xAxisTitleColor) || this.primaryTextColor,
              xAxisLabelColor:
                (null == (p = this.xyChart) ? void 0 : p.xAxisLabelColor) || this.primaryTextColor,
              xAxisTickColor:
                (null == (g = this.xyChart) ? void 0 : g.xAxisTickColor) || this.primaryTextColor,
              xAxisLineColor:
                (null == (f = this.xyChart) ? void 0 : f.xAxisLineColor) || this.primaryTextColor,
              yAxisTitleColor:
                (null == (m = this.xyChart) ? void 0 : m.yAxisTitleColor) || this.primaryTextColor,
              yAxisLabelColor:
                (null == (b = this.xyChart) ? void 0 : b.yAxisLabelColor) || this.primaryTextColor,
              yAxisTickColor:
                (null == (y = this.xyChart) ? void 0 : y.yAxisTickColor) || this.primaryTextColor,
              yAxisLineColor:
                (null == (x = this.xyChart) ? void 0 : x.yAxisLineColor) || this.primaryTextColor,
              plotColorPalette:
                (null == (k = this.xyChart) ? void 0 : k.plotColorPalette) ||
                '#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground = this.relationLabelBackground || this.labelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || Ti(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || Ti(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || Ti(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || Ti(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || Ti(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Di(this.git0, 25)),
                (this.git1 = Di(this.git1, 25)),
                (this.git2 = Di(this.git2, 25)),
                (this.git3 = Di(this.git3, 25)),
                (this.git4 = Di(this.git4, 25)),
                (this.git5 = Di(this.git5, 25)),
                (this.git6 = Di(this.git6, 25)),
                (this.git7 = Di(this.git7, 25)))
              : ((this.git0 = Ai(this.git0, 25)),
                (this.git1 = Ai(this.git1, 25)),
                (this.git2 = Ai(this.git2, 25)),
                (this.git3 = Ai(this.git3, 25)),
                (this.git4 = Ai(this.git4, 25)),
                (this.git5 = Ai(this.git5, 25)),
                (this.git6 = Ai(this.git6, 25)),
                (this.git7 = Ai(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Ai(Fi(this.git0), 25)),
            (this.gitInv1 = this.gitInv1 || Fi(this.git1)),
            (this.gitInv2 = this.gitInv2 || Fi(this.git2)),
            (this.gitInv3 = this.gitInv3 || Fi(this.git3)),
            (this.gitInv4 = this.gitInv4 || Fi(this.git4)),
            (this.gitInv5 = this.gitInv5 || Fi(this.git5)),
            (this.gitInv6 = this.gitInv6 || Fi(this.git6)),
            (this.gitInv7 = this.gitInv7 || Fi(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Fi(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Fi(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Va),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Za));
        }
        calculate(e) {
          if (
            (Object.keys(this).forEach((e) => {
              'calculated' === this[e] && (this[e] = void 0);
            }),
            'object' != typeof e)
          )
            return void this.updateColors();
          const t = Object.keys(e);
          (t.forEach((t) => {
            this[t] = e[t];
          }),
            this.updateColors(),
            t.forEach((t) => {
              this[t] = e[t];
            }));
        }
      }),
      'Theme'
    ),
    n),
  to = ii((e) => {
    const t = new eo();
    return (t.calculate(e), t);
  }, 'getThemeVariables'),
  ro =
    (ii(
      (i = class {
        constructor() {
          ((this.background = '#f4f4f4'),
            (this.primaryColor = '#cde498'),
            (this.secondaryColor = '#cdffb2'),
            (this.background = 'white'),
            (this.mainBkg = '#cde498'),
            (this.secondBkg = '#cdffb2'),
            (this.lineColor = 'green'),
            (this.border1 = '#13540c'),
            (this.border2 = '#6eaa49'),
            (this.arrowheadColor = 'green'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.tertiaryColor = Di('#cde498', 10)),
            (this.primaryBorderColor = Ka(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = Ka(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = Ka(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Fi(this.primaryColor)),
            (this.secondaryTextColor = Fi(this.secondaryColor)),
            (this.tertiaryTextColor = Fi(this.primaryColor)),
            (this.lineColor = Fi(this.background)),
            (this.textColor = Fi(this.background)),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = '#333'),
            (this.edgeLabelBackground = '#e8e8e8'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'black'),
            (this.actorLineColor = 'calculated'),
            (this.signalColor = '#333'),
            (this.signalTextColor = '#333'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = '#326932'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = '#fff5ad'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = '#6eaa49'),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = '#6eaa49'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = '#487e3a'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'black'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'lightgrey'),
            (this.doneTaskBkgColor = 'lightgrey'),
            (this.doneTaskBorderColor = 'grey'),
            (this.critBorderColor = '#ff8888'),
            (this.critBkgColor = 'red'),
            (this.todayLineColor = 'red'),
            (this.vertLineColor = '#00BFFF'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222'));
        }
        updateColors() {
          var e, t, r, n, i, a, o, s, l, c, h, d, u, p, g, f, m, b, y, x, k;
          ((this.actorBorder = Ai(this.mainBkg, 20)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || Ti(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || Ti(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || Ti(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || Ti(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || Ti(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || Ti(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || Ti(this.primaryColor, { h: 270 })),
            (this.cScale10 = this.cScale10 || Ti(this.primaryColor, { h: 300 })),
            (this.cScale11 = this.cScale11 || Ti(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 = this.cScalePeer1 || Ai(this.secondaryColor, 45)),
            (this.cScalePeer2 = this.cScalePeer2 || Ai(this.tertiaryColor, 40)));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            ((this['cScale' + C] = Ai(this['cScale' + C], 10)),
              (this['cScalePeer' + C] = this['cScalePeer' + C] || Ai(this['cScale' + C], 25)));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleInv' + C] = this['cScaleInv' + C] || Ti(this['cScale' + C], { h: 180 });
          this.scaleLabelColor =
            'calculated' !== this.scaleLabelColor && this.scaleLabelColor
              ? this.scaleLabelColor
              : this.labelTextColor;
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleLabel' + C] = this['cScaleLabel' + C] || this.scaleLabelColor;
          for (let C = 0; C < 5; C++)
            ((this['surface' + C] =
              this['surface' + C] || Ti(this.mainBkg, { h: 30, s: -30, l: -(5 + 5 * C) })),
              (this['surfacePeer' + C] =
                this['surfacePeer' + C] || Ti(this.mainBkg, { h: 30, s: -30, l: -(8 + 5 * C) })));
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.taskBorderColor = this.border1),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd = this.rowOdd || Di(this.mainBkg, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || Di(this.mainBkg, 20)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f0f0f0'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = Ti(this.primaryColor, { h: 64 })),
            (this.fillType3 = Ti(this.secondaryColor, { h: 64 })),
            (this.fillType4 = Ti(this.primaryColor, { h: -64 })),
            (this.fillType5 = Ti(this.secondaryColor, { h: -64 })),
            (this.fillType6 = Ti(this.primaryColor, { h: 128 })),
            (this.fillType7 = Ti(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || Ti(this.primaryColor, { l: -30 })),
            (this.pie5 = this.pie5 || Ti(this.secondaryColor, { l: -30 })),
            (this.pie6 = this.pie6 || Ti(this.tertiaryColor, { h: 40, l: -40 })),
            (this.pie7 = this.pie7 || Ti(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 = this.pie8 || Ti(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || Ti(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 = this.pie10 || Ti(this.primaryColor, { h: 60, l: -50 })),
            (this.pie11 = this.pie11 || Ti(this.primaryColor, { h: -60, l: -50 })),
            (this.pie12 = this.pie12 || Ti(this.primaryColor, { h: 120, l: -50 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill || Ti(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill || Ti(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill || Ti(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill || Ti(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill || Ti(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill || Ti(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Si(this.quadrant1Fill)
                ? Di(this.quadrant1Fill)
                : Ai(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.mainBkg,
            }),
            (this.radar = {
              axisColor: (null == (e = this.radar) ? void 0 : e.axisColor) || this.lineColor,
              axisStrokeWidth: (null == (t = this.radar) ? void 0 : t.axisStrokeWidth) || 2,
              axisLabelFontSize: (null == (r = this.radar) ? void 0 : r.axisLabelFontSize) || 12,
              curveOpacity: (null == (n = this.radar) ? void 0 : n.curveOpacity) || 0.5,
              curveStrokeWidth: (null == (i = this.radar) ? void 0 : i.curveStrokeWidth) || 2,
              graticuleColor: (null == (a = this.radar) ? void 0 : a.graticuleColor) || '#DEDEDE',
              graticuleStrokeWidth:
                (null == (o = this.radar) ? void 0 : o.graticuleStrokeWidth) || 1,
              graticuleOpacity: (null == (s = this.radar) ? void 0 : s.graticuleOpacity) || 0.3,
              legendBoxSize: (null == (l = this.radar) ? void 0 : l.legendBoxSize) || 12,
              legendFontSize: (null == (c = this.radar) ? void 0 : c.legendFontSize) || 12,
            }),
            (this.xyChart = {
              backgroundColor:
                (null == (h = this.xyChart) ? void 0 : h.backgroundColor) || this.background,
              titleColor:
                (null == (d = this.xyChart) ? void 0 : d.titleColor) || this.primaryTextColor,
              xAxisTitleColor:
                (null == (u = this.xyChart) ? void 0 : u.xAxisTitleColor) || this.primaryTextColor,
              xAxisLabelColor:
                (null == (p = this.xyChart) ? void 0 : p.xAxisLabelColor) || this.primaryTextColor,
              xAxisTickColor:
                (null == (g = this.xyChart) ? void 0 : g.xAxisTickColor) || this.primaryTextColor,
              xAxisLineColor:
                (null == (f = this.xyChart) ? void 0 : f.xAxisLineColor) || this.primaryTextColor,
              yAxisTitleColor:
                (null == (m = this.xyChart) ? void 0 : m.yAxisTitleColor) || this.primaryTextColor,
              yAxisLabelColor:
                (null == (b = this.xyChart) ? void 0 : b.yAxisLabelColor) || this.primaryTextColor,
              yAxisTickColor:
                (null == (y = this.xyChart) ? void 0 : y.yAxisTickColor) || this.primaryTextColor,
              yAxisLineColor:
                (null == (x = this.xyChart) ? void 0 : x.yAxisLineColor) || this.primaryTextColor,
              plotColorPalette:
                (null == (k = this.xyChart) ? void 0 : k.plotColorPalette) ||
                '#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176',
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || Ti(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || Ti(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || Ti(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || Ti(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || Ti(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Di(this.git0, 25)),
                (this.git1 = Di(this.git1, 25)),
                (this.git2 = Di(this.git2, 25)),
                (this.git3 = Di(this.git3, 25)),
                (this.git4 = Di(this.git4, 25)),
                (this.git5 = Di(this.git5, 25)),
                (this.git6 = Di(this.git6, 25)),
                (this.git7 = Di(this.git7, 25)))
              : ((this.git0 = Ai(this.git0, 25)),
                (this.git1 = Ai(this.git1, 25)),
                (this.git2 = Ai(this.git2, 25)),
                (this.git3 = Ai(this.git3, 25)),
                (this.git4 = Ai(this.git4, 25)),
                (this.git5 = Ai(this.git5, 25)),
                (this.git6 = Ai(this.git6, 25)),
                (this.git7 = Ai(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Fi(this.git0)),
            (this.gitInv1 = this.gitInv1 || Fi(this.git1)),
            (this.gitInv2 = this.gitInv2 || Fi(this.git2)),
            (this.gitInv3 = this.gitInv3 || Fi(this.git3)),
            (this.gitInv4 = this.gitInv4 || Fi(this.git4)),
            (this.gitInv5 = this.gitInv5 || Fi(this.git5)),
            (this.gitInv6 = this.gitInv6 || Fi(this.git6)),
            (this.gitInv7 = this.gitInv7 || Fi(this.git7)),
            (this.gitBranchLabel0 = this.gitBranchLabel0 || Fi(this.labelTextColor)),
            (this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 = this.gitBranchLabel3 || Fi(this.labelTextColor)),
            (this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Va),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Za));
        }
        calculate(e) {
          if ('object' != typeof e) return void this.updateColors();
          const t = Object.keys(e);
          (t.forEach((t) => {
            this[t] = e[t];
          }),
            this.updateColors(),
            t.forEach((t) => {
              this[t] = e[t];
            }));
        }
      }),
      'Theme'
    ),
    i),
  no = ii((e) => {
    const t = new ro();
    return (t.calculate(e), t);
  }, 'getThemeVariables'),
  io =
    (ii(
      (a = class {
        constructor() {
          ((this.primaryColor = '#eee'),
            (this.contrast = '#707070'),
            (this.secondaryColor = Di(this.contrast, 55)),
            (this.background = '#ffffff'),
            (this.tertiaryColor = Ti(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = Ka(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = Ka(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor = Ka(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Fi(this.primaryColor)),
            (this.secondaryTextColor = Fi(this.secondaryColor)),
            (this.tertiaryTextColor = Fi(this.tertiaryColor)),
            (this.lineColor = Fi(this.background)),
            (this.textColor = Fi(this.background)),
            (this.mainBkg = '#eee'),
            (this.secondBkg = 'calculated'),
            (this.lineColor = '#666'),
            (this.border1 = '#999'),
            (this.border2 = 'calculated'),
            (this.note = '#ffa'),
            (this.text = '#333'),
            (this.critical = '#d42'),
            (this.done = '#bbb'),
            (this.arrowheadColor = '#333333'),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = '16px'),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = 'calculated'),
            (this.nodeBorder = 'calculated'),
            (this.clusterBkg = 'calculated'),
            (this.clusterBorder = 'calculated'),
            (this.defaultLinkColor = 'calculated'),
            (this.titleColor = 'calculated'),
            (this.edgeLabelBackground = 'white'),
            (this.actorBorder = 'calculated'),
            (this.actorBkg = 'calculated'),
            (this.actorTextColor = 'calculated'),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = 'calculated'),
            (this.signalTextColor = 'calculated'),
            (this.labelBoxBkgColor = 'calculated'),
            (this.labelBoxBorderColor = 'calculated'),
            (this.labelTextColor = 'calculated'),
            (this.loopTextColor = 'calculated'),
            (this.noteBorderColor = 'calculated'),
            (this.noteBkgColor = 'calculated'),
            (this.noteTextColor = 'calculated'),
            (this.activationBorderColor = '#666'),
            (this.activationBkgColor = '#f4f4f4'),
            (this.sequenceNumberColor = 'white'),
            (this.sectionBkgColor = 'calculated'),
            (this.altSectionBkgColor = 'white'),
            (this.sectionBkgColor2 = 'calculated'),
            (this.excludeBkgColor = '#eeeeee'),
            (this.taskBorderColor = 'calculated'),
            (this.taskBkgColor = 'calculated'),
            (this.taskTextLightColor = 'white'),
            (this.taskTextColor = 'calculated'),
            (this.taskTextDarkColor = 'calculated'),
            (this.taskTextOutsideColor = 'calculated'),
            (this.taskTextClickableColor = '#003163'),
            (this.activeTaskBorderColor = 'calculated'),
            (this.activeTaskBkgColor = 'calculated'),
            (this.gridColor = 'calculated'),
            (this.doneTaskBkgColor = 'calculated'),
            (this.doneTaskBorderColor = 'calculated'),
            (this.critBkgColor = 'calculated'),
            (this.critBorderColor = 'calculated'),
            (this.todayLineColor = 'calculated'),
            (this.vertLineColor = 'calculated'),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = 'calculated'),
            (this.archEdgeArrowColor = 'calculated'),
            (this.archEdgeWidth = '3'),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = '2px'),
            (this.rowOdd = this.rowOdd || Di(this.mainBkg, 75) || '#ffffff'),
            (this.rowEven = this.rowEven || '#f4f4f4'),
            (this.labelColor = 'black'),
            (this.errorBkgColor = '#552222'),
            (this.errorTextColor = '#552222'));
        }
        updateColors() {
          var e, t, r, n, i, a, o, s, l, c, h, d, u, p, g, f, m, b, y, x, k;
          ((this.secondBkg = Di(this.contrast, 55)),
            (this.border2 = this.contrast),
            (this.actorBorder = Di(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.text),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.text),
            (this.signalTextColor = this.text),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.text),
            (this.loopTextColor = this.text),
            (this.noteBorderColor = '#999'),
            (this.noteBkgColor = '#666'),
            (this.noteTextColor = '#fff'),
            (this.cScale0 = this.cScale0 || '#555'),
            (this.cScale1 = this.cScale1 || '#F4F4F4'),
            (this.cScale2 = this.cScale2 || '#555'),
            (this.cScale3 = this.cScale3 || '#BBB'),
            (this.cScale4 = this.cScale4 || '#777'),
            (this.cScale5 = this.cScale5 || '#999'),
            (this.cScale6 = this.cScale6 || '#DDD'),
            (this.cScale7 = this.cScale7 || '#FFF'),
            (this.cScale8 = this.cScale8 || '#DDD'),
            (this.cScale9 = this.cScale9 || '#BBB'),
            (this.cScale10 = this.cScale10 || '#999'),
            (this.cScale11 = this.cScale11 || '#777'));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleInv' + C] = this['cScaleInv' + C] || Fi(this['cScale' + C]);
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this.darkMode
              ? (this['cScalePeer' + C] = this['cScalePeer' + C] || Di(this['cScale' + C], 10))
              : (this['cScalePeer' + C] = this['cScalePeer' + C] || Ai(this['cScale' + C], 10));
          ((this.scaleLabelColor =
            this.scaleLabelColor || (this.darkMode ? 'black' : this.labelTextColor)),
            (this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1),
            (this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++)
            this['cScaleLabel' + C] = this['cScaleLabel' + C] || this.scaleLabelColor;
          for (let C = 0; C < 5; C++)
            ((this['surface' + C] = this['surface' + C] || Ti(this.mainBkg, { l: -(5 + 5 * C) })),
              (this['surfacePeer' + C] =
                this['surfacePeer' + C] || Ti(this.mainBkg, { l: -(8 + 5 * C) })));
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.text),
            (this.sectionBkgColor = Di(this.contrast, 30)),
            (this.sectionBkgColor2 = Di(this.contrast, 30)),
            (this.taskBorderColor = Ai(this.contrast, 10)),
            (this.taskBkgColor = this.contrast),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = this.text),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.gridColor = Di(this.border1, 30)),
            (this.doneTaskBkgColor = this.done),
            (this.doneTaskBorderColor = this.lineColor),
            (this.critBkgColor = this.critical),
            (this.critBorderColor = Ai(this.critBkgColor, 10)),
            (this.todayLineColor = this.critBkgColor),
            (this.vertLineColor = this.critBkgColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || '#000'),
            (this.transitionLabelColor = this.transitionLabelColor || this.textColor),
            (this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground || this.background || this.tertiaryColor),
            (this.altBackground = this.altBackground || '#f4f4f4'),
            (this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg),
            (this.stateBorder = this.stateBorder || '#000'),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = '#222'),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor = this.errorTextColor || this.tertiaryTextColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = Ti(this.primaryColor, { h: 64 })),
            (this.fillType3 = Ti(this.secondaryColor, { h: 64 })),
            (this.fillType4 = Ti(this.primaryColor, { h: -64 })),
            (this.fillType5 = Ti(this.secondaryColor, { h: -64 })),
            (this.fillType6 = Ti(this.primaryColor, { h: 128 })),
            (this.fillType7 = Ti(this.secondaryColor, { h: 128 })));
          for (let C = 0; C < this.THEME_COLOR_LIMIT; C++) this['pie' + C] = this['cScale' + C];
          ((this.pie12 = this.pie0),
            (this.pieTitleTextSize = this.pieTitleTextSize || '25px'),
            (this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || '17px'),
            (this.pieSectionTextColor = this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || '17px'),
            (this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || 'black'),
            (this.pieStrokeWidth = this.pieStrokeWidth || '2px'),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || '2px'),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || 'black'),
            (this.pieOpacity = this.pieOpacity || '0.7'),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill || Ti(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill || Ti(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill || Ti(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill || Ti(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill || Ti(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill || Ti(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Si(this.quadrant1Fill)
                ? Di(this.quadrant1Fill)
                : Ai(this.quadrant1Fill)),
            (this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor:
                (null == (e = this.xyChart) ? void 0 : e.backgroundColor) || this.background,
              titleColor:
                (null == (t = this.xyChart) ? void 0 : t.titleColor) || this.primaryTextColor,
              xAxisTitleColor:
                (null == (r = this.xyChart) ? void 0 : r.xAxisTitleColor) || this.primaryTextColor,
              xAxisLabelColor:
                (null == (n = this.xyChart) ? void 0 : n.xAxisLabelColor) || this.primaryTextColor,
              xAxisTickColor:
                (null == (i = this.xyChart) ? void 0 : i.xAxisTickColor) || this.primaryTextColor,
              xAxisLineColor:
                (null == (a = this.xyChart) ? void 0 : a.xAxisLineColor) || this.primaryTextColor,
              yAxisTitleColor:
                (null == (o = this.xyChart) ? void 0 : o.yAxisTitleColor) || this.primaryTextColor,
              yAxisLabelColor:
                (null == (s = this.xyChart) ? void 0 : s.yAxisLabelColor) || this.primaryTextColor,
              yAxisTickColor:
                (null == (l = this.xyChart) ? void 0 : l.yAxisTickColor) || this.primaryTextColor,
              yAxisLineColor:
                (null == (c = this.xyChart) ? void 0 : c.yAxisLineColor) || this.primaryTextColor,
              plotColorPalette:
                (null == (h = this.xyChart) ? void 0 : h.plotColorPalette) ||
                '#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0',
            }),
            (this.radar = {
              axisColor: (null == (d = this.radar) ? void 0 : d.axisColor) || this.lineColor,
              axisStrokeWidth: (null == (u = this.radar) ? void 0 : u.axisStrokeWidth) || 2,
              axisLabelFontSize: (null == (p = this.radar) ? void 0 : p.axisLabelFontSize) || 12,
              curveOpacity: (null == (g = this.radar) ? void 0 : g.curveOpacity) || 0.5,
              curveStrokeWidth: (null == (f = this.radar) ? void 0 : f.curveStrokeWidth) || 2,
              graticuleColor: (null == (m = this.radar) ? void 0 : m.graticuleColor) || '#DEDEDE',
              graticuleStrokeWidth:
                (null == (b = this.radar) ? void 0 : b.graticuleStrokeWidth) || 1,
              graticuleOpacity: (null == (y = this.radar) ? void 0 : y.graticuleOpacity) || 0.3,
              legendBoxSize: (null == (x = this.radar) ? void 0 : x.legendBoxSize) || 12,
              legendFontSize: (null == (k = this.radar) ? void 0 : k.legendFontSize) || 12,
            }),
            (this.requirementBackground = this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || '1'),
            (this.requirementTextColor = this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor = this.relationLabelColor || this.actorTextColor),
            (this.git0 = Ai(this.pie1, 25) || this.primaryColor),
            (this.git1 = this.pie2 || this.secondaryColor),
            (this.git2 = this.pie3 || this.tertiaryColor),
            (this.git3 = this.pie4 || Ti(this.primaryColor, { h: -30 })),
            (this.git4 = this.pie5 || Ti(this.primaryColor, { h: -60 })),
            (this.git5 = this.pie6 || Ti(this.primaryColor, { h: -90 })),
            (this.git6 = this.pie7 || Ti(this.primaryColor, { h: 60 })),
            (this.git7 = this.pie8 || Ti(this.primaryColor, { h: 120 })),
            (this.gitInv0 = this.gitInv0 || Fi(this.git0)),
            (this.gitInv1 = this.gitInv1 || Fi(this.git1)),
            (this.gitInv2 = this.gitInv2 || Fi(this.git2)),
            (this.gitInv3 = this.gitInv3 || Fi(this.git3)),
            (this.gitInv4 = this.gitInv4 || Fi(this.git4)),
            (this.gitInv5 = this.gitInv5 || Fi(this.git5)),
            (this.gitInv6 = this.gitInv6 || Fi(this.git6)),
            (this.gitInv7 = this.gitInv7 || Fi(this.git7)),
            (this.branchLabelColor = this.branchLabelColor || this.labelTextColor),
            (this.gitBranchLabel0 = this.branchLabelColor),
            (this.gitBranchLabel1 = 'white'),
            (this.gitBranchLabel2 = this.branchLabelColor),
            (this.gitBranchLabel3 = 'white'),
            (this.gitBranchLabel4 = this.branchLabelColor),
            (this.gitBranchLabel5 = this.branchLabelColor),
            (this.gitBranchLabel6 = this.branchLabelColor),
            (this.gitBranchLabel7 = this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground = this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || '10px'),
            (this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || '10px'),
            (this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || Va),
            (this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || Za));
        }
        calculate(e) {
          if ('object' != typeof e) return void this.updateColors();
          const t = Object.keys(e);
          (t.forEach((t) => {
            this[t] = e[t];
          }),
            this.updateColors(),
            t.forEach((t) => {
              this[t] = e[t];
            }));
        }
      }),
      'Theme'
    ),
    a),
  ao = {
    base: { getThemeVariables: Xa },
    dark: { getThemeVariables: Ja },
    default: { getThemeVariables: to },
    forest: { getThemeVariables: no },
    neutral: {
      getThemeVariables: ii((e) => {
        const t = new io();
        return (t.calculate(e), t);
      }, 'getThemeVariables'),
    },
  },
  oo = {
    flowchart: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      subGraphTitleMargin: { top: 0, bottom: 0 },
      diagramPadding: 8,
      htmlLabels: !0,
      nodeSpacing: 50,
      rankSpacing: 50,
      curve: 'basis',
      padding: 15,
      defaultRenderer: 'dagre-wrapper',
      wrappingWidth: 200,
      inheritDir: !1,
    },
    sequence: {
      useMaxWidth: !0,
      hideUnusedParticipants: !1,
      activationWidth: 10,
      diagramMarginX: 50,
      diagramMarginY: 10,
      actorMargin: 50,
      width: 150,
      height: 65,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: 'center',
      mirrorActors: !0,
      forceMenus: !1,
      bottomMarginAdj: 1,
      rightAngles: !1,
      showSequenceNumbers: !1,
      actorFontSize: 14,
      actorFontFamily: '"Open Sans", sans-serif',
      actorFontWeight: 400,
      noteFontSize: 14,
      noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      noteFontWeight: 400,
      noteAlign: 'center',
      messageFontSize: 16,
      messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      messageFontWeight: 400,
      wrap: !1,
      wrapPadding: 10,
      labelBoxWidth: 50,
      labelBoxHeight: 20,
    },
    gantt: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      barHeight: 20,
      barGap: 4,
      topPadding: 50,
      rightPadding: 75,
      leftPadding: 75,
      gridLineStartPadding: 35,
      fontSize: 11,
      sectionFontSize: 11,
      numberSectionStyles: 4,
      axisFormat: '%Y-%m-%d',
      topAxis: !1,
      displayMode: '',
      weekday: 'sunday',
    },
    journey: {
      useMaxWidth: !0,
      diagramMarginX: 50,
      diagramMarginY: 10,
      leftMargin: 150,
      maxLabelWidth: 360,
      width: 150,
      height: 50,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: 'center',
      bottomMarginAdj: 1,
      rightAngles: !1,
      taskFontSize: 14,
      taskFontFamily: '"Open Sans", sans-serif',
      taskMargin: 50,
      activationWidth: 10,
      textPlacement: 'fo',
      actorColours: ['#8FBC8F', '#7CFC00', '#00FFFF', '#20B2AA', '#B0E0E6', '#FFFFE0'],
      sectionFills: ['#191970', '#8B008B', '#4B0082', '#2F4F4F', '#800000', '#8B4513', '#00008B'],
      sectionColours: ['#fff'],
      titleColor: '',
      titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      titleFontSize: '4ex',
    },
    class: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      arrowMarkerAbsolute: !1,
      dividerMargin: 10,
      padding: 5,
      textHeight: 10,
      defaultRenderer: 'dagre-wrapper',
      htmlLabels: !1,
      hideEmptyMembersBox: !1,
    },
    state: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      dividerMargin: 10,
      sizeUnit: 5,
      padding: 8,
      textHeight: 10,
      titleShift: -15,
      noteMargin: 10,
      forkWidth: 70,
      forkHeight: 7,
      miniPadding: 2,
      fontSizeFactor: 5.02,
      fontSize: 24,
      labelHeight: 16,
      edgeLengthFactor: '20',
      compositTitleSize: 35,
      radius: 5,
      defaultRenderer: 'dagre-wrapper',
    },
    er: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      diagramPadding: 20,
      layoutDirection: 'TB',
      minEntityWidth: 100,
      minEntityHeight: 75,
      entityPadding: 15,
      nodeSpacing: 140,
      rankSpacing: 80,
      stroke: 'gray',
      fill: 'honeydew',
      fontSize: 12,
    },
    pie: { useMaxWidth: !0, textPosition: 0.75 },
    quadrantChart: {
      useMaxWidth: !0,
      chartWidth: 500,
      chartHeight: 500,
      titleFontSize: 20,
      titlePadding: 10,
      quadrantPadding: 5,
      xAxisLabelPadding: 5,
      yAxisLabelPadding: 5,
      xAxisLabelFontSize: 16,
      yAxisLabelFontSize: 16,
      quadrantLabelFontSize: 16,
      quadrantTextTopPadding: 5,
      pointTextPadding: 5,
      pointLabelFontSize: 12,
      pointRadius: 5,
      xAxisPosition: 'top',
      yAxisPosition: 'left',
      quadrantInternalBorderStrokeWidth: 1,
      quadrantExternalBorderStrokeWidth: 2,
    },
    xyChart: {
      useMaxWidth: !0,
      width: 700,
      height: 500,
      titleFontSize: 20,
      titlePadding: 10,
      showDataLabel: !1,
      showTitle: !0,
      xAxis: {
        $ref: '#/$defs/XYChartAxisConfig',
        showLabel: !0,
        labelFontSize: 14,
        labelPadding: 5,
        showTitle: !0,
        titleFontSize: 16,
        titlePadding: 5,
        showTick: !0,
        tickLength: 5,
        tickWidth: 2,
        showAxisLine: !0,
        axisLineWidth: 2,
      },
      yAxis: {
        $ref: '#/$defs/XYChartAxisConfig',
        showLabel: !0,
        labelFontSize: 14,
        labelPadding: 5,
        showTitle: !0,
        titleFontSize: 16,
        titlePadding: 5,
        showTick: !0,
        tickLength: 5,
        tickWidth: 2,
        showAxisLine: !0,
        axisLineWidth: 2,
      },
      chartOrientation: 'vertical',
      plotReservedSpacePercent: 50,
    },
    requirement: {
      useMaxWidth: !0,
      rect_fill: '#f9f9f9',
      text_color: '#333',
      rect_border_size: '0.5px',
      rect_border_color: '#bbb',
      rect_min_width: 200,
      rect_min_height: 200,
      fontSize: 14,
      rect_padding: 10,
      line_height: 20,
    },
    mindmap: { useMaxWidth: !0, padding: 10, maxNodeWidth: 200, layoutAlgorithm: 'cose-bilkent' },
    kanban: { useMaxWidth: !0, padding: 8, sectionWidth: 200, ticketBaseUrl: '' },
    timeline: {
      useMaxWidth: !0,
      diagramMarginX: 50,
      diagramMarginY: 10,
      leftMargin: 150,
      width: 150,
      height: 50,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: 'center',
      bottomMarginAdj: 1,
      rightAngles: !1,
      taskFontSize: 14,
      taskFontFamily: '"Open Sans", sans-serif',
      taskMargin: 50,
      activationWidth: 10,
      textPlacement: 'fo',
      actorColours: ['#8FBC8F', '#7CFC00', '#00FFFF', '#20B2AA', '#B0E0E6', '#FFFFE0'],
      sectionFills: ['#191970', '#8B008B', '#4B0082', '#2F4F4F', '#800000', '#8B4513', '#00008B'],
      sectionColours: ['#fff'],
      disableMulticolor: !1,
    },
    gitGraph: {
      useMaxWidth: !0,
      titleTopMargin: 25,
      diagramPadding: 8,
      nodeLabel: { width: 75, height: 100, x: -25, y: 0 },
      mainBranchName: 'main',
      mainBranchOrder: 0,
      showCommitLabel: !0,
      showBranches: !0,
      rotateCommitLabel: !0,
      parallelCommits: !1,
      arrowMarkerAbsolute: !1,
    },
    c4: {
      useMaxWidth: !0,
      diagramMarginX: 50,
      diagramMarginY: 10,
      c4ShapeMargin: 50,
      c4ShapePadding: 20,
      width: 216,
      height: 60,
      boxMargin: 10,
      c4ShapeInRow: 4,
      nextLinePaddingX: 0,
      c4BoundaryInRow: 2,
      personFontSize: 14,
      personFontFamily: '"Open Sans", sans-serif',
      personFontWeight: 'normal',
      external_personFontSize: 14,
      external_personFontFamily: '"Open Sans", sans-serif',
      external_personFontWeight: 'normal',
      systemFontSize: 14,
      systemFontFamily: '"Open Sans", sans-serif',
      systemFontWeight: 'normal',
      external_systemFontSize: 14,
      external_systemFontFamily: '"Open Sans", sans-serif',
      external_systemFontWeight: 'normal',
      system_dbFontSize: 14,
      system_dbFontFamily: '"Open Sans", sans-serif',
      system_dbFontWeight: 'normal',
      external_system_dbFontSize: 14,
      external_system_dbFontFamily: '"Open Sans", sans-serif',
      external_system_dbFontWeight: 'normal',
      system_queueFontSize: 14,
      system_queueFontFamily: '"Open Sans", sans-serif',
      system_queueFontWeight: 'normal',
      external_system_queueFontSize: 14,
      external_system_queueFontFamily: '"Open Sans", sans-serif',
      external_system_queueFontWeight: 'normal',
      boundaryFontSize: 14,
      boundaryFontFamily: '"Open Sans", sans-serif',
      boundaryFontWeight: 'normal',
      messageFontSize: 12,
      messageFontFamily: '"Open Sans", sans-serif',
      messageFontWeight: 'normal',
      containerFontSize: 14,
      containerFontFamily: '"Open Sans", sans-serif',
      containerFontWeight: 'normal',
      external_containerFontSize: 14,
      external_containerFontFamily: '"Open Sans", sans-serif',
      external_containerFontWeight: 'normal',
      container_dbFontSize: 14,
      container_dbFontFamily: '"Open Sans", sans-serif',
      container_dbFontWeight: 'normal',
      external_container_dbFontSize: 14,
      external_container_dbFontFamily: '"Open Sans", sans-serif',
      external_container_dbFontWeight: 'normal',
      container_queueFontSize: 14,
      container_queueFontFamily: '"Open Sans", sans-serif',
      container_queueFontWeight: 'normal',
      external_container_queueFontSize: 14,
      external_container_queueFontFamily: '"Open Sans", sans-serif',
      external_container_queueFontWeight: 'normal',
      componentFontSize: 14,
      componentFontFamily: '"Open Sans", sans-serif',
      componentFontWeight: 'normal',
      external_componentFontSize: 14,
      external_componentFontFamily: '"Open Sans", sans-serif',
      external_componentFontWeight: 'normal',
      component_dbFontSize: 14,
      component_dbFontFamily: '"Open Sans", sans-serif',
      component_dbFontWeight: 'normal',
      external_component_dbFontSize: 14,
      external_component_dbFontFamily: '"Open Sans", sans-serif',
      external_component_dbFontWeight: 'normal',
      component_queueFontSize: 14,
      component_queueFontFamily: '"Open Sans", sans-serif',
      component_queueFontWeight: 'normal',
      external_component_queueFontSize: 14,
      external_component_queueFontFamily: '"Open Sans", sans-serif',
      external_component_queueFontWeight: 'normal',
      wrap: !0,
      wrapPadding: 10,
      person_bg_color: '#08427B',
      person_border_color: '#073B6F',
      external_person_bg_color: '#686868',
      external_person_border_color: '#8A8A8A',
      system_bg_color: '#1168BD',
      system_border_color: '#3C7FC0',
      system_db_bg_color: '#1168BD',
      system_db_border_color: '#3C7FC0',
      system_queue_bg_color: '#1168BD',
      system_queue_border_color: '#3C7FC0',
      external_system_bg_color: '#999999',
      external_system_border_color: '#8A8A8A',
      external_system_db_bg_color: '#999999',
      external_system_db_border_color: '#8A8A8A',
      external_system_queue_bg_color: '#999999',
      external_system_queue_border_color: '#8A8A8A',
      container_bg_color: '#438DD5',
      container_border_color: '#3C7FC0',
      container_db_bg_color: '#438DD5',
      container_db_border_color: '#3C7FC0',
      container_queue_bg_color: '#438DD5',
      container_queue_border_color: '#3C7FC0',
      external_container_bg_color: '#B3B3B3',
      external_container_border_color: '#A6A6A6',
      external_container_db_bg_color: '#B3B3B3',
      external_container_db_border_color: '#A6A6A6',
      external_container_queue_bg_color: '#B3B3B3',
      external_container_queue_border_color: '#A6A6A6',
      component_bg_color: '#85BBF0',
      component_border_color: '#78A8D8',
      component_db_bg_color: '#85BBF0',
      component_db_border_color: '#78A8D8',
      component_queue_bg_color: '#85BBF0',
      component_queue_border_color: '#78A8D8',
      external_component_bg_color: '#CCCCCC',
      external_component_border_color: '#BFBFBF',
      external_component_db_bg_color: '#CCCCCC',
      external_component_db_border_color: '#BFBFBF',
      external_component_queue_bg_color: '#CCCCCC',
      external_component_queue_border_color: '#BFBFBF',
    },
    sankey: {
      useMaxWidth: !0,
      width: 600,
      height: 400,
      linkColor: 'gradient',
      nodeAlignment: 'justify',
      showValues: !0,
      prefix: '',
      suffix: '',
    },
    block: { useMaxWidth: !0, padding: 8 },
    packet: {
      useMaxWidth: !0,
      rowHeight: 32,
      bitWidth: 32,
      bitsPerRow: 32,
      showBits: !0,
      paddingX: 5,
      paddingY: 5,
    },
    architecture: { useMaxWidth: !0, padding: 40, iconSize: 80, fontSize: 16 },
    radar: {
      useMaxWidth: !0,
      width: 600,
      height: 600,
      marginTop: 50,
      marginRight: 50,
      marginBottom: 50,
      marginLeft: 50,
      axisScaleFactor: 1,
      axisLabelFactor: 1.05,
      curveTension: 0.17,
    },
    theme: 'default',
    look: 'classic',
    handDrawnSeed: 0,
    layout: 'dagre',
    maxTextSize: 5e4,
    maxEdges: 500,
    darkMode: !1,
    fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
    logLevel: 5,
    securityLevel: 'strict',
    startOnLoad: !0,
    arrowMarkerAbsolute: !1,
    secure: [
      'secure',
      'securityLevel',
      'startOnLoad',
      'maxTextSize',
      'suppressErrorRendering',
      'maxEdges',
    ],
    legacyMathML: !1,
    forceLegacyMathML: !1,
    deterministicIds: !1,
    fontSize: 16,
    markdownAutoWrap: !0,
    suppressErrorRendering: !1,
  },
  so = {
    ...oo,
    deterministicIDSeed: void 0,
    elk: {
      mergeEdges: !1,
      nodePlacementStrategy: 'BRANDES_KOEPF',
      forceNodeModelOrder: !1,
      considerModelOrder: 'NODES_AND_EDGES',
    },
    themeCSS: void 0,
    themeVariables: ao.default.getThemeVariables(),
    sequence: {
      ...oo.sequence,
      messageFont: ii(function () {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight,
        };
      }, 'messageFont'),
      noteFont: ii(function () {
        return {
          fontFamily: this.noteFontFamily,
          fontSize: this.noteFontSize,
          fontWeight: this.noteFontWeight,
        };
      }, 'noteFont'),
      actorFont: ii(function () {
        return {
          fontFamily: this.actorFontFamily,
          fontSize: this.actorFontSize,
          fontWeight: this.actorFontWeight,
        };
      }, 'actorFont'),
    },
    class: { hideEmptyMembersBox: !1 },
    gantt: { ...oo.gantt, tickInterval: void 0, useWidth: void 0 },
    c4: {
      ...oo.c4,
      useWidth: void 0,
      personFont: ii(function () {
        return {
          fontFamily: this.personFontFamily,
          fontSize: this.personFontSize,
          fontWeight: this.personFontWeight,
        };
      }, 'personFont'),
      flowchart: { ...oo.flowchart, inheritDir: !1 },
      external_personFont: ii(function () {
        return {
          fontFamily: this.external_personFontFamily,
          fontSize: this.external_personFontSize,
          fontWeight: this.external_personFontWeight,
        };
      }, 'external_personFont'),
      systemFont: ii(function () {
        return {
          fontFamily: this.systemFontFamily,
          fontSize: this.systemFontSize,
          fontWeight: this.systemFontWeight,
        };
      }, 'systemFont'),
      external_systemFont: ii(function () {
        return {
          fontFamily: this.external_systemFontFamily,
          fontSize: this.external_systemFontSize,
          fontWeight: this.external_systemFontWeight,
        };
      }, 'external_systemFont'),
      system_dbFont: ii(function () {
        return {
          fontFamily: this.system_dbFontFamily,
          fontSize: this.system_dbFontSize,
          fontWeight: this.system_dbFontWeight,
        };
      }, 'system_dbFont'),
      external_system_dbFont: ii(function () {
        return {
          fontFamily: this.external_system_dbFontFamily,
          fontSize: this.external_system_dbFontSize,
          fontWeight: this.external_system_dbFontWeight,
        };
      }, 'external_system_dbFont'),
      system_queueFont: ii(function () {
        return {
          fontFamily: this.system_queueFontFamily,
          fontSize: this.system_queueFontSize,
          fontWeight: this.system_queueFontWeight,
        };
      }, 'system_queueFont'),
      external_system_queueFont: ii(function () {
        return {
          fontFamily: this.external_system_queueFontFamily,
          fontSize: this.external_system_queueFontSize,
          fontWeight: this.external_system_queueFontWeight,
        };
      }, 'external_system_queueFont'),
      containerFont: ii(function () {
        return {
          fontFamily: this.containerFontFamily,
          fontSize: this.containerFontSize,
          fontWeight: this.containerFontWeight,
        };
      }, 'containerFont'),
      external_containerFont: ii(function () {
        return {
          fontFamily: this.external_containerFontFamily,
          fontSize: this.external_containerFontSize,
          fontWeight: this.external_containerFontWeight,
        };
      }, 'external_containerFont'),
      container_dbFont: ii(function () {
        return {
          fontFamily: this.container_dbFontFamily,
          fontSize: this.container_dbFontSize,
          fontWeight: this.container_dbFontWeight,
        };
      }, 'container_dbFont'),
      external_container_dbFont: ii(function () {
        return {
          fontFamily: this.external_container_dbFontFamily,
          fontSize: this.external_container_dbFontSize,
          fontWeight: this.external_container_dbFontWeight,
        };
      }, 'external_container_dbFont'),
      container_queueFont: ii(function () {
        return {
          fontFamily: this.container_queueFontFamily,
          fontSize: this.container_queueFontSize,
          fontWeight: this.container_queueFontWeight,
        };
      }, 'container_queueFont'),
      external_container_queueFont: ii(function () {
        return {
          fontFamily: this.external_container_queueFontFamily,
          fontSize: this.external_container_queueFontSize,
          fontWeight: this.external_container_queueFontWeight,
        };
      }, 'external_container_queueFont'),
      componentFont: ii(function () {
        return {
          fontFamily: this.componentFontFamily,
          fontSize: this.componentFontSize,
          fontWeight: this.componentFontWeight,
        };
      }, 'componentFont'),
      external_componentFont: ii(function () {
        return {
          fontFamily: this.external_componentFontFamily,
          fontSize: this.external_componentFontSize,
          fontWeight: this.external_componentFontWeight,
        };
      }, 'external_componentFont'),
      component_dbFont: ii(function () {
        return {
          fontFamily: this.component_dbFontFamily,
          fontSize: this.component_dbFontSize,
          fontWeight: this.component_dbFontWeight,
        };
      }, 'component_dbFont'),
      external_component_dbFont: ii(function () {
        return {
          fontFamily: this.external_component_dbFontFamily,
          fontSize: this.external_component_dbFontSize,
          fontWeight: this.external_component_dbFontWeight,
        };
      }, 'external_component_dbFont'),
      component_queueFont: ii(function () {
        return {
          fontFamily: this.component_queueFontFamily,
          fontSize: this.component_queueFontSize,
          fontWeight: this.component_queueFontWeight,
        };
      }, 'component_queueFont'),
      external_component_queueFont: ii(function () {
        return {
          fontFamily: this.external_component_queueFontFamily,
          fontSize: this.external_component_queueFontSize,
          fontWeight: this.external_component_queueFontWeight,
        };
      }, 'external_component_queueFont'),
      boundaryFont: ii(function () {
        return {
          fontFamily: this.boundaryFontFamily,
          fontSize: this.boundaryFontSize,
          fontWeight: this.boundaryFontWeight,
        };
      }, 'boundaryFont'),
      messageFont: ii(function () {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight,
        };
      }, 'messageFont'),
    },
    pie: { ...oo.pie, useWidth: 984 },
    xyChart: { ...oo.xyChart, useWidth: void 0 },
    requirement: { ...oo.requirement, useWidth: void 0 },
    packet: { ...oo.packet },
    radar: { ...oo.radar },
    treemap: {
      useMaxWidth: !0,
      padding: 10,
      diagramPadding: 8,
      showValues: !0,
      nodeWidth: 100,
      nodeHeight: 40,
      borderWidth: 1,
      valueFontSize: 12,
      labelFontSize: 14,
      valueFormat: ',',
    },
  },
  lo = ii(
    (e, t = '') =>
      Object.keys(e).reduce(
        (r, n) =>
          Array.isArray(e[n])
            ? r
            : 'object' == typeof e[n] && null !== e[n]
              ? [...r, t + n, ...lo(e[n], '')]
              : [...r, t + n],
        []
      ),
    'keyify'
  ),
  co = new Set(lo(so, '')),
  ho = so,
  uo = ii((e) => {
    if ((si.debug('sanitizeDirective called with', e), 'object' == typeof e && null != e))
      if (Array.isArray(e)) e.forEach((e) => uo(e));
      else {
        for (const t of Object.keys(e)) {
          if (
            (si.debug('Checking key', t),
            t.startsWith('__') ||
              t.includes('proto') ||
              t.includes('constr') ||
              !co.has(t) ||
              null == e[t])
          ) {
            (si.debug('sanitize deleting key: ', t), delete e[t]);
            continue;
          }
          if ('object' == typeof e[t]) {
            (si.debug('sanitizing object', t), uo(e[t]));
            continue;
          }
          const r = ['themeCSS', 'fontFamily', 'altFontFamily'];
          for (const n of r)
            t.includes(n) && (si.debug('sanitizing css option', t), (e[t] = po(e[t])));
        }
        if (e.themeVariables)
          for (const t of Object.keys(e.themeVariables)) {
            const r = e.themeVariables[t];
            (null == r ? void 0 : r.match) &&
              !r.match(/^[\d "#%(),.;A-Za-z]+$/) &&
              (e.themeVariables[t] = '');
          }
        si.debug('After sanitization', e);
      }
  }, 'sanitizeDirective'),
  po = ii((e) => {
    let t = 0,
      r = 0;
    for (const n of e) {
      if (t < r) return '{ /* ERROR: Unbalanced CSS */ }';
      '{' === n ? t++ : '}' === n && r++;
    }
    return t !== r ? '{ /* ERROR: Unbalanced CSS */ }' : e;
  }, 'sanitizeCss'),
  go = Object.freeze(ho),
  fo = Ga({}, go),
  mo = [],
  bo = Ga({}, go),
  yo = ii((e, t) => {
    let r = Ga({}, e),
      n = {};
    for (const i of t) (So(i), (n = Ga(n, i)));
    if (((r = Ga(r, n)), n.theme && n.theme in ao)) {
      const e = Ga({}, La),
        t = Ga(e.themeVariables || {}, n.themeVariables);
      r.theme && r.theme in ao && (r.themeVariables = ao[r.theme].getThemeVariables(t));
    }
    return (Bo((bo = r)), bo);
  }, 'updateCurrentConfig'),
  xo = ii(
    (e) => (
      (fo = Ga({}, go)),
      (fo = Ga(fo, e)),
      e.theme &&
        ao[e.theme] &&
        (fo.themeVariables = ao[e.theme].getThemeVariables(e.themeVariables)),
      yo(fo, mo),
      fo
    ),
    'setSiteConfig'
  ),
  ko = ii((e) => {
    La = Ga({}, e);
  }, 'saveConfigFromInitialize'),
  Co = ii((e) => ((fo = Ga(fo, e)), yo(fo, mo), fo), 'updateSiteConfig'),
  wo = ii(() => Ga({}, fo), 'getSiteConfig'),
  vo = ii((e) => (Bo(e), Ga(bo, e), _o()), 'setConfig'),
  _o = ii(() => Ga({}, bo), 'getConfig'),
  So = ii((e) => {
    e &&
      (['secure', ...(fo.secure ?? [])].forEach((t) => {
        Object.hasOwn(e, t) &&
          (si.debug(`Denied attempt to modify a secure key ${t}`, e[t]), delete e[t]);
      }),
      Object.keys(e).forEach((t) => {
        t.startsWith('__') && delete e[t];
      }),
      Object.keys(e).forEach((t) => {
        ('string' == typeof e[t] &&
          (e[t].includes('<') || e[t].includes('>') || e[t].includes('url(data:')) &&
          delete e[t],
          'object' == typeof e[t] && So(e[t]));
      }));
  }, 'sanitize'),
  Eo = ii((e) => {
    var t;
    (uo(e),
      e.fontFamily &&
        !(null == (t = e.themeVariables) ? void 0 : t.fontFamily) &&
        (e.themeVariables = { ...e.themeVariables, fontFamily: e.fontFamily }),
      mo.push(e),
      yo(fo, mo));
  }, 'addDirective'),
  Do = ii((e = fo) => {
    yo(e, (mo = []));
  }, 'reset'),
  Ao = {
    LAZY_LOAD_DEPRECATED:
      'The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.',
  },
  To = {},
  Fo = ii((e) => {
    To[e] || (si.warn(Ao[e]), (To[e] = !0));
  }, 'issueWarning'),
  Bo = ii((e) => {
    e && (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) && Fo('LAZY_LOAD_DEPRECATED');
  }, 'checkConfig'),
  Mo = ii(() => {
    let e = {};
    La && (e = Ga(e, La));
    for (const t of mo) e = Ga(e, t);
    return e;
  }, 'getUserDefinedConfig'),
  No = /<br\s*\/?>/gi,
  Lo = ii((e) => {
    if (!e) return [''];
    return Uo(e).replace(/\\n/g, '#br#').split('#br#');
  }, 'getRows'),
  Oo = (() => {
    let e = !1;
    return () => {
      e || ($o(), (e = !0));
    };
  })();
function $o() {
  const e = 'data-temp-href-target';
  (Oa.addHook('beforeSanitizeAttributes', (t) => {
    'A' === t.tagName &&
      t.hasAttribute('target') &&
      t.setAttribute(e, t.getAttribute('target') ?? '');
  }),
    Oa.addHook('afterSanitizeAttributes', (t) => {
      'A' === t.tagName &&
        t.hasAttribute(e) &&
        (t.setAttribute('target', t.getAttribute(e) ?? ''),
        t.removeAttribute(e),
        '_blank' === t.getAttribute('target') && t.setAttribute('rel', 'noopener'));
    }));
}
ii($o, 'setupDompurifyHooks');
var Io = ii((e) => {
    Oo();
    return Oa.sanitize(e);
  }, 'removeScript'),
  Ro = ii((e, t) => {
    var r;
    if (!1 !== (null == (r = t.flowchart) ? void 0 : r.htmlLabels)) {
      const r = t.securityLevel;
      'antiscript' === r || 'strict' === r
        ? (e = Io(e))
        : 'loose' !== r &&
          ((e = (e = (e = Uo(e)).replace(/</g, '&lt;').replace(/>/g, '&gt;')).replace(
            /=/g,
            '&equals;'
          )),
          (e = Wo(e)));
    }
    return e;
  }, 'sanitizeMore'),
  zo = ii(
    (e, t) =>
      e
        ? (e = t.dompurifyConfig
            ? Oa.sanitize(Ro(e, t), t.dompurifyConfig).toString()
            : Oa.sanitize(Ro(e, t), { FORBID_TAGS: ['style'] }).toString())
        : e,
    'sanitizeText'
  ),
  Po = ii(
    (e, t) => ('string' == typeof e ? zo(e, t) : e.flat().map((e) => zo(e, t))),
    'sanitizeTextOrArray'
  ),
  jo = ii((e) => No.test(e), 'hasBreaks'),
  qo = ii((e) => e.split(No), 'splitBreaks'),
  Wo = ii((e) => e.replace(/#br#/g, '<br/>'), 'placeholderToBreak'),
  Uo = ii((e) => e.replace(No, '#br#'), 'breakToPlaceholder'),
  Ho = ii((e) => {
    let t = '';
    return (
      e &&
        ((t =
          window.location.protocol +
          '//' +
          window.location.host +
          window.location.pathname +
          window.location.search),
        (t = CSS.escape(t))),
      t
    );
  }, 'getUrl'),
  Go = ii(
    (e) => !1 !== e && !['false', 'null', '0'].includes(String(e).trim().toLowerCase()),
    'evaluate'
  ),
  Vo = ii(function (...e) {
    const t = e.filter((e) => !isNaN(e));
    return Math.max(...t);
  }, 'getMax'),
  Zo = ii(function (...e) {
    const t = e.filter((e) => !isNaN(e));
    return Math.min(...t);
  }, 'getMin'),
  Ko = ii(function (e) {
    const t = e.split(/(,)/),
      r = [];
    for (let n = 0; n < t.length; n++) {
      let e = t[n];
      if (',' === e && n > 0 && n + 1 < t.length) {
        const i = t[n - 1],
          a = t[n + 1];
        Xo(i, a) && ((e = i + ',' + a), n++, r.pop());
      }
      r.push(Qo(e));
    }
    return r.join('');
  }, 'parseGenericTypes'),
  Yo = ii((e, t) => Math.max(0, e.split(t).length - 1), 'countOccurrence'),
  Xo = ii((e, t) => {
    const r = Yo(e, '~'),
      n = Yo(t, '~');
    return 1 === r && 1 === n;
  }, 'shouldCombineSets'),
  Qo = ii((e) => {
    const t = Yo(e, '~');
    let r = !1;
    if (t <= 1) return e;
    t % 2 != 0 && e.startsWith('~') && ((e = e.substring(1)), (r = !0));
    const n = [...e];
    let i = n.indexOf('~'),
      a = n.lastIndexOf('~');
    for (; -1 !== i && -1 !== a && i !== a; )
      ((n[i] = '<'), (n[a] = '>'), (i = n.indexOf('~')), (a = n.lastIndexOf('~')));
    return (r && n.unshift('~'), n.join(''));
  }, 'processSet'),
  Jo = ii(() => void 0 !== window.MathMLElement, 'isMathMLSupported'),
  es = /\$\$(.*)\$\$/g,
  ts = ii((e) => {
    var t;
    return ((null == (t = e.match(es)) ? void 0 : t.length) ?? 0) > 0;
  }, 'hasKatex'),
  rs = ii(async (e, t) => {
    const r = document.createElement('div');
    ((r.innerHTML = await is(e, t)),
      (r.id = 'katex-temp'),
      (r.style.visibility = 'hidden'),
      (r.style.position = 'absolute'),
      (r.style.top = '0'));
    const n = document.querySelector('body');
    null == n || n.insertAdjacentElement('beforeend', r);
    const i = { width: r.clientWidth, height: r.clientHeight };
    return (r.remove(), i);
  }, 'calculateMathMLDimensions'),
  ns = ii(async (e, t) => {
    if (!ts(e)) return e;
    if (!(Jo() || t.legacyMathML || t.forceLegacyMathML))
      return e.replace(es, 'MathML is unsupported in this environment.');
    {
      const { default: r } = await v(async () => {
          const { default: e } = await import('./katex-CtI-vZzQ.js');
          return { default: e };
        }, []),
        n = t.forceLegacyMathML || (!Jo() && t.legacyMathML) ? 'htmlAndMathml' : 'mathml';
      return e
        .split(No)
        .map((e) =>
          ts(e)
            ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${e}</div>`
            : `<div>${e}</div>`
        )
        .join('')
        .replace(es, (e, t) =>
          r
            .renderToString(t, { throwOnError: !0, displayMode: !0, output: n })
            .replace(/\n/g, ' ')
            .replace(/<annotation.*<\/annotation>/g, '')
        );
    }
  }, 'renderKatexUnsanitized'),
  is = ii(async (e, t) => zo(await ns(e, t), t), 'renderKatexSanitized'),
  as = {
    getRows: Lo,
    sanitizeText: zo,
    sanitizeTextOrArray: Po,
    hasBreaks: jo,
    splitBreaks: qo,
    lineBreakRegex: No,
    removeScript: Io,
    getUrl: Ho,
    evaluate: Go,
    getMax: Vo,
    getMin: Zo,
  },
  os = ii(function (e, t) {
    for (let r of t) e.attr(r[0], r[1]);
  }, 'd3Attrs'),
  ss = ii(function (e, t, r) {
    let n = new Map();
    return (
      r
        ? (n.set('width', '100%'), n.set('style', `max-width: ${t}px;`))
        : (n.set('height', e), n.set('width', t)),
      n
    );
  }, 'calculateSvgSizeAttrs'),
  ls = ii(function (e, t, r, n) {
    const i = ss(t, r, n);
    os(e, i);
  }, 'configureSvgSize'),
  cs = ii(function (e, t, r, n) {
    const i = t.node().getBBox(),
      a = i.width,
      o = i.height;
    si.info(`SVG bounds: ${a}x${o}`, i);
    let s = 0,
      l = 0;
    (si.info(`Graph bounds: ${s}x${l}`, e),
      (s = a + 2 * r),
      (l = o + 2 * r),
      si.info(`Calculated bounds: ${s}x${l}`),
      ls(t, l, s, n));
    const c = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
    t.attr('viewBox', c);
  }, 'setupGraphViewbox'),
  hs = {},
  ds = ii((e, t, r) => {
    let n = '';
    return (
      e in hs && hs[e] ? (n = hs[e](r)) : si.warn(`No theme found for ${e}`),
      ` & {\n    font-family: ${r.fontFamily};\n    font-size: ${r.fontSize};\n    fill: ${r.textColor}\n  }\n  @keyframes edge-animation-frame {\n    from {\n      stroke-dashoffset: 0;\n    }\n  }\n  @keyframes dash {\n    to {\n      stroke-dashoffset: 0;\n    }\n  }\n  & .edge-animation-slow {\n    stroke-dasharray: 9,5 !important;\n    stroke-dashoffset: 900;\n    animation: dash 50s linear infinite;\n    stroke-linecap: round;\n  }\n  & .edge-animation-fast {\n    stroke-dasharray: 9,5 !important;\n    stroke-dashoffset: 900;\n    animation: dash 20s linear infinite;\n    stroke-linecap: round;\n  }\n  /* Classes common for multiple diagrams */\n\n  & .error-icon {\n    fill: ${r.errorBkgColor};\n  }\n  & .error-text {\n    fill: ${r.errorTextColor};\n    stroke: ${r.errorTextColor};\n  }\n\n  & .edge-thickness-normal {\n    stroke-width: 1px;\n  }\n  & .edge-thickness-thick {\n    stroke-width: 3.5px\n  }\n  & .edge-pattern-solid {\n    stroke-dasharray: 0;\n  }\n  & .edge-thickness-invisible {\n    stroke-width: 0;\n    fill: none;\n  }\n  & .edge-pattern-dashed{\n    stroke-dasharray: 3;\n  }\n  .edge-pattern-dotted {\n    stroke-dasharray: 2;\n  }\n\n  & .marker {\n    fill: ${r.lineColor};\n    stroke: ${r.lineColor};\n  }\n  & .marker.cross {\n    stroke: ${r.lineColor};\n  }\n\n  & svg {\n    font-family: ${r.fontFamily};\n    font-size: ${r.fontSize};\n  }\n   & p {\n    margin: 0\n   }\n\n  ${n}\n\n  ${t}\n`
    );
  }, 'getStyles'),
  us = ii((e, t) => {
    void 0 !== t && (hs[e] = t);
  }, 'addStylesForDiagram'),
  ps = ds,
  gs = {};
ai(gs, {
  clear: () => xs,
  getAccDescription: () => vs,
  getAccTitle: () => Cs,
  getDiagramTitle: () => Ss,
  setAccDescription: () => ws,
  setAccTitle: () => ks,
  setDiagramTitle: () => _s,
});
var fs = '',
  ms = '',
  bs = '',
  ys = ii((e) => zo(e, _o()), 'sanitizeText'),
  xs = ii(() => {
    ((fs = ''), (bs = ''), (ms = ''));
  }, 'clear'),
  ks = ii((e) => {
    fs = ys(e).replace(/^\s+/g, '');
  }, 'setAccTitle'),
  Cs = ii(() => fs, 'getAccTitle'),
  ws = ii((e) => {
    bs = ys(e).replace(/\n\s+/g, '\n');
  }, 'setAccDescription'),
  vs = ii(() => bs, 'getAccDescription'),
  _s = ii((e) => {
    ms = ys(e);
  }, 'setDiagramTitle'),
  Ss = ii(() => ms, 'getDiagramTitle'),
  Es = si,
  Ds = li,
  As = _o,
  Ts = vo,
  Fs = go,
  Bs = ii((e) => zo(e, As()), 'sanitizeText'),
  Ms = cs,
  Ns = ii(() => gs, 'getCommonDb'),
  Ls = {},
  Os = ii((e, t, r) => {
    var n;
    (Ls[e] && Es.warn(`Diagram with id ${e} already registered. Overwriting.`),
      (Ls[e] = t),
      r && Wa(e, r),
      us(e, t.styles),
      null == (n = t.injectUtils) || n.call(t, Es, Ds, As, Bs, Ms, Ns(), () => {}));
  }, 'registerDiagram'),
  $s = ii((e) => {
    if (e in Ls) return Ls[e];
    throw new Is(e);
  }, 'getDiagram'),
  Is =
    ((o = class extends Error {
      constructor(e) {
        super(`Diagram ${e} not found.`);
      }
    }),
    ii(o, 'DiagramNotFoundError'),
    o),
  Rs = ii((e) => {
    var t;
    const { securityLevel: r } = As();
    let n = S('body');
    if ('sandbox' === r) {
      const r = (null == (t = S(`#i${e}`).node()) ? void 0 : t.contentDocument) ?? document;
      n = S(r.body);
    }
    return n.select(`#${e}`);
  }, 'selectSvgElement');
function zs(e) {
  return null == e;
}
function Ps(e) {
  return 'object' == typeof e && null !== e;
}
function js(e) {
  return Array.isArray(e) ? e : zs(e) ? [] : [e];
}
function qs(e, t) {
  var r, n, i, a;
  if (t) for (r = 0, n = (a = Object.keys(t)).length; r < n; r += 1) e[(i = a[r])] = t[i];
  return e;
}
function Ws(e, t) {
  var r,
    n = '';
  for (r = 0; r < t; r += 1) n += e;
  return n;
}
function Us(e) {
  return 0 === e && Number.NEGATIVE_INFINITY === 1 / e;
}
(ii(zs, 'isNothing'),
  ii(Ps, 'isObject'),
  ii(js, 'toArray'),
  ii(qs, 'extend'),
  ii(Ws, 'repeat'),
  ii(Us, 'isNegativeZero'));
var Hs = { isNothing: zs, isObject: Ps, toArray: js, repeat: Ws, isNegativeZero: Us, extend: qs };
function Gs(e, t) {
  var r = '',
    n = e.reason || '(unknown reason)';
  return e.mark
    ? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
      (r += '(' + (e.mark.line + 1) + ':' + (e.mark.column + 1) + ')'),
      !t && e.mark.snippet && (r += '\n\n' + e.mark.snippet),
      n + ' ' + r)
    : n;
}
function Vs(e, t) {
  (Error.call(this),
    (this.name = 'YAMLException'),
    (this.reason = e),
    (this.mark = t),
    (this.message = Gs(this, !1)),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack || ''));
}
(ii(Gs, 'formatError'),
  ii(Vs, 'YAMLException$1'),
  (Vs.prototype = Object.create(Error.prototype)),
  (Vs.prototype.constructor = Vs),
  (Vs.prototype.toString = ii(function (e) {
    return this.name + ': ' + Gs(this, e);
  }, 'toString')));
var Zs = Vs;
function Ks(e, t, r, n, i) {
  var a = '',
    o = '',
    s = Math.floor(i / 2) - 1;
  return (
    n - t > s && (t = n - s + (a = ' ... ').length),
    r - n > s && (r = n + s - (o = ' ...').length),
    { str: a + e.slice(t, r).replace(/\t/g, '→') + o, pos: n - t + a.length }
  );
}
function Ys(e, t) {
  return Hs.repeat(' ', t - e.length) + e;
}
function Xs(e, t) {
  if (((t = Object.create(t || null)), !e.buffer)) return null;
  (t.maxLength || (t.maxLength = 79),
    'number' != typeof t.indent && (t.indent = 1),
    'number' != typeof t.linesBefore && (t.linesBefore = 3),
    'number' != typeof t.linesAfter && (t.linesAfter = 2));
  for (var r, n = /\r?\n|\r|\0/g, i = [0], a = [], o = -1; (r = n.exec(e.buffer)); )
    (a.push(r.index),
      i.push(r.index + r[0].length),
      e.position <= r.index && o < 0 && (o = i.length - 2));
  o < 0 && (o = i.length - 1);
  var s,
    l,
    c = '',
    h = Math.min(e.line + t.linesAfter, a.length).toString().length,
    d = t.maxLength - (t.indent + h + 3);
  for (s = 1; s <= t.linesBefore && !(o - s < 0); s++)
    ((l = Ks(e.buffer, i[o - s], a[o - s], e.position - (i[o] - i[o - s]), d)),
      (c =
        Hs.repeat(' ', t.indent) + Ys((e.line - s + 1).toString(), h) + ' | ' + l.str + '\n' + c));
  for (
    l = Ks(e.buffer, i[o], a[o], e.position, d),
      c += Hs.repeat(' ', t.indent) + Ys((e.line + 1).toString(), h) + ' | ' + l.str + '\n',
      c += Hs.repeat('-', t.indent + h + 3 + l.pos) + '^\n',
      s = 1;
    s <= t.linesAfter && !(o + s >= a.length);
    s++
  )
    ((l = Ks(e.buffer, i[o + s], a[o + s], e.position - (i[o] - i[o + s]), d)),
      (c += Hs.repeat(' ', t.indent) + Ys((e.line + s + 1).toString(), h) + ' | ' + l.str + '\n'));
  return c.replace(/\n$/, '');
}
(ii(Ks, 'getLine'), ii(Ys, 'padStart'), ii(Xs, 'makeSnippet'));
var Qs = Xs,
  Js = [
    'kind',
    'multi',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'representName',
    'defaultStyle',
    'styleAliases',
  ],
  el = ['scalar', 'sequence', 'mapping'];
function tl(e) {
  var t = {};
  return (
    null !== e &&
      Object.keys(e).forEach(function (r) {
        e[r].forEach(function (e) {
          t[String(e)] = r;
        });
      }),
    t
  );
}
function rl(e, t) {
  if (
    ((t = t || {}),
    Object.keys(t).forEach(function (t) {
      if (-1 === Js.indexOf(t))
        throw new Zs('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.');
    }),
    (this.options = t),
    (this.tag = e),
    (this.kind = t.kind || null),
    (this.resolve =
      t.resolve ||
      function () {
        return !0;
      }),
    (this.construct =
      t.construct ||
      function (e) {
        return e;
      }),
    (this.instanceOf = t.instanceOf || null),
    (this.predicate = t.predicate || null),
    (this.represent = t.represent || null),
    (this.representName = t.representName || null),
    (this.defaultStyle = t.defaultStyle || null),
    (this.multi = t.multi || !1),
    (this.styleAliases = tl(t.styleAliases || null)),
    -1 === el.indexOf(this.kind))
  )
    throw new Zs('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
(ii(tl, 'compileStyleAliases'), ii(rl, 'Type$1'));
var nl = rl;
function il(e, t) {
  var r = [];
  return (
    e[t].forEach(function (e) {
      var t = r.length;
      (r.forEach(function (r, n) {
        r.tag === e.tag && r.kind === e.kind && r.multi === e.multi && (t = n);
      }),
        (r[t] = e));
    }),
    r
  );
}
function al() {
  var e,
    t,
    r = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {},
      multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
    };
  function n(e) {
    e.multi
      ? (r.multi[e.kind].push(e), r.multi.fallback.push(e))
      : (r[e.kind][e.tag] = r.fallback[e.tag] = e);
  }
  for (ii(n, 'collectType'), e = 0, t = arguments.length; e < t; e += 1) arguments[e].forEach(n);
  return r;
}
function ol(e) {
  return this.extend(e);
}
(ii(il, 'compileList'),
  ii(al, 'compileMap'),
  ii(ol, 'Schema$1'),
  (ol.prototype.extend = ii(function (e) {
    var t = [],
      r = [];
    if (e instanceof nl) r.push(e);
    else if (Array.isArray(e)) r = r.concat(e);
    else {
      if (!e || (!Array.isArray(e.implicit) && !Array.isArray(e.explicit)))
        throw new Zs(
          'Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })'
        );
      (e.implicit && (t = t.concat(e.implicit)), e.explicit && (r = r.concat(e.explicit)));
    }
    (t.forEach(function (e) {
      if (!(e instanceof nl))
        throw new Zs(
          'Specified list of YAML types (or a single Type object) contains a non-Type object.'
        );
      if (e.loadKind && 'scalar' !== e.loadKind)
        throw new Zs(
          'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'
        );
      if (e.multi)
        throw new Zs(
          'There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.'
        );
    }),
      r.forEach(function (e) {
        if (!(e instanceof nl))
          throw new Zs(
            'Specified list of YAML types (or a single Type object) contains a non-Type object.'
          );
      }));
    var n = Object.create(ol.prototype);
    return (
      (n.implicit = (this.implicit || []).concat(t)),
      (n.explicit = (this.explicit || []).concat(r)),
      (n.compiledImplicit = il(n, 'implicit')),
      (n.compiledExplicit = il(n, 'explicit')),
      (n.compiledTypeMap = al(n.compiledImplicit, n.compiledExplicit)),
      n
    );
  }, 'extend')));
var sl = new ol({
  explicit: [
    new nl('tag:yaml.org,2002:str', {
      kind: 'scalar',
      construct: ii(function (e) {
        return null !== e ? e : '';
      }, 'construct'),
    }),
    new nl('tag:yaml.org,2002:seq', {
      kind: 'sequence',
      construct: ii(function (e) {
        return null !== e ? e : [];
      }, 'construct'),
    }),
    new nl('tag:yaml.org,2002:map', {
      kind: 'mapping',
      construct: ii(function (e) {
        return null !== e ? e : {};
      }, 'construct'),
    }),
  ],
});
function ll(e) {
  if (null === e) return !0;
  var t = e.length;
  return (1 === t && '~' === e) || (4 === t && ('null' === e || 'Null' === e || 'NULL' === e));
}
function cl() {
  return null;
}
function hl(e) {
  return null === e;
}
(ii(ll, 'resolveYamlNull'), ii(cl, 'constructYamlNull'), ii(hl, 'isNull'));
var dl = new nl('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: ll,
  construct: cl,
  predicate: hl,
  represent: {
    canonical: ii(function () {
      return '~';
    }, 'canonical'),
    lowercase: ii(function () {
      return 'null';
    }, 'lowercase'),
    uppercase: ii(function () {
      return 'NULL';
    }, 'uppercase'),
    camelcase: ii(function () {
      return 'Null';
    }, 'camelcase'),
    empty: ii(function () {
      return '';
    }, 'empty'),
  },
  defaultStyle: 'lowercase',
});
function ul(e) {
  if (null === e) return !1;
  var t = e.length;
  return (
    (4 === t && ('true' === e || 'True' === e || 'TRUE' === e)) ||
    (5 === t && ('false' === e || 'False' === e || 'FALSE' === e))
  );
}
function pl(e) {
  return 'true' === e || 'True' === e || 'TRUE' === e;
}
function gl(e) {
  return '[object Boolean]' === Object.prototype.toString.call(e);
}
(ii(ul, 'resolveYamlBoolean'), ii(pl, 'constructYamlBoolean'), ii(gl, 'isBoolean'));
var fl = new nl('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: ul,
  construct: pl,
  predicate: gl,
  represent: {
    lowercase: ii(function (e) {
      return e ? 'true' : 'false';
    }, 'lowercase'),
    uppercase: ii(function (e) {
      return e ? 'TRUE' : 'FALSE';
    }, 'uppercase'),
    camelcase: ii(function (e) {
      return e ? 'True' : 'False';
    }, 'camelcase'),
  },
  defaultStyle: 'lowercase',
});
function ml(e) {
  return (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102);
}
function bl(e) {
  return 48 <= e && e <= 55;
}
function yl(e) {
  return 48 <= e && e <= 57;
}
function xl(e) {
  if (null === e) return !1;
  var t,
    r = e.length,
    n = 0,
    i = !1;
  if (!r) return !1;
  if ((('-' !== (t = e[n]) && '+' !== t) || (t = e[++n]), '0' === t)) {
    if (n + 1 === r) return !0;
    if ('b' === (t = e[++n])) {
      for (n++; n < r; n++)
        if ('_' !== (t = e[n])) {
          if ('0' !== t && '1' !== t) return !1;
          i = !0;
        }
      return i && '_' !== t;
    }
    if ('x' === t) {
      for (n++; n < r; n++)
        if ('_' !== (t = e[n])) {
          if (!ml(e.charCodeAt(n))) return !1;
          i = !0;
        }
      return i && '_' !== t;
    }
    if ('o' === t) {
      for (n++; n < r; n++)
        if ('_' !== (t = e[n])) {
          if (!bl(e.charCodeAt(n))) return !1;
          i = !0;
        }
      return i && '_' !== t;
    }
  }
  if ('_' === t) return !1;
  for (; n < r; n++)
    if ('_' !== (t = e[n])) {
      if (!yl(e.charCodeAt(n))) return !1;
      i = !0;
    }
  return !(!i || '_' === t);
}
function kl(e) {
  var t,
    r = e,
    n = 1;
  if (
    (-1 !== r.indexOf('_') && (r = r.replace(/_/g, '')),
    ('-' !== (t = r[0]) && '+' !== t) || ('-' === t && (n = -1), (t = (r = r.slice(1))[0])),
    '0' === r)
  )
    return 0;
  if ('0' === t) {
    if ('b' === r[1]) return n * parseInt(r.slice(2), 2);
    if ('x' === r[1]) return n * parseInt(r.slice(2), 16);
    if ('o' === r[1]) return n * parseInt(r.slice(2), 8);
  }
  return n * parseInt(r, 10);
}
function Cl(e) {
  return (
    '[object Number]' === Object.prototype.toString.call(e) && e % 1 == 0 && !Hs.isNegativeZero(e)
  );
}
(ii(ml, 'isHexCode'),
  ii(bl, 'isOctCode'),
  ii(yl, 'isDecCode'),
  ii(xl, 'resolveYamlInteger'),
  ii(kl, 'constructYamlInteger'),
  ii(Cl, 'isInteger'));
var wl = new nl('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: xl,
    construct: kl,
    predicate: Cl,
    represent: {
      binary: ii(function (e) {
        return e >= 0 ? '0b' + e.toString(2) : '-0b' + e.toString(2).slice(1);
      }, 'binary'),
      octal: ii(function (e) {
        return e >= 0 ? '0o' + e.toString(8) : '-0o' + e.toString(8).slice(1);
      }, 'octal'),
      decimal: ii(function (e) {
        return e.toString(10);
      }, 'decimal'),
      hexadecimal: ii(function (e) {
        return e >= 0
          ? '0x' + e.toString(16).toUpperCase()
          : '-0x' + e.toString(16).toUpperCase().slice(1);
      }, 'hexadecimal'),
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary: [2, 'bin'],
      octal: [8, 'oct'],
      decimal: [10, 'dec'],
      hexadecimal: [16, 'hex'],
    },
  }),
  vl = new RegExp(
    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$'
  );
function _l(e) {
  return null !== e && !(!vl.test(e) || '_' === e[e.length - 1]);
}
function Sl(e) {
  var t, r;
  return (
    (r = '-' === (t = e.replace(/_/g, '').toLowerCase())[0] ? -1 : 1),
    '+-'.indexOf(t[0]) >= 0 && (t = t.slice(1)),
    '.inf' === t
      ? 1 === r
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY
      : '.nan' === t
        ? NaN
        : r * parseFloat(t, 10)
  );
}
(ii(_l, 'resolveYamlFloat'), ii(Sl, 'constructYamlFloat'));
var El = /^[-+]?[0-9]+e/;
function Dl(e, t) {
  var r;
  if (isNaN(e))
    switch (t) {
      case 'lowercase':
        return '.nan';
      case 'uppercase':
        return '.NAN';
      case 'camelcase':
        return '.NaN';
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (t) {
      case 'lowercase':
        return '.inf';
      case 'uppercase':
        return '.INF';
      case 'camelcase':
        return '.Inf';
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (t) {
      case 'lowercase':
        return '-.inf';
      case 'uppercase':
        return '-.INF';
      case 'camelcase':
        return '-.Inf';
    }
  else if (Hs.isNegativeZero(e)) return '-0.0';
  return ((r = e.toString(10)), El.test(r) ? r.replace('e', '.e') : r);
}
function Al(e) {
  return (
    '[object Number]' === Object.prototype.toString.call(e) && (e % 1 != 0 || Hs.isNegativeZero(e))
  );
}
(ii(Dl, 'representYamlFloat'), ii(Al, 'isFloat'));
var Tl = new nl('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: _l,
    construct: Sl,
    predicate: Al,
    represent: Dl,
    defaultStyle: 'lowercase',
  }),
  Fl = sl.extend({ implicit: [dl, fl, wl, Tl] }),
  Bl = Fl,
  Ml = new RegExp('^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$'),
  Nl = new RegExp(
    '^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$'
  );
function Ll(e) {
  return null !== e && (null !== Ml.exec(e) || null !== Nl.exec(e));
}
function Ol(e) {
  var t,
    r,
    n,
    i,
    a,
    o,
    s,
    l,
    c = 0,
    h = null;
  if ((null === (t = Ml.exec(e)) && (t = Nl.exec(e)), null === t))
    throw new Error('Date resolve error');
  if (((r = +t[1]), (n = +t[2] - 1), (i = +t[3]), !t[4])) return new Date(Date.UTC(r, n, i));
  if (((a = +t[4]), (o = +t[5]), (s = +t[6]), t[7])) {
    for (c = t[7].slice(0, 3); c.length < 3; ) c += '0';
    c = +c;
  }
  return (
    t[9] && ((h = 6e4 * (60 * +t[10] + +(t[11] || 0))), '-' === t[9] && (h = -h)),
    (l = new Date(Date.UTC(r, n, i, a, o, s, c))),
    h && l.setTime(l.getTime() - h),
    l
  );
}
function $l(e) {
  return e.toISOString();
}
(ii(Ll, 'resolveYamlTimestamp'),
  ii(Ol, 'constructYamlTimestamp'),
  ii($l, 'representYamlTimestamp'));
var Il = new nl('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: Ll,
  construct: Ol,
  instanceOf: Date,
  represent: $l,
});
function Rl(e) {
  return '<<' === e || null === e;
}
ii(Rl, 'resolveYamlMerge');
var zl = new nl('tag:yaml.org,2002:merge', { kind: 'scalar', resolve: Rl }),
  Pl = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
function jl(e) {
  if (null === e) return !1;
  var t,
    r,
    n = 0,
    i = e.length,
    a = Pl;
  for (r = 0; r < i; r++)
    if (!((t = a.indexOf(e.charAt(r))) > 64)) {
      if (t < 0) return !1;
      n += 6;
    }
  return n % 8 == 0;
}
function ql(e) {
  var t,
    r,
    n = e.replace(/[\r\n=]/g, ''),
    i = n.length,
    a = Pl,
    o = 0,
    s = [];
  for (t = 0; t < i; t++)
    (t % 4 == 0 && t && (s.push((o >> 16) & 255), s.push((o >> 8) & 255), s.push(255 & o)),
      (o = (o << 6) | a.indexOf(n.charAt(t))));
  return (
    0 === (r = (i % 4) * 6)
      ? (s.push((o >> 16) & 255), s.push((o >> 8) & 255), s.push(255 & o))
      : 18 === r
        ? (s.push((o >> 10) & 255), s.push((o >> 2) & 255))
        : 12 === r && s.push((o >> 4) & 255),
    new Uint8Array(s)
  );
}
function Wl(e) {
  var t,
    r,
    n = '',
    i = 0,
    a = e.length,
    o = Pl;
  for (t = 0; t < a; t++)
    (t % 3 == 0 &&
      t &&
      ((n += o[(i >> 18) & 63]),
      (n += o[(i >> 12) & 63]),
      (n += o[(i >> 6) & 63]),
      (n += o[63 & i])),
      (i = (i << 8) + e[t]));
  return (
    0 === (r = a % 3)
      ? ((n += o[(i >> 18) & 63]),
        (n += o[(i >> 12) & 63]),
        (n += o[(i >> 6) & 63]),
        (n += o[63 & i]))
      : 2 === r
        ? ((n += o[(i >> 10) & 63]), (n += o[(i >> 4) & 63]), (n += o[(i << 2) & 63]), (n += o[64]))
        : 1 === r && ((n += o[(i >> 2) & 63]), (n += o[(i << 4) & 63]), (n += o[64]), (n += o[64])),
    n
  );
}
function Ul(e) {
  return '[object Uint8Array]' === Object.prototype.toString.call(e);
}
(ii(jl, 'resolveYamlBinary'),
  ii(ql, 'constructYamlBinary'),
  ii(Wl, 'representYamlBinary'),
  ii(Ul, 'isBinary'));
var Hl = new nl('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: jl,
    construct: ql,
    predicate: Ul,
    represent: Wl,
  }),
  Gl = Object.prototype.hasOwnProperty,
  Vl = Object.prototype.toString;
function Zl(e) {
  if (null === e) return !0;
  var t,
    r,
    n,
    i,
    a,
    o = [],
    s = e;
  for (t = 0, r = s.length; t < r; t += 1) {
    if (((n = s[t]), (a = !1), '[object Object]' !== Vl.call(n))) return !1;
    for (i in n)
      if (Gl.call(n, i)) {
        if (a) return !1;
        a = !0;
      }
    if (!a) return !1;
    if (-1 !== o.indexOf(i)) return !1;
    o.push(i);
  }
  return !0;
}
function Kl(e) {
  return null !== e ? e : [];
}
(ii(Zl, 'resolveYamlOmap'), ii(Kl, 'constructYamlOmap'));
var Yl = new nl('tag:yaml.org,2002:omap', { kind: 'sequence', resolve: Zl, construct: Kl }),
  Xl = Object.prototype.toString;
function Ql(e) {
  if (null === e) return !0;
  var t,
    r,
    n,
    i,
    a,
    o = e;
  for (a = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
    if (((n = o[t]), '[object Object]' !== Xl.call(n))) return !1;
    if (1 !== (i = Object.keys(n)).length) return !1;
    a[t] = [i[0], n[i[0]]];
  }
  return !0;
}
function Jl(e) {
  if (null === e) return [];
  var t,
    r,
    n,
    i,
    a,
    o = e;
  for (a = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
    ((n = o[t]), (i = Object.keys(n)), (a[t] = [i[0], n[i[0]]]));
  return a;
}
(ii(Ql, 'resolveYamlPairs'), ii(Jl, 'constructYamlPairs'));
var ec = new nl('tag:yaml.org,2002:pairs', { kind: 'sequence', resolve: Ql, construct: Jl }),
  tc = Object.prototype.hasOwnProperty;
function rc(e) {
  if (null === e) return !0;
  var t,
    r = e;
  for (t in r) if (tc.call(r, t) && null !== r[t]) return !1;
  return !0;
}
function nc(e) {
  return null !== e ? e : {};
}
(ii(rc, 'resolveYamlSet'), ii(nc, 'constructYamlSet'));
var ic = new nl('tag:yaml.org,2002:set', { kind: 'mapping', resolve: rc, construct: nc }),
  ac = Bl.extend({ implicit: [Il, zl], explicit: [Hl, Yl, ec, ic] }),
  oc = Object.prototype.hasOwnProperty,
  sc =
    /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
  lc = /[\x85\u2028\u2029]/,
  cc = /[,\[\]\{\}]/,
  hc = /^(?:!|!!|![a-z\-]+!)$/i,
  dc = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function uc(e) {
  return Object.prototype.toString.call(e);
}
function pc(e) {
  return 10 === e || 13 === e;
}
function gc(e) {
  return 9 === e || 32 === e;
}
function fc(e) {
  return 9 === e || 32 === e || 10 === e || 13 === e;
}
function mc(e) {
  return 44 === e || 91 === e || 93 === e || 123 === e || 125 === e;
}
function bc(e) {
  var t;
  return 48 <= e && e <= 57 ? e - 48 : 97 <= (t = 32 | e) && t <= 102 ? t - 97 + 10 : -1;
}
function yc(e) {
  return 120 === e ? 2 : 117 === e ? 4 : 85 === e ? 8 : 0;
}
function xc(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function kc(e) {
  return 48 === e
    ? '\0'
    : 97 === e
      ? ''
      : 98 === e
        ? '\b'
        : 116 === e || 9 === e
          ? '\t'
          : 110 === e
            ? '\n'
            : 118 === e
              ? '\v'
              : 102 === e
                ? '\f'
                : 114 === e
                  ? '\r'
                  : 101 === e
                    ? ''
                    : 32 === e
                      ? ' '
                      : 34 === e
                        ? '"'
                        : 47 === e
                          ? '/'
                          : 92 === e
                            ? '\\'
                            : 78 === e
                              ? ''
                              : 95 === e
                                ? ' '
                                : 76 === e
                                  ? '\u2028'
                                  : 80 === e
                                    ? '\u2029'
                                    : '';
}
function Cc(e) {
  return e <= 65535
    ? String.fromCharCode(e)
    : String.fromCharCode(55296 + ((e - 65536) >> 10), 56320 + ((e - 65536) & 1023));
}
(ii(uc, '_class'),
  ii(pc, 'is_EOL'),
  ii(gc, 'is_WHITE_SPACE'),
  ii(fc, 'is_WS_OR_EOL'),
  ii(mc, 'is_FLOW_INDICATOR'),
  ii(bc, 'fromHexCode'),
  ii(yc, 'escapedHexLen'),
  ii(xc, 'fromDecimalCode'),
  ii(kc, 'simpleEscapeSequence'),
  ii(Cc, 'charFromCodepoint'));
var wc,
  vc = new Array(256),
  _c = new Array(256);
for (wc = 0; wc < 256; wc++) ((vc[wc] = kc(wc) ? 1 : 0), (_c[wc] = kc(wc)));
function Sc(e, t) {
  ((this.input = e),
    (this.filename = t.filename || null),
    (this.schema = t.schema || ac),
    (this.onWarning = t.onWarning || null),
    (this.legacy = t.legacy || !1),
    (this.json = t.json || !1),
    (this.listener = t.listener || null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.typeMap = this.schema.compiledTypeMap),
    (this.length = e.length),
    (this.position = 0),
    (this.line = 0),
    (this.lineStart = 0),
    (this.lineIndent = 0),
    (this.firstTabInLine = -1),
    (this.documents = []));
}
function Ec(e, t) {
  var r = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart,
  };
  return ((r.snippet = Qs(r)), new Zs(t, r));
}
function Dc(e, t) {
  throw Ec(e, t);
}
function Ac(e, t) {
  e.onWarning && e.onWarning.call(null, Ec(e, t));
}
(ii(Sc, 'State$1'), ii(Ec, 'generateError'), ii(Dc, 'throwError'), ii(Ac, 'throwWarning'));
var Tc = {
  YAML: ii(function (e, t, r) {
    var n, i, a;
    (null !== e.version && Dc(e, 'duplication of %YAML directive'),
      1 !== r.length && Dc(e, 'YAML directive accepts exactly one argument'),
      null === (n = /^([0-9]+)\.([0-9]+)$/.exec(r[0])) &&
        Dc(e, 'ill-formed argument of the YAML directive'),
      (i = parseInt(n[1], 10)),
      (a = parseInt(n[2], 10)),
      1 !== i && Dc(e, 'unacceptable YAML version of the document'),
      (e.version = r[0]),
      (e.checkLineBreaks = a < 2),
      1 !== a && 2 !== a && Ac(e, 'unsupported YAML version of the document'));
  }, 'handleYamlDirective'),
  TAG: ii(function (e, t, r) {
    var n, i;
    (2 !== r.length && Dc(e, 'TAG directive accepts exactly two arguments'),
      (n = r[0]),
      (i = r[1]),
      hc.test(n) || Dc(e, 'ill-formed tag handle (first argument) of the TAG directive'),
      oc.call(e.tagMap, n) &&
        Dc(e, 'there is a previously declared suffix for "' + n + '" tag handle'),
      dc.test(i) || Dc(e, 'ill-formed tag prefix (second argument) of the TAG directive'));
    try {
      i = decodeURIComponent(i);
    } catch (a) {
      Dc(e, 'tag prefix is malformed: ' + i);
    }
    e.tagMap[n] = i;
  }, 'handleTagDirective'),
};
function Fc(e, t, r, n) {
  var i, a, o, s;
  if (t < r) {
    if (((s = e.input.slice(t, r)), n))
      for (i = 0, a = s.length; i < a; i += 1)
        9 === (o = s.charCodeAt(i)) ||
          (32 <= o && o <= 1114111) ||
          Dc(e, 'expected valid JSON character');
    else sc.test(s) && Dc(e, 'the stream contains non-printable characters');
    e.result += s;
  }
}
function Bc(e, t, r, n) {
  var i, a, o, s;
  for (
    Hs.isObject(r) || Dc(e, 'cannot merge mappings; the provided source object is unacceptable'),
      o = 0,
      s = (i = Object.keys(r)).length;
    o < s;
    o += 1
  )
    ((a = i[o]), oc.call(t, a) || ((t[a] = r[a]), (n[a] = !0)));
}
function Mc(e, t, r, n, i, a, o, s, l) {
  var c, h;
  if (Array.isArray(i))
    for (c = 0, h = (i = Array.prototype.slice.call(i)).length; c < h; c += 1)
      (Array.isArray(i[c]) && Dc(e, 'nested arrays are not supported inside keys'),
        'object' == typeof i && '[object Object]' === uc(i[c]) && (i[c] = '[object Object]'));
  if (
    ('object' == typeof i && '[object Object]' === uc(i) && (i = '[object Object]'),
    (i = String(i)),
    null === t && (t = {}),
    'tag:yaml.org,2002:merge' === n)
  )
    if (Array.isArray(a)) for (c = 0, h = a.length; c < h; c += 1) Bc(e, t, a[c], r);
    else Bc(e, t, a, r);
  else
    (e.json ||
      oc.call(r, i) ||
      !oc.call(t, i) ||
      ((e.line = o || e.line),
      (e.lineStart = s || e.lineStart),
      (e.position = l || e.position),
      Dc(e, 'duplicated mapping key')),
      '__proto__' === i
        ? Object.defineProperty(t, i, { configurable: !0, enumerable: !0, writable: !0, value: a })
        : (t[i] = a),
      delete r[i]);
  return t;
}
function Nc(e) {
  var t;
  (10 === (t = e.input.charCodeAt(e.position))
    ? e.position++
    : 13 === t
      ? (e.position++, 10 === e.input.charCodeAt(e.position) && e.position++)
      : Dc(e, 'a line break is expected'),
    (e.line += 1),
    (e.lineStart = e.position),
    (e.firstTabInLine = -1));
}
function Lc(e, t, r) {
  for (var n = 0, i = e.input.charCodeAt(e.position); 0 !== i; ) {
    for (; gc(i); )
      (9 === i && -1 === e.firstTabInLine && (e.firstTabInLine = e.position),
        (i = e.input.charCodeAt(++e.position)));
    if (t && 35 === i)
      do {
        i = e.input.charCodeAt(++e.position);
      } while (10 !== i && 13 !== i && 0 !== i);
    if (!pc(i)) break;
    for (Nc(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0; 32 === i; )
      (e.lineIndent++, (i = e.input.charCodeAt(++e.position)));
  }
  return (-1 !== r && 0 !== n && e.lineIndent < r && Ac(e, 'deficient indentation'), n);
}
function Oc(e) {
  var t,
    r = e.position;
  return !(
    (45 !== (t = e.input.charCodeAt(r)) && 46 !== t) ||
    t !== e.input.charCodeAt(r + 1) ||
    t !== e.input.charCodeAt(r + 2) ||
    ((r += 3), 0 !== (t = e.input.charCodeAt(r)) && !fc(t))
  );
}
function $c(e, t) {
  1 === t ? (e.result += ' ') : t > 1 && (e.result += Hs.repeat('\n', t - 1));
}
function Ic(e, t, r) {
  var n,
    i,
    a,
    o,
    s,
    l,
    c,
    h,
    d = e.kind,
    u = e.result;
  if (
    fc((h = e.input.charCodeAt(e.position))) ||
    mc(h) ||
    35 === h ||
    38 === h ||
    42 === h ||
    33 === h ||
    124 === h ||
    62 === h ||
    39 === h ||
    34 === h ||
    37 === h ||
    64 === h ||
    96 === h
  )
    return !1;
  if ((63 === h || 45 === h) && (fc((n = e.input.charCodeAt(e.position + 1))) || (r && mc(n))))
    return !1;
  for (e.kind = 'scalar', e.result = '', i = a = e.position, o = !1; 0 !== h; ) {
    if (58 === h) {
      if (fc((n = e.input.charCodeAt(e.position + 1))) || (r && mc(n))) break;
    } else if (35 === h) {
      if (fc(e.input.charCodeAt(e.position - 1))) break;
    } else {
      if ((e.position === e.lineStart && Oc(e)) || (r && mc(h))) break;
      if (pc(h)) {
        if (
          ((s = e.line), (l = e.lineStart), (c = e.lineIndent), Lc(e, !1, -1), e.lineIndent >= t)
        ) {
          ((o = !0), (h = e.input.charCodeAt(e.position)));
          continue;
        }
        ((e.position = a), (e.line = s), (e.lineStart = l), (e.lineIndent = c));
        break;
      }
    }
    (o && (Fc(e, i, a, !1), $c(e, e.line - s), (i = a = e.position), (o = !1)),
      gc(h) || (a = e.position + 1),
      (h = e.input.charCodeAt(++e.position)));
  }
  return (Fc(e, i, a, !1), !!e.result || ((e.kind = d), (e.result = u), !1));
}
function Rc(e, t) {
  var r, n, i;
  if (39 !== (r = e.input.charCodeAt(e.position))) return !1;
  for (
    e.kind = 'scalar', e.result = '', e.position++, n = i = e.position;
    0 !== (r = e.input.charCodeAt(e.position));
  )
    if (39 === r) {
      if ((Fc(e, n, e.position, !0), 39 !== (r = e.input.charCodeAt(++e.position)))) return !0;
      ((n = e.position), e.position++, (i = e.position));
    } else
      pc(r)
        ? (Fc(e, n, i, !0), $c(e, Lc(e, !1, t)), (n = i = e.position))
        : e.position === e.lineStart && Oc(e)
          ? Dc(e, 'unexpected end of the document within a single quoted scalar')
          : (e.position++, (i = e.position));
  Dc(e, 'unexpected end of the stream within a single quoted scalar');
}
function zc(e, t) {
  var r, n, i, a, o, s;
  if (34 !== (s = e.input.charCodeAt(e.position))) return !1;
  for (
    e.kind = 'scalar', e.result = '', e.position++, r = n = e.position;
    0 !== (s = e.input.charCodeAt(e.position));
  ) {
    if (34 === s) return (Fc(e, r, e.position, !0), e.position++, !0);
    if (92 === s) {
      if ((Fc(e, r, e.position, !0), pc((s = e.input.charCodeAt(++e.position))))) Lc(e, !1, t);
      else if (s < 256 && vc[s]) ((e.result += _c[s]), e.position++);
      else if ((o = yc(s)) > 0) {
        for (i = o, a = 0; i > 0; i--)
          (o = bc((s = e.input.charCodeAt(++e.position)))) >= 0
            ? (a = (a << 4) + o)
            : Dc(e, 'expected hexadecimal character');
        ((e.result += Cc(a)), e.position++);
      } else Dc(e, 'unknown escape sequence');
      r = n = e.position;
    } else
      pc(s)
        ? (Fc(e, r, n, !0), $c(e, Lc(e, !1, t)), (r = n = e.position))
        : e.position === e.lineStart && Oc(e)
          ? Dc(e, 'unexpected end of the document within a double quoted scalar')
          : (e.position++, (n = e.position));
  }
  Dc(e, 'unexpected end of the stream within a double quoted scalar');
}
function Pc(e, t) {
  var r,
    n,
    i,
    a,
    o,
    s,
    l,
    c,
    h,
    d,
    u,
    p,
    g = !0,
    f = e.tag,
    m = e.anchor,
    b = Object.create(null);
  if (91 === (p = e.input.charCodeAt(e.position))) ((o = 93), (c = !1), (a = []));
  else {
    if (123 !== p) return !1;
    ((o = 125), (c = !0), (a = {}));
  }
  for (
    null !== e.anchor && (e.anchorMap[e.anchor] = a), p = e.input.charCodeAt(++e.position);
    0 !== p;
  ) {
    if ((Lc(e, !0, t), (p = e.input.charCodeAt(e.position)) === o))
      return (
        e.position++,
        (e.tag = f),
        (e.anchor = m),
        (e.kind = c ? 'mapping' : 'sequence'),
        (e.result = a),
        !0
      );
    (g
      ? 44 === p && Dc(e, "expected the node content, but found ','")
      : Dc(e, 'missed comma between flow collection entries'),
      (u = null),
      (s = l = !1),
      63 === p &&
        fc(e.input.charCodeAt(e.position + 1)) &&
        ((s = l = !0), e.position++, Lc(e, !0, t)),
      (r = e.line),
      (n = e.lineStart),
      (i = e.position),
      Vc(e, t, 1, !1, !0),
      (d = e.tag),
      (h = e.result),
      Lc(e, !0, t),
      (p = e.input.charCodeAt(e.position)),
      (!l && e.line !== r) ||
        58 !== p ||
        ((s = !0),
        (p = e.input.charCodeAt(++e.position)),
        Lc(e, !0, t),
        Vc(e, t, 1, !1, !0),
        (u = e.result)),
      c ? Mc(e, a, b, d, h, u, r, n, i) : s ? a.push(Mc(e, null, b, d, h, u, r, n, i)) : a.push(h),
      Lc(e, !0, t),
      44 === (p = e.input.charCodeAt(e.position))
        ? ((g = !0), (p = e.input.charCodeAt(++e.position)))
        : (g = !1));
  }
  Dc(e, 'unexpected end of the stream within a flow collection');
}
function jc(e, t) {
  var r,
    n,
    i,
    a,
    o = 1,
    s = !1,
    l = !1,
    c = t,
    h = 0,
    d = !1;
  if (124 === (a = e.input.charCodeAt(e.position))) n = !1;
  else {
    if (62 !== a) return !1;
    n = !0;
  }
  for (e.kind = 'scalar', e.result = ''; 0 !== a; )
    if (43 === (a = e.input.charCodeAt(++e.position)) || 45 === a)
      1 === o ? (o = 43 === a ? 3 : 2) : Dc(e, 'repeat of a chomping mode identifier');
    else {
      if (!((i = xc(a)) >= 0)) break;
      0 === i
        ? Dc(e, 'bad explicit indentation width of a block scalar; it cannot be less than one')
        : l
          ? Dc(e, 'repeat of an indentation width identifier')
          : ((c = t + i - 1), (l = !0));
    }
  if (gc(a)) {
    do {
      a = e.input.charCodeAt(++e.position);
    } while (gc(a));
    if (35 === a)
      do {
        a = e.input.charCodeAt(++e.position);
      } while (!pc(a) && 0 !== a);
  }
  for (; 0 !== a; ) {
    for (
      Nc(e), e.lineIndent = 0, a = e.input.charCodeAt(e.position);
      (!l || e.lineIndent < c) && 32 === a;
    )
      (e.lineIndent++, (a = e.input.charCodeAt(++e.position)));
    if ((!l && e.lineIndent > c && (c = e.lineIndent), pc(a))) h++;
    else {
      if (e.lineIndent < c) {
        3 === o ? (e.result += Hs.repeat('\n', s ? 1 + h : h)) : 1 === o && s && (e.result += '\n');
        break;
      }
      for (
        n
          ? gc(a)
            ? ((d = !0), (e.result += Hs.repeat('\n', s ? 1 + h : h)))
            : d
              ? ((d = !1), (e.result += Hs.repeat('\n', h + 1)))
              : 0 === h
                ? s && (e.result += ' ')
                : (e.result += Hs.repeat('\n', h))
          : (e.result += Hs.repeat('\n', s ? 1 + h : h)),
          s = !0,
          l = !0,
          h = 0,
          r = e.position;
        !pc(a) && 0 !== a;
      )
        a = e.input.charCodeAt(++e.position);
      Fc(e, r, e.position, !1);
    }
  }
  return !0;
}
function qc(e, t) {
  var r,
    n,
    i = e.tag,
    a = e.anchor,
    o = [],
    s = !1;
  if (-1 !== e.firstTabInLine) return !1;
  for (
    null !== e.anchor && (e.anchorMap[e.anchor] = o), n = e.input.charCodeAt(e.position);
    0 !== n &&
    (-1 !== e.firstTabInLine &&
      ((e.position = e.firstTabInLine), Dc(e, 'tab characters must not be used in indentation')),
    45 === n) &&
    fc(e.input.charCodeAt(e.position + 1));
  )
    if (((s = !0), e.position++, Lc(e, !0, -1) && e.lineIndent <= t))
      (o.push(null), (n = e.input.charCodeAt(e.position)));
    else if (
      ((r = e.line),
      Vc(e, t, 3, !1, !0),
      o.push(e.result),
      Lc(e, !0, -1),
      (n = e.input.charCodeAt(e.position)),
      (e.line === r || e.lineIndent > t) && 0 !== n)
    )
      Dc(e, 'bad indentation of a sequence entry');
    else if (e.lineIndent < t) break;
  return !!s && ((e.tag = i), (e.anchor = a), (e.kind = 'sequence'), (e.result = o), !0);
}
function Wc(e, t, r) {
  var n,
    i,
    a,
    o,
    s,
    l,
    c,
    h = e.tag,
    d = e.anchor,
    u = {},
    p = Object.create(null),
    g = null,
    f = null,
    m = null,
    b = !1,
    y = !1;
  if (-1 !== e.firstTabInLine) return !1;
  for (
    null !== e.anchor && (e.anchorMap[e.anchor] = u), c = e.input.charCodeAt(e.position);
    0 !== c;
  ) {
    if (
      (b ||
        -1 === e.firstTabInLine ||
        ((e.position = e.firstTabInLine), Dc(e, 'tab characters must not be used in indentation')),
      (n = e.input.charCodeAt(e.position + 1)),
      (a = e.line),
      (63 !== c && 58 !== c) || !fc(n))
    ) {
      if (((o = e.line), (s = e.lineStart), (l = e.position), !Vc(e, r, 2, !1, !0))) break;
      if (e.line === a) {
        for (c = e.input.charCodeAt(e.position); gc(c); ) c = e.input.charCodeAt(++e.position);
        if (58 === c)
          (fc((c = e.input.charCodeAt(++e.position))) ||
            Dc(
              e,
              'a whitespace character is expected after the key-value separator within a block mapping'
            ),
            b && (Mc(e, u, p, g, f, null, o, s, l), (g = f = m = null)),
            (y = !0),
            (b = !1),
            (i = !1),
            (g = e.tag),
            (f = e.result));
        else {
          if (!y) return ((e.tag = h), (e.anchor = d), !0);
          Dc(e, 'can not read an implicit mapping pair; a colon is missed');
        }
      } else {
        if (!y) return ((e.tag = h), (e.anchor = d), !0);
        Dc(e, 'can not read a block mapping entry; a multiline key may not be an implicit key');
      }
    } else
      (63 === c
        ? (b && (Mc(e, u, p, g, f, null, o, s, l), (g = f = m = null)),
          (y = !0),
          (b = !0),
          (i = !0))
        : b
          ? ((b = !1), (i = !0))
          : Dc(
              e,
              'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'
            ),
        (e.position += 1),
        (c = n));
    if (
      ((e.line === a || e.lineIndent > t) &&
        (b && ((o = e.line), (s = e.lineStart), (l = e.position)),
        Vc(e, t, 4, !0, i) && (b ? (f = e.result) : (m = e.result)),
        b || (Mc(e, u, p, g, f, m, o, s, l), (g = f = m = null)),
        Lc(e, !0, -1),
        (c = e.input.charCodeAt(e.position))),
      (e.line === a || e.lineIndent > t) && 0 !== c)
    )
      Dc(e, 'bad indentation of a mapping entry');
    else if (e.lineIndent < t) break;
  }
  return (
    b && Mc(e, u, p, g, f, null, o, s, l),
    y && ((e.tag = h), (e.anchor = d), (e.kind = 'mapping'), (e.result = u)),
    y
  );
}
function Uc(e) {
  var t,
    r,
    n,
    i,
    a = !1,
    o = !1;
  if (33 !== (i = e.input.charCodeAt(e.position))) return !1;
  if (
    (null !== e.tag && Dc(e, 'duplication of a tag property'),
    60 === (i = e.input.charCodeAt(++e.position))
      ? ((a = !0), (i = e.input.charCodeAt(++e.position)))
      : 33 === i
        ? ((o = !0), (r = '!!'), (i = e.input.charCodeAt(++e.position)))
        : (r = '!'),
    (t = e.position),
    a)
  ) {
    do {
      i = e.input.charCodeAt(++e.position);
    } while (0 !== i && 62 !== i);
    e.position < e.length
      ? ((n = e.input.slice(t, e.position)), (i = e.input.charCodeAt(++e.position)))
      : Dc(e, 'unexpected end of the stream within a verbatim tag');
  } else {
    for (; 0 !== i && !fc(i); )
      (33 === i &&
        (o
          ? Dc(e, 'tag suffix cannot contain exclamation marks')
          : ((r = e.input.slice(t - 1, e.position + 1)),
            hc.test(r) || Dc(e, 'named tag handle cannot contain such characters'),
            (o = !0),
            (t = e.position + 1))),
        (i = e.input.charCodeAt(++e.position)));
    ((n = e.input.slice(t, e.position)),
      cc.test(n) && Dc(e, 'tag suffix cannot contain flow indicator characters'));
  }
  n && !dc.test(n) && Dc(e, 'tag name cannot contain such characters: ' + n);
  try {
    n = decodeURIComponent(n);
  } catch (s) {
    Dc(e, 'tag name is malformed: ' + n);
  }
  return (
    a
      ? (e.tag = n)
      : oc.call(e.tagMap, r)
        ? (e.tag = e.tagMap[r] + n)
        : '!' === r
          ? (e.tag = '!' + n)
          : '!!' === r
            ? (e.tag = 'tag:yaml.org,2002:' + n)
            : Dc(e, 'undeclared tag handle "' + r + '"'),
    !0
  );
}
function Hc(e) {
  var t, r;
  if (38 !== (r = e.input.charCodeAt(e.position))) return !1;
  for (
    null !== e.anchor && Dc(e, 'duplication of an anchor property'),
      r = e.input.charCodeAt(++e.position),
      t = e.position;
    0 !== r && !fc(r) && !mc(r);
  )
    r = e.input.charCodeAt(++e.position);
  return (
    e.position === t && Dc(e, 'name of an anchor node must contain at least one character'),
    (e.anchor = e.input.slice(t, e.position)),
    !0
  );
}
function Gc(e) {
  var t, r, n;
  if (42 !== (n = e.input.charCodeAt(e.position))) return !1;
  for (n = e.input.charCodeAt(++e.position), t = e.position; 0 !== n && !fc(n) && !mc(n); )
    n = e.input.charCodeAt(++e.position);
  return (
    e.position === t && Dc(e, 'name of an alias node must contain at least one character'),
    (r = e.input.slice(t, e.position)),
    oc.call(e.anchorMap, r) || Dc(e, 'unidentified alias "' + r + '"'),
    (e.result = e.anchorMap[r]),
    Lc(e, !0, -1),
    !0
  );
}
function Vc(e, t, r, n, i) {
  var a,
    o,
    s,
    l,
    c,
    h,
    d,
    u,
    p,
    g = 1,
    f = !1,
    m = !1;
  if (
    (null !== e.listener && e.listener('open', e),
    (e.tag = null),
    (e.anchor = null),
    (e.kind = null),
    (e.result = null),
    (a = o = s = 4 === r || 3 === r),
    n &&
      Lc(e, !0, -1) &&
      ((f = !0),
      e.lineIndent > t ? (g = 1) : e.lineIndent === t ? (g = 0) : e.lineIndent < t && (g = -1)),
    1 === g)
  )
    for (; Uc(e) || Hc(e); )
      Lc(e, !0, -1)
        ? ((f = !0),
          (s = a),
          e.lineIndent > t ? (g = 1) : e.lineIndent === t ? (g = 0) : e.lineIndent < t && (g = -1))
        : (s = !1);
  if (
    (s && (s = f || i),
    (1 !== g && 4 !== r) ||
      ((u = 1 === r || 2 === r ? t : t + 1),
      (p = e.position - e.lineStart),
      1 === g
        ? (s && (qc(e, p) || Wc(e, p, u))) || Pc(e, u)
          ? (m = !0)
          : ((o && jc(e, u)) || Rc(e, u) || zc(e, u)
              ? (m = !0)
              : Gc(e)
                ? ((m = !0),
                  (null === e.tag && null === e.anchor) ||
                    Dc(e, 'alias node should not have any properties'))
                : Ic(e, u, 1 === r) && ((m = !0), null === e.tag && (e.tag = '?')),
            null !== e.anchor && (e.anchorMap[e.anchor] = e.result))
        : 0 === g && (m = s && qc(e, p))),
    null === e.tag)
  )
    null !== e.anchor && (e.anchorMap[e.anchor] = e.result);
  else if ('?' === e.tag) {
    for (
      null !== e.result &&
        'scalar' !== e.kind &&
        Dc(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'),
        l = 0,
        c = e.implicitTypes.length;
      l < c;
      l += 1
    )
      if ((d = e.implicitTypes[l]).resolve(e.result)) {
        ((e.result = d.construct(e.result)),
          (e.tag = d.tag),
          null !== e.anchor && (e.anchorMap[e.anchor] = e.result));
        break;
      }
  } else if ('!' !== e.tag) {
    if (oc.call(e.typeMap[e.kind || 'fallback'], e.tag)) d = e.typeMap[e.kind || 'fallback'][e.tag];
    else
      for (d = null, l = 0, c = (h = e.typeMap.multi[e.kind || 'fallback']).length; l < c; l += 1)
        if (e.tag.slice(0, h[l].tag.length) === h[l].tag) {
          d = h[l];
          break;
        }
    (d || Dc(e, 'unknown tag !<' + e.tag + '>'),
      null !== e.result &&
        d.kind !== e.kind &&
        Dc(
          e,
          'unacceptable node kind for !<' +
            e.tag +
            '> tag; it should be "' +
            d.kind +
            '", not "' +
            e.kind +
            '"'
        ),
      d.resolve(e.result, e.tag)
        ? ((e.result = d.construct(e.result, e.tag)),
          null !== e.anchor && (e.anchorMap[e.anchor] = e.result))
        : Dc(e, 'cannot resolve a node with !<' + e.tag + '> explicit tag'));
  }
  return (null !== e.listener && e.listener('close', e), null !== e.tag || null !== e.anchor || m);
}
function Zc(e) {
  var t,
    r,
    n,
    i,
    a = e.position,
    o = !1;
  for (
    e.version = null,
      e.checkLineBreaks = e.legacy,
      e.tagMap = Object.create(null),
      e.anchorMap = Object.create(null);
    0 !== (i = e.input.charCodeAt(e.position)) &&
    (Lc(e, !0, -1), (i = e.input.charCodeAt(e.position)), !(e.lineIndent > 0 || 37 !== i));
  ) {
    for (o = !0, i = e.input.charCodeAt(++e.position), t = e.position; 0 !== i && !fc(i); )
      i = e.input.charCodeAt(++e.position);
    for (
      n = [],
        (r = e.input.slice(t, e.position)).length < 1 &&
          Dc(e, 'directive name must not be less than one character in length');
      0 !== i;
    ) {
      for (; gc(i); ) i = e.input.charCodeAt(++e.position);
      if (35 === i) {
        do {
          i = e.input.charCodeAt(++e.position);
        } while (0 !== i && !pc(i));
        break;
      }
      if (pc(i)) break;
      for (t = e.position; 0 !== i && !fc(i); ) i = e.input.charCodeAt(++e.position);
      n.push(e.input.slice(t, e.position));
    }
    (0 !== i && Nc(e),
      oc.call(Tc, r) ? Tc[r](e, r, n) : Ac(e, 'unknown document directive "' + r + '"'));
  }
  (Lc(e, !0, -1),
    0 === e.lineIndent &&
    45 === e.input.charCodeAt(e.position) &&
    45 === e.input.charCodeAt(e.position + 1) &&
    45 === e.input.charCodeAt(e.position + 2)
      ? ((e.position += 3), Lc(e, !0, -1))
      : o && Dc(e, 'directives end mark is expected'),
    Vc(e, e.lineIndent - 1, 4, !1, !0),
    Lc(e, !0, -1),
    e.checkLineBreaks &&
      lc.test(e.input.slice(a, e.position)) &&
      Ac(e, 'non-ASCII line breaks are interpreted as content'),
    e.documents.push(e.result),
    e.position === e.lineStart && Oc(e)
      ? 46 === e.input.charCodeAt(e.position) && ((e.position += 3), Lc(e, !0, -1))
      : e.position < e.length - 1 &&
        Dc(e, 'end of the stream or a document separator is expected'));
}
function Kc(e, t) {
  ((t = t || {}),
    0 !== (e = String(e)).length &&
      (10 !== e.charCodeAt(e.length - 1) && 13 !== e.charCodeAt(e.length - 1) && (e += '\n'),
      65279 === e.charCodeAt(0) && (e = e.slice(1))));
  var r = new Sc(e, t),
    n = e.indexOf('\0');
  for (
    -1 !== n && ((r.position = n), Dc(r, 'null byte is not allowed in input')), r.input += '\0';
    32 === r.input.charCodeAt(r.position);
  )
    ((r.lineIndent += 1), (r.position += 1));
  for (; r.position < r.length - 1; ) Zc(r);
  return r.documents;
}
function Yc(e, t) {
  var r = Kc(e, t);
  if (0 !== r.length) {
    if (1 === r.length) return r[0];
    throw new Zs('expected a single document in the stream, but found more');
  }
}
(ii(Fc, 'captureSegment'),
  ii(Bc, 'mergeMappings'),
  ii(Mc, 'storeMappingPair'),
  ii(Nc, 'readLineBreak'),
  ii(Lc, 'skipSeparationSpace'),
  ii(Oc, 'testDocumentSeparator'),
  ii($c, 'writeFoldedLines'),
  ii(Ic, 'readPlainScalar'),
  ii(Rc, 'readSingleQuotedScalar'),
  ii(zc, 'readDoubleQuotedScalar'),
  ii(Pc, 'readFlowCollection'),
  ii(jc, 'readBlockScalar'),
  ii(qc, 'readBlockSequence'),
  ii(Wc, 'readBlockMapping'),
  ii(Uc, 'readTagProperty'),
  ii(Hc, 'readAnchorProperty'),
  ii(Gc, 'readAlias'),
  ii(Vc, 'composeNode'),
  ii(Zc, 'readDocument'),
  ii(Kc, 'loadDocuments'),
  ii(function (e, t, r) {
    null !== t && 'object' == typeof t && void 0 === r && ((r = t), (t = null));
    var n = Kc(e, r);
    if ('function' != typeof t) return n;
    for (var i = 0, a = n.length; i < a; i += 1) t(n[i]);
  }, 'loadAll$1'),
  ii(Yc, 'load$1'));
var Xc = { load: Yc },
  Qc = Object.prototype.toString,
  Jc = Object.prototype.hasOwnProperty,
  eh = 65279,
  th = {
    0: '\\0',
    7: '\\a',
    8: '\\b',
    9: '\\t',
    10: '\\n',
    11: '\\v',
    12: '\\f',
    13: '\\r',
    27: '\\e',
    34: '\\"',
    92: '\\\\',
    133: '\\N',
    160: '\\_',
    8232: '\\L',
    8233: '\\P',
  },
  rh = [
    'y',
    'Y',
    'yes',
    'Yes',
    'YES',
    'on',
    'On',
    'ON',
    'n',
    'N',
    'no',
    'No',
    'NO',
    'off',
    'Off',
    'OFF',
  ],
  nh = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function ih(e, t) {
  var r, n, i, a, o, s, l;
  if (null === t) return {};
  for (r = {}, i = 0, a = (n = Object.keys(t)).length; i < a; i += 1)
    ((o = n[i]),
      (s = String(t[o])),
      '!!' === o.slice(0, 2) && (o = 'tag:yaml.org,2002:' + o.slice(2)),
      (l = e.compiledTypeMap.fallback[o]) && Jc.call(l.styleAliases, s) && (s = l.styleAliases[s]),
      (r[o] = s));
  return r;
}
function ah(e) {
  var t, r, n;
  if (((t = e.toString(16).toUpperCase()), e <= 255)) ((r = 'x'), (n = 2));
  else if (e <= 65535) ((r = 'u'), (n = 4));
  else {
    if (!(e <= 4294967295))
      throw new Zs('code point within a string may not be greater than 0xFFFFFFFF');
    ((r = 'U'), (n = 8));
  }
  return '\\' + r + Hs.repeat('0', n - t.length) + t;
}
(ii(ih, 'compileStyleMap'), ii(ah, 'encodeHex'));
function oh(e) {
  ((this.schema = e.schema || ac),
    (this.indent = Math.max(1, e.indent || 2)),
    (this.noArrayIndent = e.noArrayIndent || !1),
    (this.skipInvalid = e.skipInvalid || !1),
    (this.flowLevel = Hs.isNothing(e.flowLevel) ? -1 : e.flowLevel),
    (this.styleMap = ih(this.schema, e.styles || null)),
    (this.sortKeys = e.sortKeys || !1),
    (this.lineWidth = e.lineWidth || 80),
    (this.noRefs = e.noRefs || !1),
    (this.noCompatMode = e.noCompatMode || !1),
    (this.condenseFlow = e.condenseFlow || !1),
    (this.quotingType = '"' === e.quotingType ? 2 : 1),
    (this.forceQuotes = e.forceQuotes || !1),
    (this.replacer = 'function' == typeof e.replacer ? e.replacer : null),
    (this.implicitTypes = this.schema.compiledImplicit),
    (this.explicitTypes = this.schema.compiledExplicit),
    (this.tag = null),
    (this.result = ''),
    (this.duplicates = []),
    (this.usedDuplicates = null));
}
function sh(e, t) {
  for (var r, n = Hs.repeat(' ', t), i = 0, a = -1, o = '', s = e.length; i < s; )
    (-1 === (a = e.indexOf('\n', i))
      ? ((r = e.slice(i)), (i = s))
      : ((r = e.slice(i, a + 1)), (i = a + 1)),
      r.length && '\n' !== r && (o += n),
      (o += r));
  return o;
}
function lh(e, t) {
  return '\n' + Hs.repeat(' ', e.indent * t);
}
function ch(e, t) {
  var r, n;
  for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
    if (e.implicitTypes[r].resolve(t)) return !0;
  return !1;
}
function hh(e) {
  return 32 === e || 9 === e;
}
function dh(e) {
  return (
    (32 <= e && e <= 126) ||
    (161 <= e && e <= 55295 && 8232 !== e && 8233 !== e) ||
    (57344 <= e && e <= 65533 && e !== eh) ||
    (65536 <= e && e <= 1114111)
  );
}
function uh(e) {
  return dh(e) && e !== eh && 13 !== e && 10 !== e;
}
function ph(e, t, r) {
  var n = uh(e),
    i = n && !hh(e);
  return (
    ((r ? n : n && 44 !== e && 91 !== e && 93 !== e && 123 !== e && 125 !== e) &&
      35 !== e &&
      !(58 === t && !i)) ||
    (uh(t) && !hh(t) && 35 === e) ||
    (58 === t && i)
  );
}
function gh(e) {
  return (
    dh(e) &&
    e !== eh &&
    !hh(e) &&
    45 !== e &&
    63 !== e &&
    58 !== e &&
    44 !== e &&
    91 !== e &&
    93 !== e &&
    123 !== e &&
    125 !== e &&
    35 !== e &&
    38 !== e &&
    42 !== e &&
    33 !== e &&
    124 !== e &&
    61 !== e &&
    62 !== e &&
    39 !== e &&
    34 !== e &&
    37 !== e &&
    64 !== e &&
    96 !== e
  );
}
function fh(e) {
  return !hh(e) && 58 !== e;
}
function mh(e, t) {
  var r,
    n = e.charCodeAt(t);
  return n >= 55296 &&
    n <= 56319 &&
    t + 1 < e.length &&
    (r = e.charCodeAt(t + 1)) >= 56320 &&
    r <= 57343
    ? 1024 * (n - 55296) + r - 56320 + 65536
    : n;
}
function bh(e) {
  return /^\n* /.test(e);
}
(ii(oh, 'State'),
  ii(sh, 'indentString'),
  ii(lh, 'generateNextLine'),
  ii(ch, 'testImplicitResolving'),
  ii(hh, 'isWhitespace'),
  ii(dh, 'isPrintable'),
  ii(uh, 'isNsCharOrWhitespace'),
  ii(ph, 'isPlainSafe'),
  ii(gh, 'isPlainSafeFirst'),
  ii(fh, 'isPlainSafeLast'),
  ii(mh, 'codePointAt'),
  ii(bh, 'needIndentIndicator'));
function yh(e, t, r, n, i, a, o, s) {
  var l,
    c = 0,
    h = null,
    d = !1,
    u = !1,
    p = -1 !== n,
    g = -1,
    f = gh(mh(e, 0)) && fh(mh(e, e.length - 1));
  if (t || o)
    for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
      if (!dh((c = mh(e, l)))) return 5;
      ((f = f && ph(c, h, s)), (h = c));
    }
  else {
    for (l = 0; l < e.length; c >= 65536 ? (l += 2) : l++) {
      if (10 === (c = mh(e, l)))
        ((d = !0), p && ((u = u || (l - g - 1 > n && ' ' !== e[g + 1])), (g = l)));
      else if (!dh(c)) return 5;
      ((f = f && ph(c, h, s)), (h = c));
    }
    u = u || (p && l - g - 1 > n && ' ' !== e[g + 1]);
  }
  return d || u
    ? r > 9 && bh(e)
      ? 5
      : o
        ? 2 === a
          ? 5
          : 2
        : u
          ? 4
          : 3
    : !f || o || i(e)
      ? 2 === a
        ? 5
        : 2
      : 1;
}
function xh(e, t, r, n, i) {
  e.dump = (function () {
    if (0 === t.length) return 2 === e.quotingType ? '""' : "''";
    if (!e.noCompatMode && (-1 !== rh.indexOf(t) || nh.test(t)))
      return 2 === e.quotingType ? '"' + t + '"' : "'" + t + "'";
    var a = e.indent * Math.max(1, r),
      o = -1 === e.lineWidth ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - a),
      s = n || (e.flowLevel > -1 && r >= e.flowLevel);
    function l(t) {
      return ch(e, t);
    }
    switch (
      (ii(l, 'testAmbiguity'), yh(t, s, e.indent, o, l, e.quotingType, e.forceQuotes && !n, i))
    ) {
      case 1:
        return t;
      case 2:
        return "'" + t.replace(/'/g, "''") + "'";
      case 3:
        return '|' + kh(t, e.indent) + Ch(sh(t, a));
      case 4:
        return '>' + kh(t, e.indent) + Ch(sh(wh(t, o), a));
      case 5:
        return '"' + _h(t) + '"';
      default:
        throw new Zs('impossible error: invalid scalar style');
    }
  })();
}
function kh(e, t) {
  var r = bh(e) ? String(t) : '',
    n = '\n' === e[e.length - 1];
  return r + (n && ('\n' === e[e.length - 2] || '\n' === e) ? '+' : n ? '' : '-') + '\n';
}
function Ch(e) {
  return '\n' === e[e.length - 1] ? e.slice(0, -1) : e;
}
function wh(e, t) {
  for (
    var r,
      n,
      i,
      a = /(\n+)([^\n]*)/g,
      o =
        ((r = -1 !== (r = e.indexOf('\n')) ? r : e.length),
        (a.lastIndex = r),
        vh(e.slice(0, r), t)),
      s = '\n' === e[0] || ' ' === e[0];
    (i = a.exec(e));
  ) {
    var l = i[1],
      c = i[2];
    ((n = ' ' === c[0]), (o += l + (s || n || '' === c ? '' : '\n') + vh(c, t)), (s = n));
  }
  return o;
}
function vh(e, t) {
  if ('' === e || ' ' === e[0]) return e;
  for (var r, n, i = / [^ ]/g, a = 0, o = 0, s = 0, l = ''; (r = i.exec(e)); )
    ((s = r.index) - a > t && ((n = o > a ? o : s), (l += '\n' + e.slice(a, n)), (a = n + 1)),
      (o = s));
  return (
    (l += '\n'),
    e.length - a > t && o > a ? (l += e.slice(a, o) + '\n' + e.slice(o + 1)) : (l += e.slice(a)),
    l.slice(1)
  );
}
function _h(e) {
  for (var t, r = '', n = 0, i = 0; i < e.length; n >= 65536 ? (i += 2) : i++)
    ((n = mh(e, i)),
      !(t = th[n]) && dh(n) ? ((r += e[i]), n >= 65536 && (r += e[i + 1])) : (r += t || ah(n)));
  return r;
}
function Sh(e, t, r) {
  var n,
    i,
    a,
    o = '',
    s = e.tag;
  for (n = 0, i = r.length; n < i; n += 1)
    ((a = r[n]),
      e.replacer && (a = e.replacer.call(r, String(n), a)),
      (Fh(e, t, a, !1, !1) || (void 0 === a && Fh(e, t, null, !1, !1))) &&
        ('' !== o && (o += ',' + (e.condenseFlow ? '' : ' ')), (o += e.dump)));
  ((e.tag = s), (e.dump = '[' + o + ']'));
}
function Eh(e, t, r, n) {
  var i,
    a,
    o,
    s = '',
    l = e.tag;
  for (i = 0, a = r.length; i < a; i += 1)
    ((o = r[i]),
      e.replacer && (o = e.replacer.call(r, String(i), o)),
      (Fh(e, t + 1, o, !0, !0, !1, !0) || (void 0 === o && Fh(e, t + 1, null, !0, !0, !1, !0))) &&
        ((n && '' === s) || (s += lh(e, t)),
        e.dump && 10 === e.dump.charCodeAt(0) ? (s += '-') : (s += '- '),
        (s += e.dump)));
  ((e.tag = l), (e.dump = s || '[]'));
}
function Dh(e, t, r) {
  var n,
    i,
    a,
    o,
    s,
    l = '',
    c = e.tag,
    h = Object.keys(r);
  for (n = 0, i = h.length; n < i; n += 1)
    ((s = ''),
      '' !== l && (s += ', '),
      e.condenseFlow && (s += '"'),
      (o = r[(a = h[n])]),
      e.replacer && (o = e.replacer.call(r, a, o)),
      Fh(e, t, a, !1, !1) &&
        (e.dump.length > 1024 && (s += '? '),
        (s += e.dump + (e.condenseFlow ? '"' : '') + ':' + (e.condenseFlow ? '' : ' ')),
        Fh(e, t, o, !1, !1) && (l += s += e.dump)));
  ((e.tag = c), (e.dump = '{' + l + '}'));
}
function Ah(e, t, r, n) {
  var i,
    a,
    o,
    s,
    l,
    c,
    h = '',
    d = e.tag,
    u = Object.keys(r);
  if (!0 === e.sortKeys) u.sort();
  else if ('function' == typeof e.sortKeys) u.sort(e.sortKeys);
  else if (e.sortKeys) throw new Zs('sortKeys must be a boolean or a function');
  for (i = 0, a = u.length; i < a; i += 1)
    ((c = ''),
      (n && '' === h) || (c += lh(e, t)),
      (s = r[(o = u[i])]),
      e.replacer && (s = e.replacer.call(r, o, s)),
      Fh(e, t + 1, o, !0, !0, !0) &&
        ((l = (null !== e.tag && '?' !== e.tag) || (e.dump && e.dump.length > 1024)) &&
          (e.dump && 10 === e.dump.charCodeAt(0) ? (c += '?') : (c += '? ')),
        (c += e.dump),
        l && (c += lh(e, t)),
        Fh(e, t + 1, s, !0, l) &&
          (e.dump && 10 === e.dump.charCodeAt(0) ? (c += ':') : (c += ': '), (h += c += e.dump))));
  ((e.tag = d), (e.dump = h || '{}'));
}
function Th(e, t, r) {
  var n, i, a, o, s, l;
  for (a = 0, o = (i = r ? e.explicitTypes : e.implicitTypes).length; a < o; a += 1)
    if (
      ((s = i[a]).instanceOf || s.predicate) &&
      (!s.instanceOf || ('object' == typeof t && t instanceof s.instanceOf)) &&
      (!s.predicate || s.predicate(t))
    ) {
      if (
        (r
          ? s.multi && s.representName
            ? (e.tag = s.representName(t))
            : (e.tag = s.tag)
          : (e.tag = '?'),
        s.represent)
      ) {
        if (
          ((l = e.styleMap[s.tag] || s.defaultStyle), '[object Function]' === Qc.call(s.represent))
        )
          n = s.represent(t, l);
        else {
          if (!Jc.call(s.represent, l))
            throw new Zs('!<' + s.tag + '> tag resolver accepts not "' + l + '" style');
          n = s.represent[l](t, l);
        }
        e.dump = n;
      }
      return !0;
    }
  return !1;
}
function Fh(e, t, r, n, i, a, o) {
  ((e.tag = null), (e.dump = r), Th(e, r, !1) || Th(e, r, !0));
  var s,
    l = Qc.call(e.dump),
    c = n;
  n && (n = e.flowLevel < 0 || e.flowLevel > t);
  var h,
    d,
    u = '[object Object]' === l || '[object Array]' === l;
  if (
    (u && (d = -1 !== (h = e.duplicates.indexOf(r))),
    ((null !== e.tag && '?' !== e.tag) || d || (2 !== e.indent && t > 0)) && (i = !1),
    d && e.usedDuplicates[h])
  )
    e.dump = '*ref_' + h;
  else {
    if ((u && d && !e.usedDuplicates[h] && (e.usedDuplicates[h] = !0), '[object Object]' === l))
      n && 0 !== Object.keys(e.dump).length
        ? (Ah(e, t, e.dump, i), d && (e.dump = '&ref_' + h + e.dump))
        : (Dh(e, t, e.dump), d && (e.dump = '&ref_' + h + ' ' + e.dump));
    else if ('[object Array]' === l)
      n && 0 !== e.dump.length
        ? (e.noArrayIndent && !o && t > 0 ? Eh(e, t - 1, e.dump, i) : Eh(e, t, e.dump, i),
          d && (e.dump = '&ref_' + h + e.dump))
        : (Sh(e, t, e.dump), d && (e.dump = '&ref_' + h + ' ' + e.dump));
    else {
      if ('[object String]' !== l) {
        if ('[object Undefined]' === l) return !1;
        if (e.skipInvalid) return !1;
        throw new Zs('unacceptable kind of an object to dump ' + l);
      }
      '?' !== e.tag && xh(e, e.dump, t, a, c);
    }
    null !== e.tag &&
      '?' !== e.tag &&
      ((s = encodeURI('!' === e.tag[0] ? e.tag.slice(1) : e.tag).replace(/!/g, '%21')),
      (s =
        '!' === e.tag[0]
          ? '!' + s
          : 'tag:yaml.org,2002:' === s.slice(0, 18)
            ? '!!' + s.slice(18)
            : '!<' + s + '>'),
      (e.dump = s + ' ' + e.dump));
  }
  return !0;
}
function Bh(e, t) {
  var r,
    n,
    i = [],
    a = [];
  for (Mh(e, i, a), r = 0, n = a.length; r < n; r += 1) t.duplicates.push(i[a[r]]);
  t.usedDuplicates = new Array(n);
}
function Mh(e, t, r) {
  var n, i, a;
  if (null !== e && 'object' == typeof e)
    if (-1 !== (i = t.indexOf(e))) -1 === r.indexOf(i) && r.push(i);
    else if ((t.push(e), Array.isArray(e))) for (i = 0, a = e.length; i < a; i += 1) Mh(e[i], t, r);
    else for (i = 0, a = (n = Object.keys(e)).length; i < a; i += 1) Mh(e[n[i]], t, r);
}
(ii(yh, 'chooseScalarStyle'),
  ii(xh, 'writeScalar'),
  ii(kh, 'blockHeader'),
  ii(Ch, 'dropEndingNewline'),
  ii(wh, 'foldString'),
  ii(vh, 'foldLine'),
  ii(_h, 'escapeString'),
  ii(Sh, 'writeFlowSequence'),
  ii(Eh, 'writeBlockSequence'),
  ii(Dh, 'writeFlowMapping'),
  ii(Ah, 'writeBlockMapping'),
  ii(Th, 'detectType'),
  ii(Fh, 'writeNode'),
  ii(Bh, 'getDuplicateReferences'),
  ii(Mh, 'inspectNode'),
  ii(function (e, t) {
    var r = new oh((t = t || {}));
    r.noRefs || Bh(e, r);
    var n = e;
    return (
      r.replacer && (n = r.replacer.call({ '': n }, '', n)),
      Fh(r, 0, n, !0, !0) ? r.dump + '\n' : ''
    );
  }, 'dump$1'),
  ii(function (e, t) {
    return function () {
      throw new Error(
        'Function yaml.' +
          e +
          ' is removed in js-yaml 4. Use yaml.' +
          t +
          ' instead, which is now safe by default.'
      );
    };
  }, 'renamed'));
var Nh = Fl,
  Lh = Xc.load,
  Oh = {
    aggregation: 17.25,
    extension: 17.25,
    composition: 17.25,
    dependency: 6,
    lollipop: 13.5,
    arrow_point: 4,
  },
  $h = { arrow_point: 9, arrow_cross: 12.5, arrow_circle: 12.5 };
function Ih(e, t) {
  if (void 0 === e || void 0 === t) return { angle: 0, deltaX: 0, deltaY: 0 };
  ((e = Rh(e)), (t = Rh(t)));
  const [r, n] = [e.x, e.y],
    [i, a] = [t.x, t.y],
    o = i - r,
    s = a - n;
  return { angle: Math.atan(s / o), deltaX: o, deltaY: s };
}
ii(Ih, 'calculateDeltaAndAngle');
var Rh = ii((e) => (Array.isArray(e) ? { x: e[0], y: e[1] } : e), 'pointTransformer'),
  zh = ii(
    (e) => ({
      x: ii(function (t, r, n) {
        let i = 0;
        const a = Rh(n[0]).x < Rh(n[n.length - 1]).x ? 'left' : 'right';
        if (0 === r && Object.hasOwn(Oh, e.arrowTypeStart)) {
          const { angle: t, deltaX: r } = Ih(n[0], n[1]);
          i = Oh[e.arrowTypeStart] * Math.cos(t) * (r >= 0 ? 1 : -1);
        } else if (r === n.length - 1 && Object.hasOwn(Oh, e.arrowTypeEnd)) {
          const { angle: t, deltaX: r } = Ih(n[n.length - 1], n[n.length - 2]);
          i = Oh[e.arrowTypeEnd] * Math.cos(t) * (r >= 0 ? 1 : -1);
        }
        const o = Math.abs(Rh(t).x - Rh(n[n.length - 1]).x),
          s = Math.abs(Rh(t).y - Rh(n[n.length - 1]).y),
          l = Math.abs(Rh(t).x - Rh(n[0]).x),
          c = Math.abs(Rh(t).y - Rh(n[0]).y),
          h = Oh[e.arrowTypeStart],
          d = Oh[e.arrowTypeEnd];
        if (o < d && o > 0 && s < d) {
          let e = d + 1 - o;
          ((e *= 'right' === a ? -1 : 1), (i -= e));
        }
        if (l < h && l > 0 && c < h) {
          let e = h + 1 - l;
          ((e *= 'right' === a ? -1 : 1), (i += e));
        }
        return Rh(t).x + i;
      }, 'x'),
      y: ii(function (t, r, n) {
        let i = 0;
        const a = Rh(n[0]).y < Rh(n[n.length - 1]).y ? 'down' : 'up';
        if (0 === r && Object.hasOwn(Oh, e.arrowTypeStart)) {
          const { angle: t, deltaY: r } = Ih(n[0], n[1]);
          i = Oh[e.arrowTypeStart] * Math.abs(Math.sin(t)) * (r >= 0 ? 1 : -1);
        } else if (r === n.length - 1 && Object.hasOwn(Oh, e.arrowTypeEnd)) {
          const { angle: t, deltaY: r } = Ih(n[n.length - 1], n[n.length - 2]);
          i = Oh[e.arrowTypeEnd] * Math.abs(Math.sin(t)) * (r >= 0 ? 1 : -1);
        }
        const o = Math.abs(Rh(t).y - Rh(n[n.length - 1]).y),
          s = Math.abs(Rh(t).x - Rh(n[n.length - 1]).x),
          l = Math.abs(Rh(t).y - Rh(n[0]).y),
          c = Math.abs(Rh(t).x - Rh(n[0]).x),
          h = Oh[e.arrowTypeStart],
          d = Oh[e.arrowTypeEnd];
        if (o < d && o > 0 && s < d) {
          let e = d + 1 - o;
          ((e *= 'up' === a ? -1 : 1), (i -= e));
        }
        if (l < h && l > 0 && c < h) {
          let e = h + 1 - l;
          ((e *= 'up' === a ? -1 : 1), (i += e));
        }
        return Rh(t).y + i;
      }, 'y'),
    }),
    'getLineFunctionsWithOffset'
  ),
  Ph = ii(({ flowchart: e }) => {
    var t, r;
    const n = (null == (t = null == e ? void 0 : e.subGraphTitleMargin) ? void 0 : t.top) ?? 0,
      i = (null == (r = null == e ? void 0 : e.subGraphTitleMargin) ? void 0 : r.bottom) ?? 0;
    return {
      subGraphTitleTopMargin: n,
      subGraphTitleBottomMargin: i,
      subGraphTitleTotalMargin: n + i,
    };
  }, 'getSubGraphTitleMargins'),
  jh = ii((e) => {
    const { handDrawnSeed: t } = As();
    return {
      fill: e,
      hachureAngle: 120,
      hachureGap: 4,
      fillWeight: 2,
      roughness: 0.7,
      stroke: e,
      seed: t,
    };
  }, 'solidStateFill'),
  qh = ii((e) => {
    const t = Wh([...(e.cssCompiledStyles || []), ...(e.cssStyles || []), ...(e.labelStyle || [])]);
    return { stylesMap: t, stylesArray: [...t] };
  }, 'compileStyles'),
  Wh = ii((e) => {
    const t = new Map();
    return (
      e.forEach((e) => {
        const [r, n] = e.split(':');
        t.set(r.trim(), null == n ? void 0 : n.trim());
      }),
      t
    );
  }, 'styles2Map'),
  Uh = ii(
    (e) =>
      'color' === e ||
      'font-size' === e ||
      'font-family' === e ||
      'font-weight' === e ||
      'font-style' === e ||
      'text-decoration' === e ||
      'text-align' === e ||
      'text-transform' === e ||
      'line-height' === e ||
      'letter-spacing' === e ||
      'word-spacing' === e ||
      'text-shadow' === e ||
      'text-overflow' === e ||
      'white-space' === e ||
      'word-wrap' === e ||
      'word-break' === e ||
      'overflow-wrap' === e ||
      'hyphens' === e,
    'isLabelStyle'
  ),
  Hh = ii((e) => {
    const { stylesArray: t } = qh(e),
      r = [],
      n = [],
      i = [],
      a = [];
    return (
      t.forEach((e) => {
        const t = e[0];
        Uh(t)
          ? r.push(e.join(':') + ' !important')
          : (n.push(e.join(':') + ' !important'),
            t.includes('stroke') && i.push(e.join(':') + ' !important'),
            'fill' === t && a.push(e.join(':') + ' !important'));
      }),
      {
        labelStyles: r.join(';'),
        nodeStyles: n.join(';'),
        stylesArray: t,
        borderStyles: i,
        backgroundStyles: a,
      }
    );
  }, 'styles2String'),
  Gh = ii((e, t) => {
    var r;
    const { themeVariables: n, handDrawnSeed: i } = As(),
      { nodeBorder: a, mainBkg: o } = n,
      { stylesMap: s } = qh(e);
    return Object.assign(
      {
        roughness: 0.7,
        fill: s.get('fill') || o,
        fillStyle: 'hachure',
        fillWeight: 4,
        hachureGap: 5.2,
        stroke: s.get('stroke') || a,
        seed: i,
        strokeWidth: (null == (r = s.get('stroke-width')) ? void 0 : r.replace('px', '')) || 1.3,
        fillLineDash: [0, 0],
        strokeLineDash: Vh(s.get('stroke-dasharray')),
      },
      t
    );
  }, 'userNodeOverrides'),
  Vh = ii((e) => {
    if (!e) return [0, 0];
    const t = e.trim().split(/\s+/).map(Number);
    if (1 === t.length) {
      const e = isNaN(t[0]) ? 0 : t[0];
      return [e, e];
    }
    return [isNaN(t[0]) ? 0 : t[0], isNaN(t[1]) ? 0 : t[1]];
  }, 'getStrokeDashArray'),
  Zh = {},
  Kh = {};
(Object.defineProperty(Kh, '__esModule', { value: !0 }),
  (Kh.BLANK_URL =
    Kh.relativeFirstCharacters =
    Kh.whitespaceEscapeCharsRegex =
    Kh.urlSchemeRegex =
    Kh.ctrlCharactersRegex =
    Kh.htmlCtrlEntityRegex =
    Kh.htmlEntitiesRegex =
    Kh.invalidProtocolRegex =
      void 0),
  (Kh.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im),
  (Kh.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g),
  (Kh.htmlCtrlEntityRegex = /&(newline|tab);/gi),
  (Kh.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim),
  (Kh.urlSchemeRegex = /^.+(:|&colon;)/gim),
  (Kh.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g),
  (Kh.relativeFirstCharacters = ['.', '/']),
  (Kh.BLANK_URL = 'about:blank'),
  Object.defineProperty(Zh, '__esModule', { value: !0 }));
var Yh = (Zh.sanitizeUrl = void 0),
  Xh = Kh;
function Qh(e) {
  return e.replace(Xh.ctrlCharactersRegex, '').replace(Xh.htmlEntitiesRegex, function (e, t) {
    return String.fromCharCode(t);
  });
}
function Jh(e) {
  try {
    return decodeURIComponent(e);
  } catch (t) {
    return e;
  }
}
Yh = Zh.sanitizeUrl = function (e) {
  if (!e) return Xh.BLANK_URL;
  var t,
    r = Jh(e.trim());
  do {
    t =
      (r = Jh(
        (r = Qh(r)
          .replace(Xh.htmlCtrlEntityRegex, '')
          .replace(Xh.ctrlCharactersRegex, '')
          .replace(Xh.whitespaceEscapeCharsRegex, '')
          .trim())
      )).match(Xh.ctrlCharactersRegex) ||
      r.match(Xh.htmlEntitiesRegex) ||
      r.match(Xh.htmlCtrlEntityRegex) ||
      r.match(Xh.whitespaceEscapeCharsRegex);
  } while (t && t.length > 0);
  var n = r;
  if (!n) return Xh.BLANK_URL;
  if (
    (function (e) {
      return Xh.relativeFirstCharacters.indexOf(e[0]) > -1;
    })(n)
  )
    return n;
  var i = n.trimStart(),
    a = i.match(Xh.urlSchemeRegex);
  if (!a) return n;
  var o = a[0].toLowerCase().trim();
  if (Xh.invalidProtocolRegex.test(o)) return Xh.BLANK_URL;
  var s = i.replace(/\\/g, '/');
  if ('mailto:' === o || o.includes('://')) return s;
  if ('http:' === o || 'https:' === o) {
    if (
      !(function (e) {
        return URL.canParse(e);
      })(s)
    )
      return Xh.BLANK_URL;
    var l = new URL(s);
    return (
      (l.protocol = l.protocol.toLowerCase()),
      (l.hostname = l.hostname.toLowerCase()),
      l.toString()
    );
  }
  return s;
};
var ed = 'object' == typeof global && global && global.Object === Object && global,
  td = 'object' == typeof self && self && self.Object === Object && self,
  rd = ed || td || Function('return this')(),
  nd = rd.Symbol,
  id = Object.prototype,
  ad = id.hasOwnProperty,
  od = id.toString,
  sd = nd ? nd.toStringTag : void 0;
var ld = Object.prototype.toString;
var cd = nd ? nd.toStringTag : void 0;
function hd(e) {
  return null == e
    ? void 0 === e
      ? '[object Undefined]'
      : '[object Null]'
    : cd && cd in Object(e)
      ? (function (e) {
          var t = ad.call(e, sd),
            r = e[sd];
          try {
            e[sd] = void 0;
            var n = !0;
          } catch (a) {}
          var i = od.call(e);
          return (n && (t ? (e[sd] = r) : delete e[sd]), i);
        })(e)
      : (function (e) {
          return ld.call(e);
        })(e);
}
function dd(e) {
  var t = typeof e;
  return null != e && ('object' == t || 'function' == t);
}
function ud(e) {
  if (!dd(e)) return !1;
  var t = hd(e);
  return (
    '[object Function]' == t ||
    '[object GeneratorFunction]' == t ||
    '[object AsyncFunction]' == t ||
    '[object Proxy]' == t
  );
}
var pd,
  gd = rd['__core-js_shared__'],
  fd = (pd = /[^.]+$/.exec((gd && gd.keys && gd.keys.IE_PROTO) || '')) ? 'Symbol(src)_1.' + pd : '';
var md = Function.prototype.toString;
function bd(e) {
  if (null != e) {
    try {
      return md.call(e);
    } catch (t) {}
    try {
      return e + '';
    } catch (t) {}
  }
  return '';
}
var yd = /^\[object .+?Constructor\]$/,
  xd = Function.prototype,
  kd = Object.prototype,
  Cd = xd.toString,
  wd = kd.hasOwnProperty,
  vd = RegExp(
    '^' +
      Cd.call(wd)
        .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
      '$'
  );
function _d(e) {
  return !(!dd(e) || ((t = e), fd && fd in t)) && (ud(e) ? vd : yd).test(bd(e));
  var t;
}
function Sd(e, t) {
  var r = (function (e, t) {
    return null == e ? void 0 : e[t];
  })(e, t);
  return _d(r) ? r : void 0;
}
var Ed = Sd(Object, 'create');
var Dd = Object.prototype.hasOwnProperty;
var Ad = Object.prototype.hasOwnProperty;
function Td(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
function Fd(e, t) {
  return e === t || (e != e && t != t);
}
function Bd(e, t) {
  for (var r = e.length; r--; ) if (Fd(e[r][0], t)) return r;
  return -1;
}
((Td.prototype.clear = function () {
  ((this.__data__ = Ed ? Ed(null) : {}), (this.size = 0));
}),
  (Td.prototype.delete = function (e) {
    var t = this.has(e) && delete this.__data__[e];
    return ((this.size -= t ? 1 : 0), t);
  }),
  (Td.prototype.get = function (e) {
    var t = this.__data__;
    if (Ed) {
      var r = t[e];
      return '__lodash_hash_undefined__' === r ? void 0 : r;
    }
    return Dd.call(t, e) ? t[e] : void 0;
  }),
  (Td.prototype.has = function (e) {
    var t = this.__data__;
    return Ed ? void 0 !== t[e] : Ad.call(t, e);
  }),
  (Td.prototype.set = function (e, t) {
    var r = this.__data__;
    return (
      (this.size += this.has(e) ? 0 : 1),
      (r[e] = Ed && void 0 === t ? '__lodash_hash_undefined__' : t),
      this
    );
  }));
var Md = Array.prototype.splice;
function Nd(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
((Nd.prototype.clear = function () {
  ((this.__data__ = []), (this.size = 0));
}),
  (Nd.prototype.delete = function (e) {
    var t = this.__data__,
      r = Bd(t, e);
    return !(r < 0) && (r == t.length - 1 ? t.pop() : Md.call(t, r, 1), --this.size, !0);
  }),
  (Nd.prototype.get = function (e) {
    var t = this.__data__,
      r = Bd(t, e);
    return r < 0 ? void 0 : t[r][1];
  }),
  (Nd.prototype.has = function (e) {
    return Bd(this.__data__, e) > -1;
  }),
  (Nd.prototype.set = function (e, t) {
    var r = this.__data__,
      n = Bd(r, e);
    return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
  }));
var Ld = Sd(rd, 'Map');
function Od(e, t) {
  var r,
    n,
    i = e.__data__;
  return (
    'string' == (n = typeof (r = t)) || 'number' == n || 'symbol' == n || 'boolean' == n
      ? '__proto__' !== r
      : null === r
  )
    ? i['string' == typeof t ? 'string' : 'hash']
    : i.map;
}
function $d(e) {
  var t = -1,
    r = null == e ? 0 : e.length;
  for (this.clear(); ++t < r; ) {
    var n = e[t];
    this.set(n[0], n[1]);
  }
}
(($d.prototype.clear = function () {
  ((this.size = 0), (this.__data__ = { hash: new Td(), map: new (Ld || Nd)(), string: new Td() }));
}),
  ($d.prototype.delete = function (e) {
    var t = Od(this, e).delete(e);
    return ((this.size -= t ? 1 : 0), t);
  }),
  ($d.prototype.get = function (e) {
    return Od(this, e).get(e);
  }),
  ($d.prototype.has = function (e) {
    return Od(this, e).has(e);
  }),
  ($d.prototype.set = function (e, t) {
    var r = Od(this, e),
      n = r.size;
    return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
  }));
function Id(e, t) {
  if ('function' != typeof e || (null != t && 'function' != typeof t))
    throw new TypeError('Expected a function');
  var r = function () {
    var n = arguments,
      i = t ? t.apply(this, n) : n[0],
      a = r.cache;
    if (a.has(i)) return a.get(i);
    var o = e.apply(this, n);
    return ((r.cache = a.set(i, o) || a), o);
  };
  return ((r.cache = new (Id.Cache || $d)()), r);
}
Id.Cache = $d;
function Rd(e) {
  var t = (this.__data__ = new Nd(e));
  this.size = t.size;
}
((Rd.prototype.clear = function () {
  ((this.__data__ = new Nd()), (this.size = 0));
}),
  (Rd.prototype.delete = function (e) {
    var t = this.__data__,
      r = t.delete(e);
    return ((this.size = t.size), r);
  }),
  (Rd.prototype.get = function (e) {
    return this.__data__.get(e);
  }),
  (Rd.prototype.has = function (e) {
    return this.__data__.has(e);
  }),
  (Rd.prototype.set = function (e, t) {
    var r = this.__data__;
    if (r instanceof Nd) {
      var n = r.__data__;
      if (!Ld || n.length < 199) return (n.push([e, t]), (this.size = ++r.size), this);
      r = this.__data__ = new $d(n);
    }
    return (r.set(e, t), (this.size = r.size), this);
  }));
var zd = (function () {
  try {
    var e = Sd(Object, 'defineProperty');
    return (e({}, '', {}), e);
  } catch (t) {}
})();
function Pd(e, t, r) {
  '__proto__' == t && zd
    ? zd(e, t, { configurable: !0, enumerable: !0, value: r, writable: !0 })
    : (e[t] = r);
}
function jd(e, t, r) {
  ((void 0 !== r && !Fd(e[t], r)) || (void 0 === r && !(t in e))) && Pd(e, t, r);
}
var qd = function (e, t, r) {
    for (var n = -1, i = Object(e), a = r(e), o = a.length; o--; ) {
      var s = a[++n];
      if (!1 === t(i[s], s, i)) break;
    }
    return e;
  },
  Wd = 'object' == typeof exports && exports && !exports.nodeType && exports,
  Ud = Wd && 'object' == typeof module && module && !module.nodeType && module,
  Hd = Ud && Ud.exports === Wd ? rd.Buffer : void 0,
  Gd = Hd ? Hd.allocUnsafe : void 0;
function Vd(e, t) {
  if (t) return e.slice();
  var r = e.length,
    n = Gd ? Gd(r) : new e.constructor(r);
  return (e.copy(n), n);
}
var Zd = rd.Uint8Array;
function Kd(e) {
  var t = new e.constructor(e.byteLength);
  return (new Zd(t).set(new Zd(e)), t);
}
function Yd(e, t) {
  var r = t ? Kd(e.buffer) : e.buffer;
  return new e.constructor(r, e.byteOffset, e.length);
}
function Xd(e, t) {
  var r = -1,
    n = e.length;
  for (t || (t = Array(n)); ++r < n; ) t[r] = e[r];
  return t;
}
var Qd = Object.create,
  Jd = (function () {
    function e() {}
    return function (t) {
      if (!dd(t)) return {};
      if (Qd) return Qd(t);
      e.prototype = t;
      var r = new e();
      return ((e.prototype = void 0), r);
    };
  })();
function eu(e, t) {
  return function (r) {
    return e(t(r));
  };
}
var tu = eu(Object.getPrototypeOf, Object),
  ru = Object.prototype;
function nu(e) {
  var t = e && e.constructor;
  return e === (('function' == typeof t && t.prototype) || ru);
}
function iu(e) {
  return 'function' != typeof e.constructor || nu(e) ? {} : Jd(tu(e));
}
function au(e) {
  return null != e && 'object' == typeof e;
}
function ou(e) {
  return au(e) && '[object Arguments]' == hd(e);
}
var su = Object.prototype,
  lu = su.hasOwnProperty,
  cu = su.propertyIsEnumerable,
  hu = ou(
    (function () {
      return arguments;
    })()
  )
    ? ou
    : function (e) {
        return au(e) && lu.call(e, 'callee') && !cu.call(e, 'callee');
      },
  du = Array.isArray;
function uu(e) {
  return 'number' == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991;
}
function pu(e) {
  return null != e && uu(e.length) && !ud(e);
}
function gu(e) {
  return au(e) && pu(e);
}
var fu = 'object' == typeof exports && exports && !exports.nodeType && exports,
  mu = fu && 'object' == typeof module && module && !module.nodeType && module,
  bu = mu && mu.exports === fu ? rd.Buffer : void 0,
  yu =
    (bu ? bu.isBuffer : void 0) ||
    function () {
      return !1;
    },
  xu = Function.prototype,
  ku = Object.prototype,
  Cu = xu.toString,
  wu = ku.hasOwnProperty,
  vu = Cu.call(Object);
var _u = {};
function Su(e) {
  return function (t) {
    return e(t);
  };
}
((_u['[object Float32Array]'] =
  _u['[object Float64Array]'] =
  _u['[object Int8Array]'] =
  _u['[object Int16Array]'] =
  _u['[object Int32Array]'] =
  _u['[object Uint8Array]'] =
  _u['[object Uint8ClampedArray]'] =
  _u['[object Uint16Array]'] =
  _u['[object Uint32Array]'] =
    !0),
  (_u['[object Arguments]'] =
    _u['[object Array]'] =
    _u['[object ArrayBuffer]'] =
    _u['[object Boolean]'] =
    _u['[object DataView]'] =
    _u['[object Date]'] =
    _u['[object Error]'] =
    _u['[object Function]'] =
    _u['[object Map]'] =
    _u['[object Number]'] =
    _u['[object Object]'] =
    _u['[object RegExp]'] =
    _u['[object Set]'] =
    _u['[object String]'] =
    _u['[object WeakMap]'] =
      !1));
var Eu = 'object' == typeof exports && exports && !exports.nodeType && exports,
  Du = Eu && 'object' == typeof module && module && !module.nodeType && module,
  Au = Du && Du.exports === Eu && ed.process,
  Tu = (function () {
    try {
      var e = Du && Du.require && Du.require('util').types;
      return e || (Au && Au.binding && Au.binding('util'));
    } catch (t) {}
  })(),
  Fu = Tu && Tu.isTypedArray,
  Bu = Fu
    ? Su(Fu)
    : function (e) {
        return au(e) && uu(e.length) && !!_u[hd(e)];
      };
function Mu(e, t) {
  if (('constructor' !== t || 'function' != typeof e[t]) && '__proto__' != t) return e[t];
}
var Nu = Object.prototype.hasOwnProperty;
function Lu(e, t, r) {
  var n = e[t];
  (Nu.call(e, t) && Fd(n, r) && (void 0 !== r || t in e)) || Pd(e, t, r);
}
function Ou(e, t, r, n) {
  var i = !r;
  r || (r = {});
  for (var a = -1, o = t.length; ++a < o; ) {
    var s = t[a],
      l = void 0;
    (void 0 === l && (l = e[s]), i ? Pd(r, s, l) : Lu(r, s, l));
  }
  return r;
}
var $u = /^(?:0|[1-9]\d*)$/;
function Iu(e, t) {
  var r = typeof e;
  return (
    !!(t = null == t ? 9007199254740991 : t) &&
    ('number' == r || ('symbol' != r && $u.test(e))) &&
    e > -1 &&
    e % 1 == 0 &&
    e < t
  );
}
var Ru = Object.prototype.hasOwnProperty;
function zu(e, t) {
  var r = du(e),
    n = !r && hu(e),
    i = !r && !n && yu(e),
    a = !r && !n && !i && Bu(e),
    o = r || n || i || a,
    s = o
      ? (function (e, t) {
          for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r);
          return n;
        })(e.length, String)
      : [],
    l = s.length;
  for (var c in e)
    (!t && !Ru.call(e, c)) ||
      (o &&
        ('length' == c ||
          (i && ('offset' == c || 'parent' == c)) ||
          (a && ('buffer' == c || 'byteLength' == c || 'byteOffset' == c)) ||
          Iu(c, l))) ||
      s.push(c);
  return s;
}
var Pu = Object.prototype.hasOwnProperty;
function ju(e) {
  if (!dd(e))
    return (function (e) {
      var t = [];
      if (null != e) for (var r in Object(e)) t.push(r);
      return t;
    })(e);
  var t = nu(e),
    r = [];
  for (var n in e) ('constructor' != n || (!t && Pu.call(e, n))) && r.push(n);
  return r;
}
function qu(e) {
  return pu(e) ? zu(e, !0) : ju(e);
}
function Wu(e, t, r, n, i, a, o) {
  var s = Mu(e, r),
    l = Mu(t, r),
    c = o.get(l);
  if (c) jd(e, r, c);
  else {
    var h,
      d = a ? a(s, l, r + '', e, t, o) : void 0,
      u = void 0 === d;
    if (u) {
      var p = du(l),
        g = !p && yu(l),
        f = !p && !g && Bu(l);
      ((d = l),
        p || g || f
          ? du(s)
            ? (d = s)
            : gu(s)
              ? (d = Xd(s))
              : g
                ? ((u = !1), (d = Vd(l, !0)))
                : f
                  ? ((u = !1), (d = Yd(l, !0)))
                  : (d = [])
          : (function (e) {
                if (!au(e) || '[object Object]' != hd(e)) return !1;
                var t = tu(e);
                if (null === t) return !0;
                var r = wu.call(t, 'constructor') && t.constructor;
                return 'function' == typeof r && r instanceof r && Cu.call(r) == vu;
              })(l) || hu(l)
            ? ((d = s), hu(s) ? (d = Ou((h = s), qu(h))) : (dd(s) && !ud(s)) || (d = iu(l)))
            : (u = !1));
    }
    (u && (o.set(l, d), i(d, l, n, a, o), o.delete(l)), jd(e, r, d));
  }
}
function Uu(e, t, r, n, i) {
  e !== t &&
    qd(
      t,
      function (a, o) {
        if ((i || (i = new Rd()), dd(a))) Wu(e, t, o, r, Uu, n, i);
        else {
          var s = n ? n(Mu(e, o), a, o + '', e, t, i) : void 0;
          (void 0 === s && (s = a), jd(e, o, s));
        }
      },
      qu
    );
}
function Hu(e) {
  return e;
}
var Gu = Math.max;
function Vu(e, t, r) {
  return (
    (t = Gu(void 0 === t ? e.length - 1 : t, 0)),
    function () {
      for (var n = arguments, i = -1, a = Gu(n.length - t, 0), o = Array(a); ++i < a; )
        o[i] = n[t + i];
      i = -1;
      for (var s = Array(t + 1); ++i < t; ) s[i] = n[i];
      return (
        (s[t] = r(o)),
        (function (e, t, r) {
          switch (r.length) {
            case 0:
              return e.call(t);
            case 1:
              return e.call(t, r[0]);
            case 2:
              return e.call(t, r[0], r[1]);
            case 3:
              return e.call(t, r[0], r[1], r[2]);
          }
          return e.apply(t, r);
        })(e, this, s)
      );
    }
  );
}
function Zu(e) {
  return function () {
    return e;
  };
}
var Ku = zd
    ? function (e, t) {
        return zd(e, 'toString', { configurable: !0, enumerable: !1, value: Zu(t), writable: !0 });
      }
    : Hu,
  Yu = Date.now;
var Xu,
  Qu,
  Ju,
  ep =
    ((Xu = Ku),
    (Qu = 0),
    (Ju = 0),
    function () {
      var e = Yu(),
        t = 16 - (e - Ju);
      if (((Ju = e), t > 0)) {
        if (++Qu >= 800) return arguments[0];
      } else Qu = 0;
      return Xu.apply(void 0, arguments);
    });
function tp(e, t) {
  return ep(Vu(e, t, Hu), e + '');
}
function rp(e, t, r) {
  if (!dd(r)) return !1;
  var n = typeof t;
  return !!('number' == n ? pu(r) && Iu(t, r.length) : 'string' == n && t in r) && Fd(r[t], e);
}
function np(e) {
  return tp(function (t, r) {
    var n = -1,
      i = r.length,
      a = i > 1 ? r[i - 1] : void 0,
      o = i > 2 ? r[2] : void 0;
    for (
      a = e.length > 3 && 'function' == typeof a ? (i--, a) : void 0,
        o && rp(r[0], r[1], o) && ((a = i < 3 ? void 0 : a), (i = 1)),
        t = Object(t);
      ++n < i;
    ) {
      var s = r[n];
      s && e(t, s, n, a);
    }
    return t;
  });
}
var ip = np(function (e, t, r) {
    Uu(e, t, r);
  }),
  ap = '​',
  op = {
    curveBasis: H,
    curveBasisClosed: U,
    curveBasisOpen: W,
    curveBumpX: q,
    curveBumpY: j,
    curveBundle: P,
    curveCardinalClosed: z,
    curveCardinalOpen: R,
    curveCardinal: I,
    curveCatmullRomClosed: $,
    curveCatmullRomOpen: O,
    curveCatmullRom: L,
    curveLinear: N,
    curveLinearClosed: M,
    curveMonotoneX: B,
    curveMonotoneY: F,
    curveNatural: T,
    curveStep: A,
    curveStepAfter: D,
    curveStepBefore: E,
  },
  sp = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi,
  lp = ii(function (e, t) {
    const r = cp(e, /(?:init\b)|(?:initialize\b)/);
    let n = {};
    if (Array.isArray(r)) {
      const e = r.map((e) => e.args);
      (uo(e), (n = Ga(n, [...e])));
    } else n = r.args;
    if (!n) return;
    let i = ja(e, t);
    const a = 'config';
    return (
      void 0 !== n[a] && ('flowchart-v2' === i && (i = 'flowchart'), (n[i] = n[a]), delete n[a]),
      n
    );
  }, 'detectInit'),
  cp = ii(function (e, t = null) {
    var r, n;
    try {
      const i = new RegExp(`[%]{2}(?![{]${sp.source})(?=[}][%]{2}).*\n`, 'ig');
      let a;
      ((e = e.trim().replace(i, '').replace(/'/gm, '"')),
        si.debug(
          `Detecting diagram directive${null !== t ? ' type:' + t : ''} based on the text:${e}`
        ));
      const o = [];
      for (; null !== (a = Ia.exec(e)); )
        if (
          (a.index === Ia.lastIndex && Ia.lastIndex++,
          (a && !t) ||
            (t && (null == (r = a[1]) ? void 0 : r.match(t))) ||
            (t && (null == (n = a[2]) ? void 0 : n.match(t))))
        ) {
          const e = a[1] ? a[1] : a[2],
            t = a[3] ? a[3].trim() : a[4] ? JSON.parse(a[4].trim()) : null;
          o.push({ type: e, args: t });
        }
      return 0 === o.length ? { type: e, args: null } : 1 === o.length ? o[0] : o;
    } catch (i) {
      return (
        si.error(
          `ERROR: ${i.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`
        ),
        { type: void 0, args: null }
      );
    }
  }, 'detectDirective'),
  hp = ii(function (e) {
    return e.replace(Ia, '');
  }, 'removeDirectives'),
  dp = ii(function (e, t) {
    for (const [r, n] of t.entries()) if (n.match(e)) return r;
    return -1;
  }, 'isSubstringInArray');
function up(e, t) {
  if (!e) return t;
  const r = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`;
  return op[r] ?? t;
}
function pp(e, t) {
  const r = e.trim();
  if (r) return 'loose' !== t.securityLevel ? Yh(r) : r;
}
(ii(up, 'interpolateToCurve'), ii(pp, 'formatUrl'));
var gp = ii((e, ...t) => {
  const r = e.split('.'),
    n = r.length - 1,
    i = r[n];
  let a = window;
  for (let o = 0; o < n; o++)
    if (((a = a[r[o]]), !a)) return void si.error(`Function name: ${e} not found in window`);
  a[i](...t);
}, 'runFunc');
function fp(e, t) {
  return e && t ? Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)) : 0;
}
function mp(e) {
  let t,
    r = 0;
  e.forEach((e) => {
    ((r += fp(e, t)), (t = e));
  });
  return xp(e, r / 2);
}
function bp(e) {
  return 1 === e.length ? e[0] : mp(e);
}
(ii(fp, 'distance'), ii(mp, 'traverseEdge'), ii(bp, 'calcLabelPosition'));
var yp = ii((e, t = 2) => {
    const r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, 'roundNumber'),
  xp = ii((e, t) => {
    let r,
      n = t;
    for (const i of e) {
      if (r) {
        const e = fp(i, r);
        if (0 === e) return r;
        if (e < n) n -= e;
        else {
          const t = n / e;
          if (t <= 0) return r;
          if (t >= 1) return { x: i.x, y: i.y };
          if (t > 0 && t < 1)
            return { x: yp((1 - t) * r.x + t * i.x, 5), y: yp((1 - t) * r.y + t * i.y, 5) };
        }
      }
      r = i;
    }
    throw new Error('Could not find a suitable point for the given distance');
  }, 'calculatePoint'),
  kp = ii((e, t, r) => {
    (si.info(`our points ${JSON.stringify(t)}`), t[0] !== r && (t = t.reverse()));
    const n = xp(t, 25),
      i = e ? 10 : 5,
      a = Math.atan2(t[0].y - n.y, t[0].x - n.x),
      o = { x: 0, y: 0 };
    return (
      (o.x = Math.sin(a) * i + (t[0].x + n.x) / 2),
      (o.y = -Math.cos(a) * i + (t[0].y + n.y) / 2),
      o
    );
  }, 'calcCardinalityPosition');
function Cp(e, t, r) {
  const n = structuredClone(r);
  (si.info('our points', n), 'start_left' !== t && 'start_right' !== t && n.reverse());
  const i = xp(n, 25 + e),
    a = 10 + 0.5 * e,
    o = Math.atan2(n[0].y - i.y, n[0].x - i.x),
    s = { x: 0, y: 0 };
  return (
    'start_left' === t
      ? ((s.x = Math.sin(o + Math.PI) * a + (n[0].x + i.x) / 2),
        (s.y = -Math.cos(o + Math.PI) * a + (n[0].y + i.y) / 2))
      : 'end_right' === t
        ? ((s.x = Math.sin(o - Math.PI) * a + (n[0].x + i.x) / 2 - 5),
          (s.y = -Math.cos(o - Math.PI) * a + (n[0].y + i.y) / 2 - 5))
        : 'end_left' === t
          ? ((s.x = Math.sin(o) * a + (n[0].x + i.x) / 2 - 5),
            (s.y = -Math.cos(o) * a + (n[0].y + i.y) / 2 - 5))
          : ((s.x = Math.sin(o) * a + (n[0].x + i.x) / 2),
            (s.y = -Math.cos(o) * a + (n[0].y + i.y) / 2)),
    s
  );
}
function wp(e) {
  let t = '',
    r = '';
  for (const n of e)
    void 0 !== n &&
      (n.startsWith('color:') || n.startsWith('text-align:')
        ? (r = r + n + ';')
        : (t = t + n + ';'));
  return { style: t, labelStyle: r };
}
(ii(Cp, 'calcTerminalLabelPosition'), ii(wp, 'getStylesFromArray'));
var vp = 0,
  _p = ii(() => (vp++, 'id-' + Math.random().toString(36).substr(2, 12) + '-' + vp), 'generateId');
function Sp(e) {
  let t = '';
  const r = '0123456789abcdef';
  for (let n = 0; n < e; n++) t += r.charAt(Math.floor(16 * Math.random()));
  return t;
}
ii(Sp, 'makeRandomHex');
var Ep = ii((e) => Sp(e.length), 'random'),
  Dp = ii(function () {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      anchor: 'start',
      style: '#666',
      width: 100,
      height: 100,
      textMargin: 0,
      rx: 0,
      ry: 0,
      valign: void 0,
      text: '',
    };
  }, 'getTextObj'),
  Ap = ii(function (e, t) {
    const r = t.text.replace(as.lineBreakRegex, ' '),
      [, n] = zp(t.fontSize),
      i = e.append('text');
    (i.attr('x', t.x),
      i.attr('y', t.y),
      i.style('text-anchor', t.anchor),
      i.style('font-family', t.fontFamily),
      i.style('font-size', n),
      i.style('font-weight', t.fontWeight),
      i.attr('fill', t.fill),
      void 0 !== t.class && i.attr('class', t.class));
    const a = i.append('tspan');
    return (a.attr('x', t.x + 2 * t.textMargin), a.attr('fill', t.fill), a.text(r), i);
  }, 'drawSimpleText'),
  Tp = Id(
    (e, t, r) => {
      if (!e) return e;
      if (
        ((r = Object.assign(
          { fontSize: 12, fontWeight: 400, fontFamily: 'Arial', joinWith: '<br/>' },
          r
        )),
        as.lineBreakRegex.test(e))
      )
        return e;
      const n = e.split(' ').filter(Boolean),
        i = [];
      let a = '';
      return (
        n.forEach((e, o) => {
          const s = Mp(`${e} `, r),
            l = Mp(a, r);
          if (s > t) {
            const { hyphenatedStrings: n, remainingWord: o } = Fp(e, t, '-', r);
            (i.push(a, ...n), (a = o));
          } else l + s >= t ? (i.push(a), (a = e)) : (a = [a, e].filter(Boolean).join(' '));
          o + 1 === n.length && i.push(a);
        }),
        i.filter((e) => '' !== e).join(r.joinWith)
      );
    },
    (e, t, r) => `${e}${t}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`
  ),
  Fp = Id(
    (e, t, r = '-', n) => {
      n = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: 'Arial', margin: 0 }, n);
      const i = [...e],
        a = [];
      let o = '';
      return (
        i.forEach((e, s) => {
          const l = `${o}${e}`;
          if (Mp(l, n) >= t) {
            const e = s + 1,
              t = i.length === e,
              n = `${l}${r}`;
            (a.push(t ? l : n), (o = ''));
          } else o = l;
        }),
        { hyphenatedStrings: a, remainingWord: o }
      );
    },
    (e, t, r = '-', n) => `${e}${t}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`
  );
function Bp(e, t) {
  return Lp(e, t).height;
}
function Mp(e, t) {
  return Lp(e, t).width;
}
(ii(Bp, 'calculateTextHeight'), ii(Mp, 'calculateTextWidth'));
var Np,
  Lp = Id(
    (e, t) => {
      const { fontSize: r = 12, fontFamily: n = 'Arial', fontWeight: i = 400 } = t;
      if (!e) return { width: 0, height: 0 };
      const [, a] = zp(r),
        o = ['sans-serif', n],
        s = e.split(as.lineBreakRegex),
        l = [],
        c = S('body');
      if (!c.remove) return { width: 0, height: 0, lineHeight: 0 };
      const h = c.append('svg');
      for (const d of o) {
        let e = 0;
        const t = { width: 0, height: 0, lineHeight: 0 };
        for (const r of s) {
          const n = Dp();
          n.text = r || '​';
          const o = Ap(h, n).style('font-size', a).style('font-weight', i).style('font-family', d),
            s = (o._groups || o)[0][0].getBBox();
          if (0 === s.width && 0 === s.height) throw new Error('svg element not in render tree');
          ((t.width = Math.round(Math.max(t.width, s.width))),
            (e = Math.round(s.height)),
            (t.height += e),
            (t.lineHeight = Math.round(Math.max(t.lineHeight, e))));
        }
        l.push(t);
      }
      h.remove();
      return l[
        isNaN(l[1].height) ||
        isNaN(l[1].width) ||
        isNaN(l[1].lineHeight) ||
        (l[0].height > l[1].height && l[0].width > l[1].width && l[0].lineHeight > l[1].lineHeight)
          ? 0
          : 1
      ];
    },
    (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`
  ),
  Op =
    (ii(
      (s = class {
        constructor(e = !1, t) {
          ((this.count = 0),
            (this.count = t ? t.length : 0),
            (this.next = e ? () => this.count++ : () => Date.now()));
        }
      }),
      'InitIDGenerator'
    ),
    s),
  $p = ii(function (e) {
    return (
      (Np = Np || document.createElement('div')),
      (e = escape(e).replace(/%26/g, '&').replace(/%23/g, '#').replace(/%3B/g, ';')),
      (Np.innerHTML = e),
      unescape(Np.textContent)
    );
  }, 'entityDecode');
function Ip(e) {
  return 'str' in e;
}
ii(Ip, 'isDetailedError');
var Rp = ii((e, t, r, n) => {
    var i;
    if (!n) return;
    const a = null == (i = e.node()) ? void 0 : i.getBBox();
    a &&
      e
        .append('text')
        .text(n)
        .attr('text-anchor', 'middle')
        .attr('x', a.x + a.width / 2)
        .attr('y', -r)
        .attr('class', t);
  }, 'insertTitle'),
  zp = ii((e) => {
    if ('number' == typeof e) return [e, e + 'px'];
    const t = parseInt(e ?? '', 10);
    return Number.isNaN(t) ? [void 0, void 0] : e === String(t) ? [t, e + 'px'] : [t, e];
  }, 'parseFontSize');
function Pp(e, t) {
  return ip({}, e, t);
}
ii(Pp, 'cleanAndMerge');
var jp = {
    assignWithDepth: Ga,
    wrapLabel: Tp,
    calculateTextHeight: Bp,
    calculateTextWidth: Mp,
    calculateTextDimensions: Lp,
    cleanAndMerge: Pp,
    detectInit: lp,
    detectDirective: cp,
    isSubstringInArray: dp,
    interpolateToCurve: up,
    calcLabelPosition: bp,
    calcCardinalityPosition: kp,
    calcTerminalLabelPosition: Cp,
    formatUrl: pp,
    getStylesFromArray: wp,
    generateId: _p,
    random: Ep,
    runFunc: gp,
    entityDecode: $p,
    insertTitle: Rp,
    isLabelCoordinateInPath: Gp,
    parseFontSize: zp,
    InitIDGenerator: Op,
  },
  qp = ii(function (e) {
    let t = e;
    return (
      (t = t.replace(/style.*:\S*#.*;/g, function (e) {
        return e.substring(0, e.length - 1);
      })),
      (t = t.replace(/classDef.*:\S*#.*;/g, function (e) {
        return e.substring(0, e.length - 1);
      })),
      (t = t.replace(/#\w+;/g, function (e) {
        const t = e.substring(1, e.length - 1);
        return /^\+?\d+$/.test(t) ? 'ﬂ°°' + t + '¶ß' : 'ﬂ°' + t + '¶ß';
      })),
      t
    );
  }, 'encodeEntities'),
  Wp = ii(function (e) {
    return e.replace(/ﬂ°°/g, '&#').replace(/ﬂ°/g, '&').replace(/¶ß/g, ';');
  }, 'decodeEntities'),
  Up = ii(
    (e, t, { counter: r = 0, prefix: n, suffix: i }, a) =>
      a || `${n ? `${n}_` : ''}${e}_${t}_${r}${i ? `_${i}` : ''}`,
    'getEdgeId'
  );
function Hp(e) {
  return e ?? null;
}
function Gp(e, t) {
  const r = Math.round(e.x),
    n = Math.round(e.y),
    i = t.replace(/(\d+\.\d+)/g, (e) => Math.round(parseFloat(e)).toString());
  return i.includes(r.toString()) || i.includes(n.toString());
}
(ii(Hp, 'handleUndefinedAttr'), ii(Gp, 'isLabelCoordinateInPath'));
const Vp = Object.freeze({ left: 0, top: 0, width: 16, height: 16 }),
  Zp = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 }),
  Kp = Object.freeze({ ...Vp, ...Zp }),
  Yp = Object.freeze({ ...Kp, body: '', hidden: !1 }),
  Xp = Object.freeze({ width: null, height: null }),
  Qp = Object.freeze({ ...Xp, ...Zp }),
  Jp = (e, t) => !!e && !(!((t && '' === e.prefix) || e.prefix) || !e.name);
function eg(e, t) {
  const r = (function (e, t) {
    const r = {};
    (!e.hFlip != !t.hFlip && (r.hFlip = !0), !e.vFlip != !t.vFlip && (r.vFlip = !0));
    const n = ((e.rotate || 0) + (t.rotate || 0)) % 4;
    return (n && (r.rotate = n), r);
  })(e, t);
  for (const n in Yp)
    n in Zp
      ? n in e && !(n in r) && (r[n] = Zp[n])
      : n in t
        ? (r[n] = t[n])
        : n in e && (r[n] = e[n]);
  return r;
}
function tg(e, t, r) {
  const n = e.icons,
    i = e.aliases || Object.create(null);
  let a = {};
  function o(e) {
    a = eg(n[e] || i[e], a);
  }
  return (o(t), r.forEach(o), eg(e, a));
}
function rg(e, t) {
  if (e.icons[t]) return tg(e, t, []);
  const r = (function (e, t) {
    const r = e.icons,
      n = e.aliases || Object.create(null),
      i = Object.create(null);
    return (
      (t || Object.keys(r).concat(Object.keys(n))).forEach(function e(t) {
        if (r[t]) return (i[t] = []);
        if (!(t in i)) {
          i[t] = null;
          const r = n[t] && n[t].parent,
            a = r && e(r);
          a && (i[t] = [r].concat(a));
        }
        return i[t];
      }),
      i
    );
  })(e, [t])[t];
  return r ? tg(e, t, r) : null;
}
const ng = /(-?[0-9.]*[0-9]+[0-9.]*)/g,
  ig = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ag(e, t, r) {
  if (1 === t) return e;
  if (((r = r || 100), 'number' == typeof e)) return Math.ceil(e * t * r) / r;
  if ('string' != typeof e) return e;
  const n = e.split(ng);
  if (null === n || !n.length) return e;
  const i = [];
  let a = n.shift(),
    o = ig.test(a);
  for (;;) {
    if (o) {
      const e = parseFloat(a);
      isNaN(e) ? i.push(a) : i.push(Math.ceil(e * t * r) / r);
    } else i.push(a);
    if (((a = n.shift()), void 0 === a)) return i.join('');
    o = !o;
  }
}
const og = /\sid="(\S+)"/g,
  sg = new Map();
function lg(e) {
  const t = [];
  let r;
  for (; (r = og.exec(e)); ) t.push(r[1]);
  if (!t.length) return e;
  const n = 'suffix' + ((16777216 * Math.random()) | Date.now()).toString(16);
  return (
    t.forEach((t) => {
      const r = (function (e) {
          e = e.replace(/[0-9]+$/, '') || 'a';
          const t = sg.get(e) || 0;
          return (sg.set(e, t + 1), t ? `${e}${t}` : e);
        })(t),
        i = t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      e = e.replace(new RegExp('([#;"])(' + i + ')([")]|\\.[a-z])', 'g'), '$1' + r + n + '$3');
    }),
    (e = e.replace(new RegExp(n, 'g'), ''))
  );
}
function cg() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null,
  };
}
var hg = {
  async: !1,
  breaks: !1,
  extensions: null,
  gfm: !0,
  hooks: null,
  pedantic: !1,
  renderer: null,
  silent: !1,
  tokenizer: null,
  walkTokens: null,
};
function dg(e) {
  hg = e;
}
var ug = { exec: () => null };
function pg(e, t = '') {
  let r = 'string' == typeof e ? e : e.source,
    n = {
      replace: (e, t) => {
        let i = 'string' == typeof t ? t : t.source;
        return ((i = i.replace(fg.caret, '$1')), (r = r.replace(e, i)), n);
      },
      getRegex: () => new RegExp(r, t),
    };
  return n;
}
var gg = (() => {
    try {
      return !!new RegExp('(?<=1)(?<!1)');
    } catch {
      return !1;
    }
  })(),
  fg = {
    codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
    outputLinkReplace: /\\([\[\]])/g,
    indentCodeCompensation: /^(\s+)(?:```)/,
    beginningSpace: /^\s+/,
    endingHash: /#$/,
    startingSpaceChar: /^ /,
    endingSpaceChar: / $/,
    nonSpaceChar: /[^ ]/,
    newLineCharGlobal: /\n/g,
    tabCharGlobal: /\t/g,
    multipleSpaceGlobal: /\s+/g,
    blankLine: /^[ \t]*$/,
    doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
    blockquoteStart: /^ {0,3}>/,
    blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
    blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
    listReplaceTabs: /^\t+/,
    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
    listIsTask: /^\[[ xX]\] /,
    listReplaceTask: /^\[[ xX]\] +/,
    anyLine: /\n.*\n/,
    hrefBrackets: /^<(.*)>$/,
    tableDelimiter: /[:|]/,
    tableAlignChars: /^\||\| *$/g,
    tableRowBlankLine: /\n[ \t]*$/,
    tableAlignRight: /^ *-+: *$/,
    tableAlignCenter: /^ *:-+: *$/,
    tableAlignLeft: /^ *:-+ *$/,
    startATag: /^<a /i,
    endATag: /^<\/a>/i,
    startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
    endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
    startAngleBracket: /^</,
    endAngleBracket: />$/,
    pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
    unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
    escapeTest: /[&<>"']/,
    escapeReplace: /[&<>"']/g,
    escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
    escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
    unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,
    caret: /(^|[^\[])\^/g,
    percentDecode: /%25/g,
    findPipe: /\|/g,
    splitPipe: / \|/,
    slashPipe: /\\\|/g,
    carriageReturn: /\r\n|\r/g,
    spaceLine: /^ +$/gm,
    notSpaceStart: /^\S*/,
    endingNewline: /\n$/,
    listItemRegex: (e) => new RegExp(`^( {0,3}${e})((?:[\t ][^\\n]*)?(?:\\n|$))`),
    nextBulletRegex: (e) =>
      new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ \t][^\\n]*)?(?:\\n|$))`),
    hrRegex: (e) =>
      new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
    fencesBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`),
    headingBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`),
    htmlBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, 'i'),
  },
  mg = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  bg = /(?:[*+-]|\d{1,9}[.)])/,
  yg =
    /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  xg = pg(yg)
    .replace(/bull/g, bg)
    .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .replace(/\|table/g, '')
    .getRegex(),
  kg = pg(yg)
    .replace(/bull/g, bg)
    .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
    .replace(/blockquote/g, / {0,3}>/)
    .replace(/heading/g, / {0,3}#{1,6}/)
    .replace(/html/g, / {0,3}<[^\n>]+>\n/)
    .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/)
    .getRegex(),
  Cg = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  wg = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,
  vg = pg(
    /^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/
  )
    .replace('label', wg)
    .replace('title', /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/)
    .getRegex(),
  _g = pg(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
    .replace(/bull/g, bg)
    .getRegex(),
  Sg =
    'address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul',
  Eg = /<!--(?:-?>|[\s\S]*?(?:-->|$))/,
  Dg = pg(
    '^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$))',
    'i'
  )
    .replace('comment', Eg)
    .replace('tag', Sg)
    .replace(
      'attribute',
      / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
    )
    .getRegex(),
  Ag = pg(Cg)
    .replace('hr', mg)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('|lheading', '')
    .replace('|table', '')
    .replace('blockquote', ' {0,3}>')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', Sg)
    .getRegex(),
  Tg = {
    blockquote: pg(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
      .replace('paragraph', Ag)
      .getRegex(),
    code: /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,
    def: vg,
    fences:
      /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    hr: mg,
    html: Dg,
    lheading: xg,
    list: _g,
    newline: /^(?:[ \t]*(?:\n|$))+/,
    paragraph: Ag,
    table: ug,
    text: /^[^\n]+/,
  },
  Fg = pg(
    '^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)'
  )
    .replace('hr', mg)
    .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
    .replace('blockquote', ' {0,3}>')
    .replace('code', '(?: {4}| {0,3}\t)[^\\n]')
    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
    .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
    .replace('tag', Sg)
    .getRegex(),
  Bg = {
    ...Tg,
    lheading: kg,
    table: Fg,
    paragraph: pg(Cg)
      .replace('hr', mg)
      .replace('heading', ' {0,3}#{1,6}(?:\\s|$)')
      .replace('|lheading', '')
      .replace('table', Fg)
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ')
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
      .replace('tag', Sg)
      .getRegex(),
  },
  Mg = {
    ...Tg,
    html: pg(
      '^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))'
    )
      .replace('comment', Eg)
      .replace(
        /tag/g,
        '(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b'
      )
      .getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: ug,
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: pg(Cg)
      .replace('hr', mg)
      .replace('heading', ' *#{1,6} *[^\n]')
      .replace('lheading', xg)
      .replace('|table', '')
      .replace('blockquote', ' {0,3}>')
      .replace('|fences', '')
      .replace('|list', '')
      .replace('|html', '')
      .replace('|tag', '')
      .getRegex(),
  },
  Ng = /^( {2,}|\\)\n(?!\s*$)/,
  Lg = /[\p{P}\p{S}]/u,
  Og = /[\s\p{P}\p{S}]/u,
  $g = /[^\s\p{P}\p{S}]/u,
  Ig = pg(/^((?![*_])punctSpace)/, 'u')
    .replace(/punctSpace/g, Og)
    .getRegex(),
  Rg = /(?!~)[\p{P}\p{S}]/u,
  zg = pg(/link|precode-code|html/, 'g')
    .replace(
      'link',
      /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/
    )
    .replace('precode-', gg ? '(?<!`)()' : '(^^|[^`])')
    .replace('code', /(?<b>`+)[^`]+\k<b>(?!`)/)
    .replace('html', /<(?! )[^<>]*?>/)
    .getRegex(),
  Pg = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,
  jg = pg(Pg, 'u').replace(/punct/g, Lg).getRegex(),
  qg = pg(Pg, 'u').replace(/punct/g, Rg).getRegex(),
  Wg =
    '^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)',
  Ug = pg(Wg, 'gu')
    .replace(/notPunctSpace/g, $g)
    .replace(/punctSpace/g, Og)
    .replace(/punct/g, Lg)
    .getRegex(),
  Hg = pg(Wg, 'gu')
    .replace(/notPunctSpace/g, /(?:[^\s\p{P}\p{S}]|~)/u)
    .replace(/punctSpace/g, /(?!~)[\s\p{P}\p{S}]/u)
    .replace(/punct/g, Rg)
    .getRegex(),
  Gg = pg(
    '^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)',
    'gu'
  )
    .replace(/notPunctSpace/g, $g)
    .replace(/punctSpace/g, Og)
    .replace(/punct/g, Lg)
    .getRegex(),
  Vg = pg(/\\(punct)/, 'gu')
    .replace(/punct/g, Lg)
    .getRegex(),
  Zg = pg(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
    .replace(
      'email',
      /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/
    )
    .getRegex(),
  Kg = pg(Eg).replace('(?:--\x3e|$)', '--\x3e').getRegex(),
  Yg = pg(
    '^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'
  )
    .replace('comment', Kg)
    .replace(
      'attribute',
      /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/
    )
    .getRegex(),
  Xg = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/,
  Qg = pg(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/)
    .replace('label', Xg)
    .replace('href', /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/)
    .replace('title', /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/)
    .getRegex(),
  Jg = pg(/^!?\[(label)\]\[(ref)\]/)
    .replace('label', Xg)
    .replace('ref', wg)
    .getRegex(),
  ef = pg(/^!?\[(ref)\](?:\[\])?/)
    .replace('ref', wg)
    .getRegex(),
  tf = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/,
  rf = {
    _backpedal: ug,
    anyPunctuation: Vg,
    autolink: Zg,
    blockSkip: zg,
    br: Ng,
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    del: ug,
    emStrongLDelim: jg,
    emStrongRDelimAst: Ug,
    emStrongRDelimUnd: Gg,
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    link: Qg,
    nolink: ef,
    punctuation: Ig,
    reflink: Jg,
    reflinkSearch: pg('reflink|nolink(?!\\()', 'g')
      .replace('reflink', Jg)
      .replace('nolink', ef)
      .getRegex(),
    tag: Yg,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    url: ug,
  },
  nf = {
    ...rf,
    link: pg(/^!?\[(label)\]\((.*?)\)/)
      .replace('label', Xg)
      .getRegex(),
    reflink: pg(/^!?\[(label)\]\s*\[([^\]]*)\]/)
      .replace('label', Xg)
      .getRegex(),
  },
  af = {
    ...rf,
    emStrongRDelimAst: Hg,
    emStrongLDelim: qg,
    url: pg(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)
      .replace('protocol', tf)
      .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)
      .getRegex(),
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,
    text: pg(
      /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    )
      .replace('protocol', tf)
      .getRegex(),
  },
  of = {
    ...af,
    br: pg(Ng).replace('{2,}', '*').getRegex(),
    text: pg(af.text)
      .replace('\\b_', '\\b_| {2,}\\n')
      .replace(/\{2,\}/g, '*')
      .getRegex(),
  },
  sf = { normal: Tg, gfm: Bg, pedantic: Mg },
  lf = { normal: rf, gfm: af, breaks: of, pedantic: nf },
  cf = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' },
  hf = (e) => cf[e];
function df(e, t) {
  if (t) {
    if (fg.escapeTest.test(e)) return e.replace(fg.escapeReplace, hf);
  } else if (fg.escapeTestNoEncode.test(e)) return e.replace(fg.escapeReplaceNoEncode, hf);
  return e;
}
function uf(e) {
  try {
    e = encodeURI(e).replace(fg.percentDecode, '%');
  } catch {
    return null;
  }
  return e;
}
function pf(e, t) {
  var r;
  let n = e
      .replace(fg.findPipe, (e, t, r) => {
        let n = !1,
          i = t;
        for (; --i >= 0 && '\\' === r[i]; ) n = !n;
        return n ? '|' : ' |';
      })
      .split(fg.splitPipe),
    i = 0;
  if (
    (n[0].trim() || n.shift(),
    n.length > 0 && !(null == (r = n.at(-1)) ? void 0 : r.trim()) && n.pop(),
    t)
  )
    if (n.length > t) n.splice(t);
    else for (; n.length < t; ) n.push('');
  for (; i < n.length; i++) n[i] = n[i].trim().replace(fg.slashPipe, '|');
  return n;
}
function gf(e, t, r) {
  let n = e.length;
  if (0 === n) return '';
  let i = 0;
  for (; i < n; ) {
    if (e.charAt(n - i - 1) !== t) break;
    i++;
  }
  return e.slice(0, n - i);
}
function ff(e, t, r, n, i) {
  let a = t.href,
    o = t.title || null,
    s = e[1].replace(i.other.outputLinkReplace, '$1');
  n.state.inLink = !0;
  let l = {
    type: '!' === e[0].charAt(0) ? 'image' : 'link',
    raw: r,
    href: a,
    title: o,
    text: s,
    tokens: n.inlineTokens(s),
  };
  return ((n.state.inLink = !1), l);
}
var mf = class {
    constructor(e) {
      (d(this, 'options'), d(this, 'rules'), d(this, 'lexer'), (this.options = e || hg));
    }
    space(e) {
      let t = this.rules.block.newline.exec(e);
      if (t && t[0].length > 0) return { type: 'space', raw: t[0] };
    }
    code(e) {
      let t = this.rules.block.code.exec(e);
      if (t) {
        let e = t[0].replace(this.rules.other.codeRemoveIndent, '');
        return {
          type: 'code',
          raw: t[0],
          codeBlockStyle: 'indented',
          text: this.options.pedantic ? e : gf(e, '\n'),
        };
      }
    }
    fences(e) {
      let t = this.rules.block.fences.exec(e);
      if (t) {
        let e = t[0],
          r = (function (e, t, r) {
            let n = e.match(r.other.indentCodeCompensation);
            if (null === n) return t;
            let i = n[1];
            return t
              .split('\n')
              .map((e) => {
                let t = e.match(r.other.beginningSpace);
                if (null === t) return e;
                let [n] = t;
                return n.length >= i.length ? e.slice(i.length) : e;
              })
              .join('\n');
          })(e, t[3] || '', this.rules);
        return {
          type: 'code',
          raw: e,
          lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : t[2],
          text: r,
        };
      }
    }
    heading(e) {
      let t = this.rules.block.heading.exec(e);
      if (t) {
        let e = t[2].trim();
        if (this.rules.other.endingHash.test(e)) {
          let t = gf(e, '#');
          (this.options.pedantic || !t || this.rules.other.endingSpaceChar.test(t)) &&
            (e = t.trim());
        }
        return {
          type: 'heading',
          raw: t[0],
          depth: t[1].length,
          text: e,
          tokens: this.lexer.inline(e),
        };
      }
    }
    hr(e) {
      let t = this.rules.block.hr.exec(e);
      if (t) return { type: 'hr', raw: gf(t[0], '\n') };
    }
    blockquote(e) {
      let t = this.rules.block.blockquote.exec(e);
      if (t) {
        let e = gf(t[0], '\n').split('\n'),
          r = '',
          n = '',
          i = [];
        for (; e.length > 0; ) {
          let t,
            a = !1,
            o = [];
          for (t = 0; t < e.length; t++)
            if (this.rules.other.blockquoteStart.test(e[t])) (o.push(e[t]), (a = !0));
            else {
              if (a) break;
              o.push(e[t]);
            }
          e = e.slice(t);
          let s = o.join('\n'),
            l = s
              .replace(this.rules.other.blockquoteSetextReplace, '\n    $1')
              .replace(this.rules.other.blockquoteSetextReplace2, '');
          ((r = r ? `${r}\n${s}` : s), (n = n ? `${n}\n${l}` : l));
          let c = this.lexer.state.top;
          if (
            ((this.lexer.state.top = !0),
            this.lexer.blockTokens(l, i, !0),
            (this.lexer.state.top = c),
            0 === e.length)
          )
            break;
          let h = i.at(-1);
          if ('code' === (null == h ? void 0 : h.type)) break;
          if ('blockquote' === (null == h ? void 0 : h.type)) {
            let t = h,
              a = t.raw + '\n' + e.join('\n'),
              o = this.blockquote(a);
            ((i[i.length - 1] = o),
              (r = r.substring(0, r.length - t.raw.length) + o.raw),
              (n = n.substring(0, n.length - t.text.length) + o.text));
            break;
          }
          if ('list' === (null == h ? void 0 : h.type)) {
            let t = h,
              a = t.raw + '\n' + e.join('\n'),
              o = this.list(a);
            ((i[i.length - 1] = o),
              (r = r.substring(0, r.length - h.raw.length) + o.raw),
              (n = n.substring(0, n.length - t.raw.length) + o.raw),
              (e = a.substring(i.at(-1).raw.length).split('\n')));
            continue;
          }
        }
        return { type: 'blockquote', raw: r, tokens: i, text: n };
      }
    }
    list(e) {
      let t = this.rules.block.list.exec(e);
      if (t) {
        let r = t[1].trim(),
          n = r.length > 1,
          i = {
            type: 'list',
            raw: '',
            ordered: n,
            start: n ? +r.slice(0, -1) : '',
            loose: !1,
            items: [],
          };
        ((r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`),
          this.options.pedantic && (r = n ? r : '[*+-]'));
        let a = this.rules.other.listItemRegex(r),
          o = !1;
        for (; e; ) {
          let r = !1,
            n = '',
            s = '';
          if (!(t = a.exec(e)) || this.rules.block.hr.test(e)) break;
          ((n = t[0]), (e = e.substring(n.length)));
          let l = t[2]
              .split('\n', 1)[0]
              .replace(this.rules.other.listReplaceTabs, (e) => ' '.repeat(3 * e.length)),
            c = e.split('\n', 1)[0],
            h = !l.trim(),
            d = 0;
          if (
            (this.options.pedantic
              ? ((d = 2), (s = l.trimStart()))
              : h
                ? (d = t[1].length + 1)
                : ((d = t[2].search(this.rules.other.nonSpaceChar)),
                  (d = d > 4 ? 1 : d),
                  (s = l.slice(d)),
                  (d += t[1].length)),
            h &&
              this.rules.other.blankLine.test(c) &&
              ((n += c + '\n'), (e = e.substring(c.length + 1)), (r = !0)),
            !r)
          ) {
            let t = this.rules.other.nextBulletRegex(d),
              r = this.rules.other.hrRegex(d),
              i = this.rules.other.fencesBeginRegex(d),
              a = this.rules.other.headingBeginRegex(d),
              o = this.rules.other.htmlBeginRegex(d);
            for (; e; ) {
              let u,
                p = e.split('\n', 1)[0];
              if (
                ((c = p),
                this.options.pedantic
                  ? ((c = c.replace(this.rules.other.listReplaceNesting, '  ')), (u = c))
                  : (u = c.replace(this.rules.other.tabCharGlobal, '    ')),
                i.test(c) || a.test(c) || o.test(c) || t.test(c) || r.test(c))
              )
                break;
              if (u.search(this.rules.other.nonSpaceChar) >= d || !c.trim()) s += '\n' + u.slice(d);
              else {
                if (
                  h ||
                  l
                    .replace(this.rules.other.tabCharGlobal, '    ')
                    .search(this.rules.other.nonSpaceChar) >= 4 ||
                  i.test(l) ||
                  a.test(l) ||
                  r.test(l)
                )
                  break;
                s += '\n' + c;
              }
              (!h && !c.trim() && (h = !0),
                (n += p + '\n'),
                (e = e.substring(p.length + 1)),
                (l = u.slice(d)));
            }
          }
          i.loose || (o ? (i.loose = !0) : this.rules.other.doubleBlankLine.test(n) && (o = !0));
          let u,
            p = null;
          (this.options.gfm &&
            ((p = this.rules.other.listIsTask.exec(s)),
            p && ((u = '[ ] ' !== p[0]), (s = s.replace(this.rules.other.listReplaceTask, '')))),
            i.items.push({
              type: 'list_item',
              raw: n,
              task: !!p,
              checked: u,
              loose: !1,
              text: s,
              tokens: [],
            }),
            (i.raw += n));
        }
        let s = i.items.at(-1);
        if (!s) return;
        ((s.raw = s.raw.trimEnd()), (s.text = s.text.trimEnd()), (i.raw = i.raw.trimEnd()));
        for (let e = 0; e < i.items.length; e++)
          if (
            ((this.lexer.state.top = !1),
            (i.items[e].tokens = this.lexer.blockTokens(i.items[e].text, [])),
            !i.loose)
          ) {
            let t = i.items[e].tokens.filter((e) => 'space' === e.type),
              r = t.length > 0 && t.some((e) => this.rules.other.anyLine.test(e.raw));
            i.loose = r;
          }
        if (i.loose) for (let e = 0; e < i.items.length; e++) i.items[e].loose = !0;
        return i;
      }
    }
    html(e) {
      let t = this.rules.block.html.exec(e);
      if (t)
        return {
          type: 'html',
          block: !0,
          raw: t[0],
          pre: 'pre' === t[1] || 'script' === t[1] || 'style' === t[1],
          text: t[0],
        };
    }
    def(e) {
      let t = this.rules.block.def.exec(e);
      if (t) {
        let e = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' '),
          r = t[2]
            ? t[2]
                .replace(this.rules.other.hrefBrackets, '$1')
                .replace(this.rules.inline.anyPunctuation, '$1')
            : '',
          n = t[3]
            ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1')
            : t[3];
        return { type: 'def', tag: e, raw: t[0], href: r, title: n };
      }
    }
    table(e) {
      var t;
      let r = this.rules.block.table.exec(e);
      if (!r || !this.rules.other.tableDelimiter.test(r[2])) return;
      let n = pf(r[1]),
        i = r[2].replace(this.rules.other.tableAlignChars, '').split('|'),
        a = (null == (t = r[3]) ? void 0 : t.trim())
          ? r[3].replace(this.rules.other.tableRowBlankLine, '').split('\n')
          : [],
        o = { type: 'table', raw: r[0], header: [], align: [], rows: [] };
      if (n.length === i.length) {
        for (let e of i)
          this.rules.other.tableAlignRight.test(e)
            ? o.align.push('right')
            : this.rules.other.tableAlignCenter.test(e)
              ? o.align.push('center')
              : this.rules.other.tableAlignLeft.test(e)
                ? o.align.push('left')
                : o.align.push(null);
        for (let e = 0; e < n.length; e++)
          o.header.push({
            text: n[e],
            tokens: this.lexer.inline(n[e]),
            header: !0,
            align: o.align[e],
          });
        for (let e of a)
          o.rows.push(
            pf(e, o.header.length).map((e, t) => ({
              text: e,
              tokens: this.lexer.inline(e),
              header: !1,
              align: o.align[t],
            }))
          );
        return o;
      }
    }
    lheading(e) {
      let t = this.rules.block.lheading.exec(e);
      if (t)
        return {
          type: 'heading',
          raw: t[0],
          depth: '=' === t[2].charAt(0) ? 1 : 2,
          text: t[1],
          tokens: this.lexer.inline(t[1]),
        };
    }
    paragraph(e) {
      let t = this.rules.block.paragraph.exec(e);
      if (t) {
        let e = '\n' === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1];
        return { type: 'paragraph', raw: t[0], text: e, tokens: this.lexer.inline(e) };
      }
    }
    text(e) {
      let t = this.rules.block.text.exec(e);
      if (t) return { type: 'text', raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
    }
    escape(e) {
      let t = this.rules.inline.escape.exec(e);
      if (t) return { type: 'escape', raw: t[0], text: t[1] };
    }
    tag(e) {
      let t = this.rules.inline.tag.exec(e);
      if (t)
        return (
          !this.lexer.state.inLink && this.rules.other.startATag.test(t[0])
            ? (this.lexer.state.inLink = !0)
            : this.lexer.state.inLink &&
              this.rules.other.endATag.test(t[0]) &&
              (this.lexer.state.inLink = !1),
          !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0])
            ? (this.lexer.state.inRawBlock = !0)
            : this.lexer.state.inRawBlock &&
              this.rules.other.endPreScriptTag.test(t[0]) &&
              (this.lexer.state.inRawBlock = !1),
          {
            type: 'html',
            raw: t[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: t[0],
          }
        );
    }
    link(e) {
      let t = this.rules.inline.link.exec(e);
      if (t) {
        let e = t[2].trim();
        if (!this.options.pedantic && this.rules.other.startAngleBracket.test(e)) {
          if (!this.rules.other.endAngleBracket.test(e)) return;
          let t = gf(e.slice(0, -1), '\\');
          if ((e.length - t.length) % 2 == 0) return;
        } else {
          let e = (function (e, t) {
            if (-1 === e.indexOf(t[1])) return -1;
            let r = 0;
            for (let n = 0; n < e.length; n++)
              if ('\\' === e[n]) n++;
              else if (e[n] === t[0]) r++;
              else if (e[n] === t[1] && (r--, r < 0)) return n;
            return r > 0 ? -2 : -1;
          })(t[2], '()');
          if (-2 === e) return;
          if (e > -1) {
            let r = (0 === t[0].indexOf('!') ? 5 : 4) + t[1].length + e;
            ((t[2] = t[2].substring(0, e)), (t[0] = t[0].substring(0, r).trim()), (t[3] = ''));
          }
        }
        let r = t[2],
          n = '';
        if (this.options.pedantic) {
          let e = this.rules.other.pedanticHrefTitle.exec(r);
          e && ((r = e[1]), (n = e[3]));
        } else n = t[3] ? t[3].slice(1, -1) : '';
        return (
          (r = r.trim()),
          this.rules.other.startAngleBracket.test(r) &&
            (r =
              this.options.pedantic && !this.rules.other.endAngleBracket.test(e)
                ? r.slice(1)
                : r.slice(1, -1)),
          ff(
            t,
            {
              href: r && r.replace(this.rules.inline.anyPunctuation, '$1'),
              title: n && n.replace(this.rules.inline.anyPunctuation, '$1'),
            },
            t[0],
            this.lexer,
            this.rules
          )
        );
      }
    }
    reflink(e, t) {
      let r;
      if ((r = this.rules.inline.reflink.exec(e)) || (r = this.rules.inline.nolink.exec(e))) {
        let e = t[(r[2] || r[1]).replace(this.rules.other.multipleSpaceGlobal, ' ').toLowerCase()];
        if (!e) {
          let e = r[0].charAt(0);
          return { type: 'text', raw: e, text: e };
        }
        return ff(r, e, r[0], this.lexer, this.rules);
      }
    }
    emStrong(e, t, r = '') {
      let n = this.rules.inline.emStrongLDelim.exec(e);
      if (
        !(!n || (n[3] && r.match(this.rules.other.unicodeAlphaNumeric))) &&
        ((!n[1] && !n[2]) || !r || this.rules.inline.punctuation.exec(r))
      ) {
        let r,
          i,
          a = [...n[0]].length - 1,
          o = a,
          s = 0,
          l =
            '*' === n[0][0]
              ? this.rules.inline.emStrongRDelimAst
              : this.rules.inline.emStrongRDelimUnd;
        for (l.lastIndex = 0, t = t.slice(-1 * e.length + a); null != (n = l.exec(t)); ) {
          if (((r = n[1] || n[2] || n[3] || n[4] || n[5] || n[6]), !r)) continue;
          if (((i = [...r].length), n[3] || n[4])) {
            o += i;
            continue;
          }
          if ((n[5] || n[6]) && a % 3 && !((a + i) % 3)) {
            s += i;
            continue;
          }
          if (((o -= i), o > 0)) continue;
          i = Math.min(i, i + o + s);
          let t = [...n[0]][0].length,
            l = e.slice(0, a + n.index + t + i);
          if (Math.min(a, i) % 2) {
            let e = l.slice(1, -1);
            return { type: 'em', raw: l, text: e, tokens: this.lexer.inlineTokens(e) };
          }
          let c = l.slice(2, -2);
          return { type: 'strong', raw: l, text: c, tokens: this.lexer.inlineTokens(c) };
        }
      }
    }
    codespan(e) {
      let t = this.rules.inline.code.exec(e);
      if (t) {
        let e = t[2].replace(this.rules.other.newLineCharGlobal, ' '),
          r = this.rules.other.nonSpaceChar.test(e),
          n =
            this.rules.other.startingSpaceChar.test(e) && this.rules.other.endingSpaceChar.test(e);
        return (
          r && n && (e = e.substring(1, e.length - 1)),
          { type: 'codespan', raw: t[0], text: e }
        );
      }
    }
    br(e) {
      let t = this.rules.inline.br.exec(e);
      if (t) return { type: 'br', raw: t[0] };
    }
    del(e) {
      let t = this.rules.inline.del.exec(e);
      if (t) return { type: 'del', raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
    }
    autolink(e) {
      let t = this.rules.inline.autolink.exec(e);
      if (t) {
        let e, r;
        return (
          '@' === t[2] ? ((e = t[1]), (r = 'mailto:' + e)) : ((e = t[1]), (r = e)),
          { type: 'link', raw: t[0], text: e, href: r, tokens: [{ type: 'text', raw: e, text: e }] }
        );
      }
    }
    url(e) {
      var t;
      let r;
      if ((r = this.rules.inline.url.exec(e))) {
        let e, n;
        if ('@' === r[2]) ((e = r[0]), (n = 'mailto:' + e));
        else {
          let i;
          do {
            ((i = r[0]),
              (r[0] =
                (null == (t = this.rules.inline._backpedal.exec(r[0])) ? void 0 : t[0]) ?? ''));
          } while (i !== r[0]);
          ((e = r[0]), (n = 'www.' === r[1] ? 'http://' + r[0] : r[0]));
        }
        return {
          type: 'link',
          raw: r[0],
          text: e,
          href: n,
          tokens: [{ type: 'text', raw: e, text: e }],
        };
      }
    }
    inlineText(e) {
      let t = this.rules.inline.text.exec(e);
      if (t) {
        let e = this.lexer.state.inRawBlock;
        return { type: 'text', raw: t[0], text: t[0], escaped: e };
      }
    }
  },
  bf = class e {
    constructor(e) {
      (d(this, 'tokens'),
        d(this, 'options'),
        d(this, 'state'),
        d(this, 'tokenizer'),
        d(this, 'inlineQueue'),
        (this.tokens = []),
        (this.tokens.links = Object.create(null)),
        (this.options = e || hg),
        (this.options.tokenizer = this.options.tokenizer || new mf()),
        (this.tokenizer = this.options.tokenizer),
        (this.tokenizer.options = this.options),
        (this.tokenizer.lexer = this),
        (this.inlineQueue = []),
        (this.state = { inLink: !1, inRawBlock: !1, top: !0 }));
      let t = { other: fg, block: sf.normal, inline: lf.normal };
      (this.options.pedantic
        ? ((t.block = sf.pedantic), (t.inline = lf.pedantic))
        : this.options.gfm &&
          ((t.block = sf.gfm), this.options.breaks ? (t.inline = lf.breaks) : (t.inline = lf.gfm)),
        (this.tokenizer.rules = t));
    }
    static get rules() {
      return { block: sf, inline: lf };
    }
    static lex(t, r) {
      return new e(r).lex(t);
    }
    static lexInline(t, r) {
      return new e(r).inlineTokens(t);
    }
    lex(e) {
      ((e = e.replace(fg.carriageReturn, '\n')), this.blockTokens(e, this.tokens));
      for (let t = 0; t < this.inlineQueue.length; t++) {
        let e = this.inlineQueue[t];
        this.inlineTokens(e.src, e.tokens);
      }
      return ((this.inlineQueue = []), this.tokens);
    }
    blockTokens(e, t = [], r = !1) {
      var n, i, a;
      for (
        this.options.pedantic &&
        (e = e.replace(fg.tabCharGlobal, '    ').replace(fg.spaceLine, ''));
        e;
      ) {
        let o;
        if (
          null == (i = null == (n = this.options.extensions) ? void 0 : n.block)
            ? void 0
            : i.some(
                (r) =>
                  !!(o = r.call({ lexer: this }, e, t)) &&
                  ((e = e.substring(o.raw.length)), t.push(o), !0)
              )
        )
          continue;
        if ((o = this.tokenizer.space(e))) {
          e = e.substring(o.raw.length);
          let r = t.at(-1);
          1 === o.raw.length && void 0 !== r ? (r.raw += '\n') : t.push(o);
          continue;
        }
        if ((o = this.tokenizer.code(e))) {
          e = e.substring(o.raw.length);
          let r = t.at(-1);
          'paragraph' === (null == r ? void 0 : r.type) || 'text' === (null == r ? void 0 : r.type)
            ? ((r.raw += (r.raw.endsWith('\n') ? '' : '\n') + o.raw),
              (r.text += '\n' + o.text),
              (this.inlineQueue.at(-1).src = r.text))
            : t.push(o);
          continue;
        }
        if ((o = this.tokenizer.fences(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.heading(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.hr(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.blockquote(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.list(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.html(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.def(e))) {
          e = e.substring(o.raw.length);
          let r = t.at(-1);
          'paragraph' === (null == r ? void 0 : r.type) || 'text' === (null == r ? void 0 : r.type)
            ? ((r.raw += (r.raw.endsWith('\n') ? '' : '\n') + o.raw),
              (r.text += '\n' + o.raw),
              (this.inlineQueue.at(-1).src = r.text))
            : this.tokens.links[o.tag] ||
              ((this.tokens.links[o.tag] = { href: o.href, title: o.title }), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.table(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        if ((o = this.tokenizer.lheading(e))) {
          ((e = e.substring(o.raw.length)), t.push(o));
          continue;
        }
        let s = e;
        if (null == (a = this.options.extensions) ? void 0 : a.startBlock) {
          let t,
            r = 1 / 0,
            n = e.slice(1);
          (this.options.extensions.startBlock.forEach((e) => {
            ((t = e.call({ lexer: this }, n)),
              'number' == typeof t && t >= 0 && (r = Math.min(r, t)));
          }),
            r < 1 / 0 && r >= 0 && (s = e.substring(0, r + 1)));
        }
        if (this.state.top && (o = this.tokenizer.paragraph(s))) {
          let n = t.at(-1);
          (r && 'paragraph' === (null == n ? void 0 : n.type)
            ? ((n.raw += (n.raw.endsWith('\n') ? '' : '\n') + o.raw),
              (n.text += '\n' + o.text),
              this.inlineQueue.pop(),
              (this.inlineQueue.at(-1).src = n.text))
            : t.push(o),
            (r = s.length !== e.length),
            (e = e.substring(o.raw.length)));
          continue;
        }
        if ((o = this.tokenizer.text(e))) {
          e = e.substring(o.raw.length);
          let r = t.at(-1);
          'text' === (null == r ? void 0 : r.type)
            ? ((r.raw += (r.raw.endsWith('\n') ? '' : '\n') + o.raw),
              (r.text += '\n' + o.text),
              this.inlineQueue.pop(),
              (this.inlineQueue.at(-1).src = r.text))
            : t.push(o);
          continue;
        }
        if (e) {
          let t = 'Infinite loop on byte: ' + e.charCodeAt(0);
          if (this.options.silent) break;
          throw new Error(t);
        }
      }
      return ((this.state.top = !0), t);
    }
    inline(e, t = []) {
      return (this.inlineQueue.push({ src: e, tokens: t }), t);
    }
    inlineTokens(e, t = []) {
      var r, n, i, a, o;
      let s,
        l = e,
        c = null;
      if (this.tokens.links) {
        let e = Object.keys(this.tokens.links);
        if (e.length > 0)
          for (; null != (c = this.tokenizer.rules.inline.reflinkSearch.exec(l)); )
            e.includes(c[0].slice(c[0].lastIndexOf('[') + 1, -1)) &&
              (l =
                l.slice(0, c.index) +
                '[' +
                'a'.repeat(c[0].length - 2) +
                ']' +
                l.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
      }
      for (; null != (c = this.tokenizer.rules.inline.anyPunctuation.exec(l)); )
        l =
          l.slice(0, c.index) +
          '++' +
          l.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
      for (; null != (c = this.tokenizer.rules.inline.blockSkip.exec(l)); )
        ((s = c[2] ? c[2].length : 0),
          (l =
            l.slice(0, c.index + s) +
            '[' +
            'a'.repeat(c[0].length - s - 2) +
            ']' +
            l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex)));
      l =
        (null == (n = null == (r = this.options.hooks) ? void 0 : r.emStrongMask)
          ? void 0
          : n.call({ lexer: this }, l)) ?? l;
      let h = !1,
        d = '';
      for (; e; ) {
        let r;
        if (
          (h || (d = ''),
          (h = !1),
          null == (a = null == (i = this.options.extensions) ? void 0 : i.inline)
            ? void 0
            : a.some(
                (n) =>
                  !!(r = n.call({ lexer: this }, e, t)) &&
                  ((e = e.substring(r.raw.length)), t.push(r), !0)
              ))
        )
          continue;
        if ((r = this.tokenizer.escape(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.tag(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.link(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.reflink(e, this.tokens.links))) {
          e = e.substring(r.raw.length);
          let n = t.at(-1);
          'text' === r.type && 'text' === (null == n ? void 0 : n.type)
            ? ((n.raw += r.raw), (n.text += r.text))
            : t.push(r);
          continue;
        }
        if ((r = this.tokenizer.emStrong(e, l, d))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.codespan(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.br(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.del(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if ((r = this.tokenizer.autolink(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        if (!this.state.inLink && (r = this.tokenizer.url(e))) {
          ((e = e.substring(r.raw.length)), t.push(r));
          continue;
        }
        let n = e;
        if (null == (o = this.options.extensions) ? void 0 : o.startInline) {
          let t,
            r = 1 / 0,
            i = e.slice(1);
          (this.options.extensions.startInline.forEach((e) => {
            ((t = e.call({ lexer: this }, i)),
              'number' == typeof t && t >= 0 && (r = Math.min(r, t)));
          }),
            r < 1 / 0 && r >= 0 && (n = e.substring(0, r + 1)));
        }
        if ((r = this.tokenizer.inlineText(n))) {
          ((e = e.substring(r.raw.length)),
            '_' !== r.raw.slice(-1) && (d = r.raw.slice(-1)),
            (h = !0));
          let n = t.at(-1);
          'text' === (null == n ? void 0 : n.type)
            ? ((n.raw += r.raw), (n.text += r.text))
            : t.push(r);
          continue;
        }
        if (e) {
          let t = 'Infinite loop on byte: ' + e.charCodeAt(0);
          if (this.options.silent) break;
          throw new Error(t);
        }
      }
      return t;
    }
  },
  yf = class {
    constructor(e) {
      (d(this, 'options'), d(this, 'parser'), (this.options = e || hg));
    }
    space(e) {
      return '';
    }
    code({ text: e, lang: t, escaped: r }) {
      var n;
      let i = null == (n = (t || '').match(fg.notSpaceStart)) ? void 0 : n[0],
        a = e.replace(fg.endingNewline, '') + '\n';
      return i
        ? '<pre><code class="language-' + df(i) + '">' + (r ? a : df(a, !0)) + '</code></pre>\n'
        : '<pre><code>' + (r ? a : df(a, !0)) + '</code></pre>\n';
    }
    blockquote({ tokens: e }) {
      return `<blockquote>\n${this.parser.parse(e)}</blockquote>\n`;
    }
    html({ text: e }) {
      return e;
    }
    def(e) {
      return '';
    }
    heading({ tokens: e, depth: t }) {
      return `<h${t}>${this.parser.parseInline(e)}</h${t}>\n`;
    }
    hr(e) {
      return '<hr>\n';
    }
    list(e) {
      let t = e.ordered,
        r = e.start,
        n = '';
      for (let a = 0; a < e.items.length; a++) {
        let t = e.items[a];
        n += this.listitem(t);
      }
      let i = t ? 'ol' : 'ul';
      return '<' + i + (t && 1 !== r ? ' start="' + r + '"' : '') + '>\n' + n + '</' + i + '>\n';
    }
    listitem(e) {
      var t;
      let r = '';
      if (e.task) {
        let n = this.checkbox({ checked: !!e.checked });
        e.loose
          ? 'paragraph' === (null == (t = e.tokens[0]) ? void 0 : t.type)
            ? ((e.tokens[0].text = n + ' ' + e.tokens[0].text),
              e.tokens[0].tokens &&
                e.tokens[0].tokens.length > 0 &&
                'text' === e.tokens[0].tokens[0].type &&
                ((e.tokens[0].tokens[0].text = n + ' ' + df(e.tokens[0].tokens[0].text)),
                (e.tokens[0].tokens[0].escaped = !0)))
            : e.tokens.unshift({ type: 'text', raw: n + ' ', text: n + ' ', escaped: !0 })
          : (r += n + ' ');
      }
      return ((r += this.parser.parse(e.tokens, !!e.loose)), `<li>${r}</li>\n`);
    }
    checkbox({ checked: e }) {
      return '<input ' + (e ? 'checked="" ' : '') + 'disabled="" type="checkbox">';
    }
    paragraph({ tokens: e }) {
      return `<p>${this.parser.parseInline(e)}</p>\n`;
    }
    table(e) {
      let t = '',
        r = '';
      for (let i = 0; i < e.header.length; i++) r += this.tablecell(e.header[i]);
      t += this.tablerow({ text: r });
      let n = '';
      for (let i = 0; i < e.rows.length; i++) {
        let t = e.rows[i];
        r = '';
        for (let e = 0; e < t.length; e++) r += this.tablecell(t[e]);
        n += this.tablerow({ text: r });
      }
      return (
        n && (n = `<tbody>${n}</tbody>`),
        '<table>\n<thead>\n' + t + '</thead>\n' + n + '</table>\n'
      );
    }
    tablerow({ text: e }) {
      return `<tr>\n${e}</tr>\n`;
    }
    tablecell(e) {
      let t = this.parser.parseInline(e.tokens),
        r = e.header ? 'th' : 'td';
      return (e.align ? `<${r} align="${e.align}">` : `<${r}>`) + t + `</${r}>\n`;
    }
    strong({ tokens: e }) {
      return `<strong>${this.parser.parseInline(e)}</strong>`;
    }
    em({ tokens: e }) {
      return `<em>${this.parser.parseInline(e)}</em>`;
    }
    codespan({ text: e }) {
      return `<code>${df(e, !0)}</code>`;
    }
    br(e) {
      return '<br>';
    }
    del({ tokens: e }) {
      return `<del>${this.parser.parseInline(e)}</del>`;
    }
    link({ href: e, title: t, tokens: r }) {
      let n = this.parser.parseInline(r),
        i = uf(e);
      if (null === i) return n;
      let a = '<a href="' + (e = i) + '"';
      return (t && (a += ' title="' + df(t) + '"'), (a += '>' + n + '</a>'), a);
    }
    image({ href: e, title: t, text: r, tokens: n }) {
      n && (r = this.parser.parseInline(n, this.parser.textRenderer));
      let i = uf(e);
      if (null === i) return df(r);
      let a = `<img src="${(e = i)}" alt="${r}"`;
      return (t && (a += ` title="${df(t)}"`), (a += '>'), a);
    }
    text(e) {
      return 'tokens' in e && e.tokens
        ? this.parser.parseInline(e.tokens)
        : 'escaped' in e && e.escaped
          ? e.text
          : df(e.text);
    }
  },
  xf = class {
    strong({ text: e }) {
      return e;
    }
    em({ text: e }) {
      return e;
    }
    codespan({ text: e }) {
      return e;
    }
    del({ text: e }) {
      return e;
    }
    html({ text: e }) {
      return e;
    }
    text({ text: e }) {
      return e;
    }
    link({ text: e }) {
      return '' + e;
    }
    image({ text: e }) {
      return '' + e;
    }
    br() {
      return '';
    }
  },
  kf = class e {
    constructor(e) {
      (d(this, 'options'),
        d(this, 'renderer'),
        d(this, 'textRenderer'),
        (this.options = e || hg),
        (this.options.renderer = this.options.renderer || new yf()),
        (this.renderer = this.options.renderer),
        (this.renderer.options = this.options),
        (this.renderer.parser = this),
        (this.textRenderer = new xf()));
    }
    static parse(t, r) {
      return new e(r).parse(t);
    }
    static parseInline(t, r) {
      return new e(r).parseInline(t);
    }
    parse(e, t = !0) {
      var r, n;
      let i = '';
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        if (
          null == (n = null == (r = this.options.extensions) ? void 0 : r.renderers)
            ? void 0
            : n[o.type]
        ) {
          let e = o,
            t = this.options.extensions.renderers[e.type].call({ parser: this }, e);
          if (
            !1 !== t ||
            ![
              'space',
              'hr',
              'heading',
              'code',
              'table',
              'blockquote',
              'list',
              'html',
              'def',
              'paragraph',
              'text',
            ].includes(e.type)
          ) {
            i += t || '';
            continue;
          }
        }
        let s = o;
        switch (s.type) {
          case 'space':
            i += this.renderer.space(s);
            continue;
          case 'hr':
            i += this.renderer.hr(s);
            continue;
          case 'heading':
            i += this.renderer.heading(s);
            continue;
          case 'code':
            i += this.renderer.code(s);
            continue;
          case 'table':
            i += this.renderer.table(s);
            continue;
          case 'blockquote':
            i += this.renderer.blockquote(s);
            continue;
          case 'list':
            i += this.renderer.list(s);
            continue;
          case 'html':
            i += this.renderer.html(s);
            continue;
          case 'def':
            i += this.renderer.def(s);
            continue;
          case 'paragraph':
            i += this.renderer.paragraph(s);
            continue;
          case 'text': {
            let r = s,
              n = this.renderer.text(r);
            for (; a + 1 < e.length && 'text' === e[a + 1].type; )
              ((r = e[++a]), (n += '\n' + this.renderer.text(r)));
            i += t
              ? this.renderer.paragraph({
                  type: 'paragraph',
                  raw: n,
                  text: n,
                  tokens: [{ type: 'text', raw: n, text: n, escaped: !0 }],
                })
              : n;
            continue;
          }
          default: {
            let e = 'Token with "' + s.type + '" type was not found.';
            if (this.options.silent) return '';
            throw new Error(e);
          }
        }
      }
      return i;
    }
    parseInline(e, t = this.renderer) {
      var r, n;
      let i = '';
      for (let a = 0; a < e.length; a++) {
        let o = e[a];
        if (
          null == (n = null == (r = this.options.extensions) ? void 0 : r.renderers)
            ? void 0
            : n[o.type]
        ) {
          let e = this.options.extensions.renderers[o.type].call({ parser: this }, o);
          if (
            !1 !== e ||
            ![
              'escape',
              'html',
              'link',
              'image',
              'strong',
              'em',
              'codespan',
              'br',
              'del',
              'text',
            ].includes(o.type)
          ) {
            i += e || '';
            continue;
          }
        }
        let s = o;
        switch (s.type) {
          case 'escape':
          case 'text':
            i += t.text(s);
            break;
          case 'html':
            i += t.html(s);
            break;
          case 'link':
            i += t.link(s);
            break;
          case 'image':
            i += t.image(s);
            break;
          case 'strong':
            i += t.strong(s);
            break;
          case 'em':
            i += t.em(s);
            break;
          case 'codespan':
            i += t.codespan(s);
            break;
          case 'br':
            i += t.br(s);
            break;
          case 'del':
            i += t.del(s);
            break;
          default: {
            let e = 'Token with "' + s.type + '" type was not found.';
            if (this.options.silent) return '';
            throw new Error(e);
          }
        }
      }
      return i;
    }
  },
  Cf =
    ((l = class {
      constructor(e) {
        (d(this, 'options'), d(this, 'block'), (this.options = e || hg));
      }
      preprocess(e) {
        return e;
      }
      postprocess(e) {
        return e;
      }
      processAllTokens(e) {
        return e;
      }
      emStrongMask(e) {
        return e;
      }
      provideLexer() {
        return this.block ? bf.lex : bf.lexInline;
      }
      provideParser() {
        return this.block ? kf.parse : kf.parseInline;
      }
    }),
    d(
      l,
      'passThroughHooks',
      new Set(['preprocess', 'postprocess', 'processAllTokens', 'emStrongMask'])
    ),
    d(
      l,
      'passThroughHooksRespectAsync',
      new Set(['preprocess', 'postprocess', 'processAllTokens'])
    ),
    l),
  wf = new (class {
    constructor(...e) {
      (d(this, 'defaults', {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null,
      }),
        d(this, 'options', this.setOptions),
        d(this, 'parse', this.parseMarkdown(!0)),
        d(this, 'parseInline', this.parseMarkdown(!1)),
        d(this, 'Parser', kf),
        d(this, 'Renderer', yf),
        d(this, 'TextRenderer', xf),
        d(this, 'Lexer', bf),
        d(this, 'Tokenizer', mf),
        d(this, 'Hooks', Cf),
        this.use(...e));
    }
    walkTokens(e, t) {
      var r, n;
      let i = [];
      for (let a of e)
        switch (((i = i.concat(t.call(this, a))), a.type)) {
          case 'table': {
            let e = a;
            for (let r of e.header) i = i.concat(this.walkTokens(r.tokens, t));
            for (let r of e.rows) for (let e of r) i = i.concat(this.walkTokens(e.tokens, t));
            break;
          }
          case 'list': {
            let e = a;
            i = i.concat(this.walkTokens(e.items, t));
            break;
          }
          default: {
            let e = a;
            (
              null == (n = null == (r = this.defaults.extensions) ? void 0 : r.childTokens)
                ? void 0
                : n[e.type]
            )
              ? this.defaults.extensions.childTokens[e.type].forEach((r) => {
                  let n = e[r].flat(1 / 0);
                  i = i.concat(this.walkTokens(n, t));
                })
              : e.tokens && (i = i.concat(this.walkTokens(e.tokens, t)));
          }
        }
      return i;
    }
    use(...e) {
      let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
      return (
        e.forEach((e) => {
          let r = { ...e };
          if (
            ((r.async = this.defaults.async || r.async || !1),
            e.extensions &&
              (e.extensions.forEach((e) => {
                if (!e.name) throw new Error('extension name required');
                if ('renderer' in e) {
                  let r = t.renderers[e.name];
                  t.renderers[e.name] = r
                    ? function (...t) {
                        let n = e.renderer.apply(this, t);
                        return (!1 === n && (n = r.apply(this, t)), n);
                      }
                    : e.renderer;
                }
                if ('tokenizer' in e) {
                  if (!e.level || ('block' !== e.level && 'inline' !== e.level))
                    throw new Error("extension level must be 'block' or 'inline'");
                  let r = t[e.level];
                  (r ? r.unshift(e.tokenizer) : (t[e.level] = [e.tokenizer]),
                    e.start &&
                      ('block' === e.level
                        ? t.startBlock
                          ? t.startBlock.push(e.start)
                          : (t.startBlock = [e.start])
                        : 'inline' === e.level &&
                          (t.startInline
                            ? t.startInline.push(e.start)
                            : (t.startInline = [e.start]))));
                }
                'childTokens' in e && e.childTokens && (t.childTokens[e.name] = e.childTokens);
              }),
              (r.extensions = t)),
            e.renderer)
          ) {
            let t = this.defaults.renderer || new yf(this.defaults);
            for (let r in e.renderer) {
              if (!(r in t)) throw new Error(`renderer '${r}' does not exist`);
              if (['options', 'parser'].includes(r)) continue;
              let n = r,
                i = e.renderer[n],
                a = t[n];
              t[n] = (...e) => {
                let r = i.apply(t, e);
                return (!1 === r && (r = a.apply(t, e)), r || '');
              };
            }
            r.renderer = t;
          }
          if (e.tokenizer) {
            let t = this.defaults.tokenizer || new mf(this.defaults);
            for (let r in e.tokenizer) {
              if (!(r in t)) throw new Error(`tokenizer '${r}' does not exist`);
              if (['options', 'rules', 'lexer'].includes(r)) continue;
              let n = r,
                i = e.tokenizer[n],
                a = t[n];
              t[n] = (...e) => {
                let r = i.apply(t, e);
                return (!1 === r && (r = a.apply(t, e)), r);
              };
            }
            r.tokenizer = t;
          }
          if (e.hooks) {
            let t = this.defaults.hooks || new Cf();
            for (let r in e.hooks) {
              if (!(r in t)) throw new Error(`hook '${r}' does not exist`);
              if (['options', 'block'].includes(r)) continue;
              let n = r,
                i = e.hooks[n],
                a = t[n];
              Cf.passThroughHooks.has(r)
                ? (t[n] = (e) => {
                    if (this.defaults.async && Cf.passThroughHooksRespectAsync.has(r))
                      return (async () => {
                        let r = await i.call(t, e);
                        return a.call(t, r);
                      })();
                    let n = i.call(t, e);
                    return a.call(t, n);
                  })
                : (t[n] = (...e) => {
                    if (this.defaults.async)
                      return (async () => {
                        let r = await i.apply(t, e);
                        return (!1 === r && (r = await a.apply(t, e)), r);
                      })();
                    let r = i.apply(t, e);
                    return (!1 === r && (r = a.apply(t, e)), r);
                  });
            }
            r.hooks = t;
          }
          if (e.walkTokens) {
            let t = this.defaults.walkTokens,
              n = e.walkTokens;
            r.walkTokens = function (e) {
              let r = [];
              return (r.push(n.call(this, e)), t && (r = r.concat(t.call(this, e))), r);
            };
          }
          this.defaults = { ...this.defaults, ...r };
        }),
        this
      );
    }
    setOptions(e) {
      return ((this.defaults = { ...this.defaults, ...e }), this);
    }
    lexer(e, t) {
      return bf.lex(e, t ?? this.defaults);
    }
    parser(e, t) {
      return kf.parse(e, t ?? this.defaults);
    }
    parseMarkdown(e) {
      return (t, r) => {
        let n = { ...r },
          i = { ...this.defaults, ...n },
          a = this.onError(!!i.silent, !!i.async);
        if (!0 === this.defaults.async && !1 === n.async)
          return a(
            new Error(
              'marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'
            )
          );
        if (typeof t > 'u' || null === t)
          return a(new Error('marked(): input parameter is undefined or null'));
        if ('string' != typeof t)
          return a(
            new Error(
              'marked(): input parameter is of type ' +
                Object.prototype.toString.call(t) +
                ', string expected'
            )
          );
        if ((i.hooks && ((i.hooks.options = i), (i.hooks.block = e)), i.async))
          return (async () => {
            let r = i.hooks ? await i.hooks.preprocess(t) : t,
              n = await (i.hooks ? await i.hooks.provideLexer() : e ? bf.lex : bf.lexInline)(r, i),
              a = i.hooks ? await i.hooks.processAllTokens(n) : n;
            i.walkTokens && (await Promise.all(this.walkTokens(a, i.walkTokens)));
            let o = await (i.hooks ? await i.hooks.provideParser() : e ? kf.parse : kf.parseInline)(
              a,
              i
            );
            return i.hooks ? await i.hooks.postprocess(o) : o;
          })().catch(a);
        try {
          i.hooks && (t = i.hooks.preprocess(t));
          let r = (i.hooks ? i.hooks.provideLexer() : e ? bf.lex : bf.lexInline)(t, i);
          (i.hooks && (r = i.hooks.processAllTokens(r)),
            i.walkTokens && this.walkTokens(r, i.walkTokens));
          let n = (i.hooks ? i.hooks.provideParser() : e ? kf.parse : kf.parseInline)(r, i);
          return (i.hooks && (n = i.hooks.postprocess(n)), n);
        } catch (o) {
          return a(o);
        }
      };
    }
    onError(e, t) {
      return (r) => {
        if (((r.message += '\nPlease report this to https://github.com/markedjs/marked.'), e)) {
          let e = '<p>An error occurred:</p><pre>' + df(r.message + '', !0) + '</pre>';
          return t ? Promise.resolve(e) : e;
        }
        if (t) return Promise.reject(r);
        throw r;
      };
    }
  })();
function vf(e, t) {
  return wf.parse(e, t);
}
function _f(e) {
  for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
  var n = Array.from('string' == typeof e ? [e] : e);
  n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, '');
  var i = n.reduce(function (e, t) {
    var r = t.match(/\n([\t ]+|(?!\s).)/g);
    return r
      ? e.concat(
          r.map(function (e) {
            var t, r;
            return null !==
              (r = null === (t = e.match(/[\t ]/g)) || void 0 === t ? void 0 : t.length) &&
              void 0 !== r
              ? r
              : 0;
          })
        )
      : e;
  }, []);
  if (i.length) {
    var a = new RegExp('\n[\t ]{' + Math.min.apply(Math, i) + '}', 'g');
    n = n.map(function (e) {
      return e.replace(a, '\n');
    });
  }
  n[0] = n[0].replace(/^\r?\n/, '');
  var o = n[0];
  return (
    t.forEach(function (e, t) {
      var r = o.match(/(?:^|\n)( *)$/),
        i = r ? r[1] : '',
        a = e;
      ('string' == typeof e &&
        e.includes('\n') &&
        (a = String(e)
          .split('\n')
          .map(function (e, t) {
            return 0 === t ? e : '' + i + e;
          })
          .join('\n')),
        (o += a + n[t + 1]));
    }),
    o
  );
}
((vf.options = vf.setOptions =
  function (e) {
    return (wf.setOptions(e), (vf.defaults = wf.defaults), dg(vf.defaults), vf);
  }),
  (vf.getDefaults = cg),
  (vf.defaults = hg),
  (vf.use = function (...e) {
    return (wf.use(...e), (vf.defaults = wf.defaults), dg(vf.defaults), vf);
  }),
  (vf.walkTokens = function (e, t) {
    return wf.walkTokens(e, t);
  }),
  (vf.parseInline = wf.parseInline),
  (vf.Parser = kf),
  (vf.parser = kf.parse),
  (vf.Renderer = yf),
  (vf.TextRenderer = xf),
  (vf.Lexer = bf),
  (vf.lexer = bf.lex),
  (vf.Tokenizer = mf),
  (vf.Hooks = Cf),
  (vf.parse = vf),
  vf.options,
  vf.setOptions,
  vf.use,
  vf.walkTokens,
  vf.parseInline,
  kf.parse,
  bf.lex);
var Sf = {
    body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
    height: 80,
    width: 80,
  },
  Ef = new Map(),
  Df = new Map(),
  Af = ii((e) => {
    for (const t of e) {
      if (!t.name)
        throw new Error(
          'Invalid icon loader. Must have a "name" property with non-empty string value.'
        );
      if ((si.debug('Registering icon pack:', t.name), 'loader' in t)) Df.set(t.name, t.loader);
      else {
        if (!('icons' in t))
          throw (
            si.error('Invalid icon loader:', t),
            new Error('Invalid icon loader. Must have either "icons" or "loader" property.')
          );
        Ef.set(t.name, t.icons);
      }
    }
  }, 'registerIconPacks'),
  Tf = ii(async (e, t) => {
    const r = ((e, t, r, n = '') => {
      const i = e.split(':');
      if ('@' === e.slice(0, 1)) {
        if (i.length < 2 || i.length > 3) return null;
        n = i.shift().slice(1);
      }
      if (i.length > 3 || !i.length) return null;
      if (i.length > 1) {
        const e = i.pop(),
          t = i.pop(),
          r = { provider: i.length > 0 ? i[0] : n, prefix: t, name: e };
        return Jp(r) ? r : null;
      }
      const a = i[0],
        o = a.split('-');
      if (o.length > 1) {
        const e = { provider: n, prefix: o.shift(), name: o.join('-') };
        return Jp(e) ? e : null;
      }
      if (r && '' === n) {
        const e = { provider: n, prefix: '', name: a };
        return Jp(e, r) ? e : null;
      }
      return null;
    })(e, 0, void 0 !== t);
    if (!r) throw new Error(`Invalid icon name: ${e}`);
    const n = r.prefix || t;
    if (!n) throw new Error(`Icon name must contain a prefix: ${e}`);
    let i = Ef.get(n);
    if (!i) {
      const e = Df.get(n);
      if (!e) throw new Error(`Icon set not found: ${r.prefix}`);
      try {
        ((i = { ...(await e()), prefix: n }), Ef.set(n, i));
      } catch (o) {
        throw (si.error(o), new Error(`Failed to load icon set: ${r.prefix}`));
      }
    }
    const a = rg(i, r.name);
    if (!a) throw new Error(`Icon not found: ${e}`);
    return a;
  }, 'getRegisteredIconData'),
  Ff = ii(async (e) => {
    try {
      return (await Tf(e), !0);
    } catch {
      return !1;
    }
  }, 'isIconAvailable'),
  Bf = ii(async (e, t, r) => {
    let n;
    try {
      n = await Tf(e, null == t ? void 0 : t.fallbackPrefix);
    } catch (o) {
      (si.error(o), (n = Sf));
    }
    const i = (function (e, t) {
        const r = { ...Kp, ...e },
          n = { ...Qp, ...t },
          i = { left: r.left, top: r.top, width: r.width, height: r.height };
        let a = r.body;
        [r, n].forEach((e) => {
          const t = [],
            r = e.hFlip,
            n = e.vFlip;
          let o,
            s = e.rotate;
          switch (
            (r
              ? n
                ? (s += 2)
                : (t.push(
                    'translate(' +
                      (i.width + i.left).toString() +
                      ' ' +
                      (0 - i.top).toString() +
                      ')'
                  ),
                  t.push('scale(-1 1)'),
                  (i.top = i.left = 0))
              : n &&
                (t.push(
                  'translate(' + (0 - i.left).toString() + ' ' + (i.height + i.top).toString() + ')'
                ),
                t.push('scale(1 -1)'),
                (i.top = i.left = 0)),
            s < 0 && (s -= 4 * Math.floor(s / 4)),
            (s %= 4),
            s)
          ) {
            case 1:
              ((o = i.height / 2 + i.top),
                t.unshift('rotate(90 ' + o.toString() + ' ' + o.toString() + ')'));
              break;
            case 2:
              t.unshift(
                'rotate(180 ' +
                  (i.width / 2 + i.left).toString() +
                  ' ' +
                  (i.height / 2 + i.top).toString() +
                  ')'
              );
              break;
            case 3:
              ((o = i.width / 2 + i.left),
                t.unshift('rotate(-90 ' + o.toString() + ' ' + o.toString() + ')'));
          }
          (s % 2 == 1 &&
            (i.left !== i.top && ((o = i.left), (i.left = i.top), (i.top = o)),
            i.width !== i.height && ((o = i.width), (i.width = i.height), (i.height = o))),
            t.length &&
              (a = (function (e, t, r) {
                const n = (function (e, t = 'defs') {
                  let r = '';
                  const n = e.indexOf('<' + t);
                  for (; n >= 0; ) {
                    const i = e.indexOf('>', n),
                      a = e.indexOf('</' + t);
                    if (-1 === i || -1 === a) break;
                    const o = e.indexOf('>', a);
                    if (-1 === o) break;
                    ((r += e.slice(i + 1, a).trim()), (e = e.slice(0, n).trim() + e.slice(o + 1)));
                  }
                  return { defs: r, content: e };
                })(e);
                return (
                  (i = n.defs),
                  (a = t + n.content + r),
                  i ? '<defs>' + i + '</defs>' + a : a
                );
                var i, a;
              })(a, '<g transform="' + t.join(' ') + '">', '</g>')));
        });
        const o = n.width,
          s = n.height,
          l = i.width,
          c = i.height;
        let h, d;
        null === o
          ? ((d = null === s ? '1em' : 'auto' === s ? c : s), (h = ag(d, l / c)))
          : ((h = 'auto' === o ? l : o), (d = null === s ? ag(h, c / l) : 'auto' === s ? c : s));
        const u = {},
          p = (e, t) => {
            ((e) => 'unset' === e || 'undefined' === e || 'none' === e)(t) || (u[e] = t.toString());
          };
        (p('width', h), p('height', d));
        const g = [i.left, i.top, l, c];
        return ((u.viewBox = g.join(' ')), { attributes: u, viewBox: g, body: a });
      })(n, t),
      a = (function (e, t) {
        let r = -1 === e.indexOf('xlink:') ? '' : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
        for (const n in t) r += ' ' + n + '="' + t[n] + '"';
        return '<svg xmlns="http://www.w3.org/2000/svg"' + r + '>' + e + '</svg>';
      })(lg(i.body), { ...i.attributes, ...r });
    return zo(a, _o());
  }, 'getIconSVG');
function Mf(e, { markdownAutoWrap: t }) {
  const r = _f(e.replace(/<br\/>/g, '\n').replace(/\n{2,}/g, '\n'));
  return !1 === t ? r.replace(/ /g, '&nbsp;') : r;
}
function Nf(e, t = {}) {
  const r = Mf(e, t),
    n = vf.lexer(r),
    i = [[]];
  let a = 0;
  function o(e, t = 'normal') {
    if ('text' === e.type) {
      e.text.split('\n').forEach((e, r) => {
        (0 !== r && (a++, i.push([])),
          e.split(' ').forEach((e) => {
            (e = e.replace(/&#39;/g, "'")) && i[a].push({ content: e, type: t });
          }));
      });
    } else
      'strong' === e.type || 'em' === e.type
        ? e.tokens.forEach((t) => {
            o(t, e.type);
          })
        : 'html' === e.type && i[a].push({ content: e.text, type: 'normal' });
  }
  return (
    ii(o, 'processNode'),
    n.forEach((e) => {
      var t;
      'paragraph' === e.type
        ? null == (t = e.tokens) ||
          t.forEach((e) => {
            o(e);
          })
        : 'html' === e.type
          ? i[a].push({ content: e.text, type: 'normal' })
          : i[a].push({ content: e.raw, type: 'normal' });
    }),
    i
  );
}
function Lf(e, { markdownAutoWrap: t } = {}) {
  const r = vf.lexer(e);
  function n(e) {
    var r, i, a;
    return 'text' === e.type
      ? !1 === t
        ? e.text.replace(/\n */g, '<br/>').replace(/ /g, '&nbsp;')
        : e.text.replace(/\n */g, '<br/>')
      : 'strong' === e.type
        ? `<strong>${null == (r = e.tokens) ? void 0 : r.map(n).join('')}</strong>`
        : 'em' === e.type
          ? `<em>${null == (i = e.tokens) ? void 0 : i.map(n).join('')}</em>`
          : 'paragraph' === e.type
            ? `<p>${null == (a = e.tokens) ? void 0 : a.map(n).join('')}</p>`
            : 'space' === e.type
              ? ''
              : 'html' === e.type
                ? `${e.text}`
                : 'escape' === e.type
                  ? e.text
                  : (si.warn(`Unsupported markdown: ${e.type}`), e.raw);
  }
  return (ii(n, 'output'), r.map(n).join(''));
}
function Of(e) {
  return Intl.Segmenter ? [...new Intl.Segmenter().segment(e)].map((e) => e.segment) : [...e];
}
function $f(e, t) {
  return If(e, [], Of(t.content), t.type);
}
function If(e, t, r, n) {
  if (0 === r.length)
    return [
      { content: t.join(''), type: n },
      { content: '', type: n },
    ];
  const [i, ...a] = r,
    o = [...t, i];
  return e([{ content: o.join(''), type: n }])
    ? If(e, o, a, n)
    : (0 === t.length && i && (t.push(i), r.shift()),
      [
        { content: t.join(''), type: n },
        { content: r.join(''), type: n },
      ]);
}
function Rf(e, t) {
  if (e.some(({ content: e }) => e.includes('\n')))
    throw new Error('splitLineToFitWidth does not support newlines in the line');
  return zf(e, t);
}
function zf(e, t, r = [], n = []) {
  if (0 === e.length) return (n.length > 0 && r.push(n), r.length > 0 ? r : []);
  let i = '';
  ' ' === e[0].content && ((i = ' '), e.shift());
  const a = e.shift() ?? { content: ' ', type: 'normal' },
    o = [...n];
  if (('' !== i && o.push({ content: i, type: 'normal' }), o.push(a), t(o))) return zf(e, t, r, o);
  if (n.length > 0) (r.push(n), e.unshift(a));
  else if (a.content) {
    const [n, i] = $f(t, a);
    (r.push([n]), i.content && e.unshift(i));
  }
  return zf(e, t, r);
}
function Pf(e, t) {
  t && e.attr('style', t);
}
async function jf(e, t, r, n, i = !1, a = _o()) {
  const o = e.append('foreignObject');
  (o.attr('width', 10 * r + 'px'), o.attr('height', 10 * r + 'px'));
  const s = o.append('xhtml:div'),
    l = ts(t.label) ? await is(t.label.replace(as.lineBreakRegex, '\n'), a) : zo(t.label, a),
    c = t.isNode ? 'nodeLabel' : 'edgeLabel',
    h = s.append('span');
  (h.html(l),
    Pf(h, t.labelStyle),
    h.attr('class', `${c} ${n}`),
    Pf(s, t.labelStyle),
    s.style('display', 'table-cell'),
    s.style('white-space', 'nowrap'),
    s.style('line-height', '1.5'),
    s.style('max-width', r + 'px'),
    s.style('text-align', 'center'),
    s.attr('xmlns', 'http://www.w3.org/1999/xhtml'),
    i && s.attr('class', 'labelBkg'));
  let d = s.node().getBoundingClientRect();
  return (
    d.width === r &&
      (s.style('display', 'table'),
      s.style('white-space', 'break-spaces'),
      s.style('width', r + 'px'),
      (d = s.node().getBoundingClientRect())),
    o.node()
  );
}
function qf(e, t, r) {
  return e
    .append('tspan')
    .attr('class', 'text-outer-tspan')
    .attr('x', 0)
    .attr('y', t * r - 0.1 + 'em')
    .attr('dy', r + 'em');
}
function Wf(e, t, r) {
  const n = e.append('text'),
    i = qf(n, 1, t);
  Gf(i, r);
  const a = i.node().getComputedTextLength();
  return (n.remove(), a);
}
function Uf(e, t, r) {
  var n;
  const i = e.append('text'),
    a = qf(i, 1, t);
  Gf(a, [{ content: r, type: 'normal' }]);
  const o = null == (n = a.node()) ? void 0 : n.getBoundingClientRect();
  return (o && i.remove(), o);
}
function Hf(e, t, r, n = !1) {
  const i = t.append('g'),
    a = i.insert('rect').attr('class', 'background').attr('style', 'stroke: none'),
    o = i.append('text').attr('y', '-10.1');
  let s = 0;
  for (const l of r) {
    const t = ii((t) => Wf(i, 1.1, t) <= e, 'checkWidth'),
      r = t(l) ? [l] : Rf(l, t);
    for (const e of r) {
      (Gf(qf(o, s, 1.1), e), s++);
    }
  }
  if (n) {
    const e = o.node().getBBox(),
      t = 2;
    return (
      a
        .attr('x', e.x - t)
        .attr('y', e.y - t)
        .attr('width', e.width + 2 * t)
        .attr('height', e.height + 2 * t),
      i.node()
    );
  }
  return o.node();
}
function Gf(e, t) {
  (e.text(''),
    t.forEach((t, r) => {
      const n = e
        .append('tspan')
        .attr('font-style', 'em' === t.type ? 'italic' : 'normal')
        .attr('class', 'text-inner-tspan')
        .attr('font-weight', 'strong' === t.type ? 'bold' : 'normal');
      0 === r ? n.text(t.content) : n.text(' ' + t.content);
    }));
}
async function Vf(e, t = {}) {
  const r = [];
  e.replace(
    /(fa[bklrs]?):fa-([\w-]+)/g,
    (e, n, i) => (
      r.push(
        (async () => {
          const r = `${n}:${i}`;
          return (await Ff(r))
            ? await Bf(r, void 0, { class: 'label-icon' })
            : `<i class='${zo(e, t).replace(':', ' ')}'></i>`;
        })()
      ),
      e
    )
  );
  const n = await Promise.all(r);
  return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? '');
}
(ii(Mf, 'preprocessMarkdown'),
  ii(Nf, 'markdownToLines'),
  ii(Lf, 'markdownToHTML'),
  ii(Of, 'splitTextToChars'),
  ii($f, 'splitWordToFitWidth'),
  ii(If, 'splitWordToFitWidthRecursion'),
  ii(Rf, 'splitLineToFitWidth'),
  ii(zf, 'splitLineToFitWidthRecursion'),
  ii(Pf, 'applyStyle'),
  ii(jf, 'addHtmlSpan'),
  ii(qf, 'createTspan'),
  ii(Wf, 'computeWidthOfText'),
  ii(Uf, 'computeDimensionOfText'),
  ii(Hf, 'createFormattedText'),
  ii(Gf, 'updateTextContentAndStyles'),
  ii(Vf, 'replaceIconSubstring'));
var Zf = ii(
  async (
    e,
    t = '',
    {
      style: r = '',
      isTitle: n = !1,
      classes: i = '',
      useHtmlLabels: a = !0,
      isNode: o = !0,
      width: s = 200,
      addSvgBackground: l = !1,
    } = {},
    c
  ) => {
    if ((si.debug('XYZ createText', t, r, n, i, a, o, 'addSvgBackground: ', l), a)) {
      const n = Lf(t, c),
        a = await Vf(Wp(n), c),
        h = t.replace(/\\\\/g, '\\'),
        d = { isNode: o, label: ts(t) ? h : a, labelStyle: r.replace('fill:', 'color:') };
      return await jf(e, d, s, i, l, c);
    }
    {
      const n = Hf(
        s,
        e,
        Nf(t.replace(/<br\s*\/?>/g, '<br/>').replace('<br>', '<br/>'), c),
        !!t && l
      );
      if (o) {
        /stroke:/.exec(r) && (r = r.replace('stroke:', 'lineColor:'));
        const e = r
          .replace(/stroke:[^;]+;?/g, '')
          .replace(/stroke-width:[^;]+;?/g, '')
          .replace(/fill:[^;]+;?/g, '')
          .replace(/color:/g, 'fill:');
        S(n).attr('style', e);
      } else {
        const e = r
          .replace(/stroke:[^;]+;?/g, '')
          .replace(/stroke-width:[^;]+;?/g, '')
          .replace(/fill:[^;]+;?/g, '')
          .replace(/background:/g, 'fill:');
        S(n)
          .select('rect')
          .attr('style', e.replace(/background:/g, 'fill:'));
        const t = r
          .replace(/stroke:[^;]+;?/g, '')
          .replace(/stroke-width:[^;]+;?/g, '')
          .replace(/fill:[^;]+;?/g, '')
          .replace(/color:/g, 'fill:');
        S(n).select('text').attr('style', t);
      }
      return n;
    }
  },
  'createText'
);
function Kf(e, t, r) {
  if (e && e.length) {
    const [n, i] = t,
      a = (Math.PI / 180) * r,
      o = Math.cos(a),
      s = Math.sin(a);
    for (const t of e) {
      const [e, r] = t;
      ((t[0] = (e - n) * o - (r - i) * s + n), (t[1] = (e - n) * s + (r - i) * o + i));
    }
  }
}
function Yf(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function Xf(e, t) {
  var r;
  const n = t.hachureAngle + 90;
  let i = t.hachureGap;
  (i < 0 && (i = 4 * t.strokeWidth), (i = Math.round(Math.max(i, 0.1))));
  let a = 1;
  return (
    t.roughness >= 1 &&
      ((null === (r = t.randomizer) || void 0 === r ? void 0 : r.next()) || Math.random()) > 0.7 &&
      (a = i),
    (function (e, t, r, n = 1) {
      const i = r,
        a = Math.max(t, 0.1),
        o = e[0] && e[0][0] && 'number' == typeof e[0][0] ? [e] : e,
        s = [0, 0];
      if (i) for (const c of o) Kf(c, s, i);
      const l = (function (e, t, r) {
        const n = [];
        for (const c of e) {
          const e = [...c];
          (Yf(e[0], e[e.length - 1]) || e.push([e[0][0], e[0][1]]), e.length > 2 && n.push(e));
        }
        const i = [];
        t = Math.max(t, 0.1);
        const a = [];
        for (const c of n)
          for (let e = 0; e < c.length - 1; e++) {
            const t = c[e],
              r = c[e + 1];
            if (t[1] !== r[1]) {
              const e = Math.min(t[1], r[1]);
              a.push({
                ymin: e,
                ymax: Math.max(t[1], r[1]),
                x: e === t[1] ? t[0] : r[0],
                islope: (r[0] - t[0]) / (r[1] - t[1]),
              });
            }
          }
        if (
          (a.sort((e, t) =>
            e.ymin < t.ymin
              ? -1
              : e.ymin > t.ymin
                ? 1
                : e.x < t.x
                  ? -1
                  : e.x > t.x
                    ? 1
                    : e.ymax === t.ymax
                      ? 0
                      : (e.ymax - t.ymax) / Math.abs(e.ymax - t.ymax)
          ),
          !a.length)
        )
          return i;
        let o = [],
          s = a[0].ymin,
          l = 0;
        for (; o.length || a.length; ) {
          if (a.length) {
            let e = -1;
            for (let t = 0; t < a.length && !(a[t].ymin > s); t++) e = t;
            a.splice(0, e + 1).forEach((e) => {
              o.push({ s: s, edge: e });
            });
          }
          if (
            ((o = o.filter((e) => !(e.edge.ymax <= s))),
            o.sort((e, t) =>
              e.edge.x === t.edge.x ? 0 : (e.edge.x - t.edge.x) / Math.abs(e.edge.x - t.edge.x)
            ),
            (1 !== r || l % t == 0) && o.length > 1)
          )
            for (let e = 0; e < o.length; e += 2) {
              const t = e + 1;
              if (t >= o.length) break;
              const r = o[e].edge,
                n = o[t].edge;
              i.push([
                [Math.round(r.x), s],
                [Math.round(n.x), s],
              ]);
            }
          ((s += r),
            o.forEach((e) => {
              e.edge.x = e.edge.x + r * e.edge.islope;
            }),
            l++);
        }
        return i;
      })(o, a, n);
      if (i) {
        for (const e of o) Kf(e, s, -i);
        !(function (e, t, r) {
          const n = [];
          (e.forEach((e) => n.push(...e)), Kf(n, t, r));
        })(l, s, -i);
      }
      return l;
    })(e, i, n, a || 1)
  );
}
class Qf {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, t) {
    return this._fillPolygons(e, t);
  }
  _fillPolygons(e, t) {
    const r = Xf(e, t);
    return { type: 'fillSketch', ops: this.renderLines(r, t) };
  }
  renderLines(e, t) {
    const r = [];
    for (const n of e) r.push(...this.helper.doubleLineOps(n[0][0], n[0][1], n[1][0], n[1][1], t));
    return r;
  }
}
function Jf(e) {
  const t = e[0],
    r = e[1];
  return Math.sqrt(Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2));
}
class em extends Qf {
  fillPolygons(e, t) {
    let r = t.hachureGap;
    (r < 0 && (r = 4 * t.strokeWidth), (r = Math.max(r, 0.1)));
    const n = Xf(e, Object.assign({}, t, { hachureGap: r })),
      i = (Math.PI / 180) * t.hachureAngle,
      a = [],
      o = 0.5 * r * Math.cos(i),
      s = 0.5 * r * Math.sin(i);
    for (const [l, c] of n)
      Jf([l, c]) && a.push([[l[0] - o, l[1] + s], [...c]], [[l[0] + o, l[1] - s], [...c]]);
    return { type: 'fillSketch', ops: this.renderLines(a, t) };
  }
}
class tm extends Qf {
  fillPolygons(e, t) {
    const r = this._fillPolygons(e, t),
      n = Object.assign({}, t, { hachureAngle: t.hachureAngle + 90 }),
      i = this._fillPolygons(e, n);
    return ((r.ops = r.ops.concat(i.ops)), r);
  }
}
class rm {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, t) {
    const r = Xf(e, (t = Object.assign({}, t, { hachureAngle: 0 })));
    return this.dotsOnLines(r, t);
  }
  dotsOnLines(e, t) {
    const r = [];
    let n = t.hachureGap;
    (n < 0 && (n = 4 * t.strokeWidth), (n = Math.max(n, 0.1)));
    let i = t.fillWeight;
    i < 0 && (i = t.strokeWidth / 2);
    const a = n / 4;
    for (const o of e) {
      const e = Jf(o),
        s = e / n,
        l = Math.ceil(s) - 1,
        c = e - l * n,
        h = (o[0][0] + o[1][0]) / 2 - n / 4,
        d = Math.min(o[0][1], o[1][1]);
      for (let o = 0; o < l; o++) {
        const e = d + c + o * n,
          s = h - a + 2 * Math.random() * a,
          l = e - a + 2 * Math.random() * a,
          u = this.helper.ellipse(s, l, i, i, t);
        r.push(...u.ops);
      }
    }
    return { type: 'fillSketch', ops: r };
  }
}
class nm {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, t) {
    const r = Xf(e, t);
    return { type: 'fillSketch', ops: this.dashedLine(r, t) };
  }
  dashedLine(e, t) {
    const r =
        t.dashOffset < 0 ? (t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap) : t.dashOffset,
      n = t.dashGap < 0 ? (t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap) : t.dashGap,
      i = [];
    return (
      e.forEach((e) => {
        const a = Jf(e),
          o = Math.floor(a / (r + n)),
          s = (a + n - o * (r + n)) / 2;
        let l = e[0],
          c = e[1];
        l[0] > c[0] && ((l = e[1]), (c = e[0]));
        const h = Math.atan((c[1] - l[1]) / (c[0] - l[0]));
        for (let d = 0; d < o; d++) {
          const e = d * (r + n),
            a = e + r,
            o = [
              l[0] + e * Math.cos(h) + s * Math.cos(h),
              l[1] + e * Math.sin(h) + s * Math.sin(h),
            ],
            c = [
              l[0] + a * Math.cos(h) + s * Math.cos(h),
              l[1] + a * Math.sin(h) + s * Math.sin(h),
            ];
          i.push(...this.helper.doubleLineOps(o[0], o[1], c[0], c[1], t));
        }
      }),
      i
    );
  }
}
class im {
  constructor(e) {
    this.helper = e;
  }
  fillPolygons(e, t) {
    const r = t.hachureGap < 0 ? 4 * t.strokeWidth : t.hachureGap,
      n = t.zigzagOffset < 0 ? r : t.zigzagOffset,
      i = Xf(e, (t = Object.assign({}, t, { hachureGap: r + n })));
    return { type: 'fillSketch', ops: this.zigzagLines(i, n, t) };
  }
  zigzagLines(e, t, r) {
    const n = [];
    return (
      e.forEach((e) => {
        const i = Jf(e),
          a = Math.round(i / (2 * t));
        let o = e[0],
          s = e[1];
        o[0] > s[0] && ((o = e[1]), (s = e[0]));
        const l = Math.atan((s[1] - o[1]) / (s[0] - o[0]));
        for (let c = 0; c < a; c++) {
          const e = 2 * c * t,
            i = 2 * (c + 1) * t,
            a = Math.sqrt(2 * Math.pow(t, 2)),
            s = [o[0] + e * Math.cos(l), o[1] + e * Math.sin(l)],
            h = [o[0] + i * Math.cos(l), o[1] + i * Math.sin(l)],
            d = [s[0] + a * Math.cos(l + Math.PI / 4), s[1] + a * Math.sin(l + Math.PI / 4)];
          n.push(
            ...this.helper.doubleLineOps(s[0], s[1], d[0], d[1], r),
            ...this.helper.doubleLineOps(d[0], d[1], h[0], h[1], r)
          );
        }
      }),
      n
    );
  }
}
const am = {};
class om {
  constructor(e) {
    this.seed = e;
  }
  next() {
    return this.seed
      ? ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31
      : Math.random();
  }
}
const sm = {
  A: 7,
  a: 7,
  C: 6,
  c: 6,
  H: 1,
  h: 1,
  L: 2,
  l: 2,
  M: 2,
  m: 2,
  Q: 4,
  q: 4,
  S: 4,
  s: 4,
  T: 2,
  t: 2,
  V: 1,
  v: 1,
  Z: 0,
  z: 0,
};
function lm(e, t) {
  return e.type === t;
}
function cm(e) {
  const t = [],
    r = (function (e) {
      const t = new Array();
      for (; '' !== e; )
        if (e.match(/^([ \t\r\n,]+)/)) e = e.substr(RegExp.$1.length);
        else if (e.match(/^([aAcChHlLmMqQsStTvVzZ])/))
          ((t[t.length] = { type: 0, text: RegExp.$1 }), (e = e.substr(RegExp.$1.length)));
        else {
          if (!e.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
          ((t[t.length] = { type: 1, text: `${parseFloat(RegExp.$1)}` }),
            (e = e.substr(RegExp.$1.length)));
        }
      return ((t[t.length] = { type: 2, text: '' }), t);
    })(e);
  let n = 'BOD',
    i = 0,
    a = r[i];
  for (; !lm(a, 2); ) {
    let o = 0;
    const s = [];
    if ('BOD' === n) {
      if ('M' !== a.text && 'm' !== a.text) return cm('M0,0' + e);
      (i++, (o = sm[a.text]), (n = a.text));
    } else lm(a, 1) ? (o = sm[n]) : (i++, (o = sm[a.text]), (n = a.text));
    if (!(i + o < r.length)) throw new Error('Path data ended short');
    for (let e = i; e < i + o; e++) {
      const t = r[e];
      if (!lm(t, 1)) throw new Error('Param not a number: ' + n + ',' + t.text);
      s[s.length] = +t.text;
    }
    if ('number' != typeof sm[n]) throw new Error('Bad segment: ' + n);
    {
      const e = { key: n, data: s };
      (t.push(e), (i += o), (a = r[i]), 'M' === n && (n = 'L'), 'm' === n && (n = 'l'));
    }
  }
  return t;
}
function hm(e) {
  let t = 0,
    r = 0,
    n = 0,
    i = 0;
  const a = [];
  for (const { key: o, data: s } of e)
    switch (o) {
      case 'M':
        (a.push({ key: 'M', data: [...s] }), ([t, r] = s), ([n, i] = s));
        break;
      case 'm':
        ((t += s[0]), (r += s[1]), a.push({ key: 'M', data: [t, r] }), (n = t), (i = r));
        break;
      case 'L':
        (a.push({ key: 'L', data: [...s] }), ([t, r] = s));
        break;
      case 'l':
        ((t += s[0]), (r += s[1]), a.push({ key: 'L', data: [t, r] }));
        break;
      case 'C':
        (a.push({ key: 'C', data: [...s] }), (t = s[4]), (r = s[5]));
        break;
      case 'c': {
        const e = s.map((e, n) => (n % 2 ? e + r : e + t));
        (a.push({ key: 'C', data: e }), (t = e[4]), (r = e[5]));
        break;
      }
      case 'Q':
        (a.push({ key: 'Q', data: [...s] }), (t = s[2]), (r = s[3]));
        break;
      case 'q': {
        const e = s.map((e, n) => (n % 2 ? e + r : e + t));
        (a.push({ key: 'Q', data: e }), (t = e[2]), (r = e[3]));
        break;
      }
      case 'A':
        (a.push({ key: 'A', data: [...s] }), (t = s[5]), (r = s[6]));
        break;
      case 'a':
        ((t += s[5]),
          (r += s[6]),
          a.push({ key: 'A', data: [s[0], s[1], s[2], s[3], s[4], t, r] }));
        break;
      case 'H':
        (a.push({ key: 'H', data: [...s] }), (t = s[0]));
        break;
      case 'h':
        ((t += s[0]), a.push({ key: 'H', data: [t] }));
        break;
      case 'V':
        (a.push({ key: 'V', data: [...s] }), (r = s[0]));
        break;
      case 'v':
        ((r += s[0]), a.push({ key: 'V', data: [r] }));
        break;
      case 'S':
        (a.push({ key: 'S', data: [...s] }), (t = s[2]), (r = s[3]));
        break;
      case 's': {
        const e = s.map((e, n) => (n % 2 ? e + r : e + t));
        (a.push({ key: 'S', data: e }), (t = e[2]), (r = e[3]));
        break;
      }
      case 'T':
        (a.push({ key: 'T', data: [...s] }), (t = s[0]), (r = s[1]));
        break;
      case 't':
        ((t += s[0]), (r += s[1]), a.push({ key: 'T', data: [t, r] }));
        break;
      case 'Z':
      case 'z':
        (a.push({ key: 'Z', data: [] }), (t = n), (r = i));
    }
  return a;
}
function dm(e) {
  const t = [];
  let r = '',
    n = 0,
    i = 0,
    a = 0,
    o = 0,
    s = 0,
    l = 0;
  for (const { key: c, data: h } of e) {
    switch (c) {
      case 'M':
        (t.push({ key: 'M', data: [...h] }), ([n, i] = h), ([a, o] = h));
        break;
      case 'C':
        (t.push({ key: 'C', data: [...h] }), (n = h[4]), (i = h[5]), (s = h[2]), (l = h[3]));
        break;
      case 'L':
        (t.push({ key: 'L', data: [...h] }), ([n, i] = h));
        break;
      case 'H':
        ((n = h[0]), t.push({ key: 'L', data: [n, i] }));
        break;
      case 'V':
        ((i = h[0]), t.push({ key: 'L', data: [n, i] }));
        break;
      case 'S': {
        let e = 0,
          a = 0;
        ('C' === r || 'S' === r ? ((e = n + (n - s)), (a = i + (i - l))) : ((e = n), (a = i)),
          t.push({ key: 'C', data: [e, a, ...h] }),
          (s = h[0]),
          (l = h[1]),
          (n = h[2]),
          (i = h[3]));
        break;
      }
      case 'T': {
        const [e, a] = h;
        let o = 0,
          c = 0;
        'Q' === r || 'T' === r ? ((o = n + (n - s)), (c = i + (i - l))) : ((o = n), (c = i));
        const d = n + (2 * (o - n)) / 3,
          u = i + (2 * (c - i)) / 3,
          p = e + (2 * (o - e)) / 3,
          g = a + (2 * (c - a)) / 3;
        (t.push({ key: 'C', data: [d, u, p, g, e, a] }), (s = o), (l = c), (n = e), (i = a));
        break;
      }
      case 'Q': {
        const [e, r, a, o] = h,
          c = n + (2 * (e - n)) / 3,
          d = i + (2 * (r - i)) / 3,
          u = a + (2 * (e - a)) / 3,
          p = o + (2 * (r - o)) / 3;
        (t.push({ key: 'C', data: [c, d, u, p, a, o] }), (s = e), (l = r), (n = a), (i = o));
        break;
      }
      case 'A': {
        const e = Math.abs(h[0]),
          r = Math.abs(h[1]),
          a = h[2],
          o = h[3],
          s = h[4],
          l = h[5],
          c = h[6];
        0 === e || 0 === r
          ? (t.push({ key: 'C', data: [n, i, l, c, l, c] }), (n = l), (i = c))
          : (n === l && i === c) ||
            (pm(n, i, l, c, e, r, a, o, s).forEach(function (e) {
              t.push({ key: 'C', data: e });
            }),
            (n = l),
            (i = c));
        break;
      }
      case 'Z':
        (t.push({ key: 'Z', data: [] }), (n = a), (i = o));
    }
    r = c;
  }
  return t;
}
function um(e, t, r) {
  return [e * Math.cos(r) - t * Math.sin(r), e * Math.sin(r) + t * Math.cos(r)];
}
function pm(e, t, r, n, i, a, o, s, l, c) {
  const h = ((d = o), (Math.PI * d) / 180);
  var d;
  let u = [],
    p = 0,
    g = 0,
    f = 0,
    m = 0;
  if (c) [p, g, f, m] = c;
  else {
    (([e, t] = um(e, t, -h)), ([r, n] = um(r, n, -h)));
    const o = (e - r) / 2,
      c = (t - n) / 2;
    let d = (o * o) / (i * i) + (c * c) / (a * a);
    d > 1 && ((d = Math.sqrt(d)), (i *= d), (a *= d));
    const u = i * i,
      b = a * a,
      y = u * b - u * c * c - b * o * o,
      x = u * c * c + b * o * o,
      k = (s === l ? -1 : 1) * Math.sqrt(Math.abs(y / x));
    ((f = (k * i * c) / a + (e + r) / 2),
      (m = (k * -a * o) / i + (t + n) / 2),
      (p = Math.asin(parseFloat(((t - m) / a).toFixed(9)))),
      (g = Math.asin(parseFloat(((n - m) / a).toFixed(9)))),
      e < f && (p = Math.PI - p),
      r < f && (g = Math.PI - g),
      p < 0 && (p = 2 * Math.PI + p),
      g < 0 && (g = 2 * Math.PI + g),
      l && p > g && (p -= 2 * Math.PI),
      !l && g > p && (g -= 2 * Math.PI));
  }
  let b = g - p;
  if (Math.abs(b) > (120 * Math.PI) / 180) {
    const e = g,
      t = r,
      s = n;
    ((g = l && g > p ? p + ((120 * Math.PI) / 180) * 1 : p + ((120 * Math.PI) / 180) * -1),
      (u = pm((r = f + i * Math.cos(g)), (n = m + a * Math.sin(g)), t, s, i, a, o, 0, l, [
        g,
        e,
        f,
        m,
      ])));
  }
  b = g - p;
  const y = Math.cos(p),
    x = Math.sin(p),
    k = Math.cos(g),
    C = Math.sin(g),
    w = Math.tan(b / 4),
    v = (4 / 3) * i * w,
    _ = (4 / 3) * a * w,
    S = [e, t],
    E = [e + v * x, t - _ * y],
    D = [r + v * C, n - _ * k],
    A = [r, n];
  if (((E[0] = 2 * S[0] - E[0]), (E[1] = 2 * S[1] - E[1]), c)) return [E, D, A].concat(u);
  {
    u = [E, D, A].concat(u);
    const e = [];
    for (let t = 0; t < u.length; t += 3) {
      const r = um(u[t][0], u[t][1], h),
        n = um(u[t + 1][0], u[t + 1][1], h),
        i = um(u[t + 2][0], u[t + 2][1], h);
      e.push([r[0], r[1], n[0], n[1], i[0], i[1]]);
    }
    return e;
  }
}
const gm = {
  randOffset: function (e, t) {
    return Dm(e, t);
  },
  randOffsetWithRange: function (e, t, r) {
    return Em(e, t, r);
  },
  ellipse: function (e, t, r, n, i) {
    return xm(e, t, i, ym(r, n, i)).opset;
  },
  doubleLineOps: function (e, t, r, n, i) {
    return Am(e, t, r, n, i, !0);
  },
};
function fm(e, t, r, n, i) {
  return { type: 'path', ops: Am(e, t, r, n, i) };
}
function mm(e, t, r) {
  const n = (e || []).length;
  if (n > 2) {
    const i = [];
    for (let t = 0; t < n - 1; t++) i.push(...Am(e[t][0], e[t][1], e[t + 1][0], e[t + 1][1], r));
    return (
      t && i.push(...Am(e[n - 1][0], e[n - 1][1], e[0][0], e[0][1], r)),
      { type: 'path', ops: i }
    );
  }
  return 2 === n ? fm(e[0][0], e[0][1], e[1][0], e[1][1], r) : { type: 'path', ops: [] };
}
function bm(e, t) {
  if (e.length) {
    const r = 'number' == typeof e[0][0] ? [e] : e,
      n = Fm(r[0], 1 * (1 + 0.2 * t.roughness), t),
      i = t.disableMultiStroke ? [] : Fm(r[0], 1.5 * (1 + 0.22 * t.roughness), _m(t));
    for (let e = 1; e < r.length; e++) {
      const a = r[e];
      if (a.length) {
        const e = Fm(a, 1 * (1 + 0.2 * t.roughness), t),
          r = t.disableMultiStroke ? [] : Fm(a, 1.5 * (1 + 0.22 * t.roughness), _m(t));
        for (const t of e) 'move' !== t.op && n.push(t);
        for (const t of r) 'move' !== t.op && i.push(t);
      }
    }
    return { type: 'path', ops: n.concat(i) };
  }
  return { type: 'path', ops: [] };
}
function ym(e, t, r) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2)),
    i = Math.ceil(Math.max(r.curveStepCount, (r.curveStepCount / Math.sqrt(200)) * n)),
    a = (2 * Math.PI) / i;
  let o = Math.abs(e / 2),
    s = Math.abs(t / 2);
  const l = 1 - r.curveFitting;
  return ((o += Dm(o * l, r)), (s += Dm(s * l, r)), { increment: a, rx: o, ry: s });
}
function xm(e, t, r, n) {
  const [i, a] = Mm(n.increment, e, t, n.rx, n.ry, 1, n.increment * Em(0.1, Em(0.4, 1, r), r), r);
  let o = Bm(i, null, r);
  if (!r.disableMultiStroke && 0 !== r.roughness) {
    const [i] = Mm(n.increment, e, t, n.rx, n.ry, 1.5, 0, r),
      a = Bm(i, null, r);
    o = o.concat(a);
  }
  return { estimatedPoints: a, opset: { type: 'path', ops: o } };
}
function km(e, t, r, n, i, a, o, s, l) {
  const c = e,
    h = t;
  let d = Math.abs(r / 2),
    u = Math.abs(n / 2);
  ((d += Dm(0.01 * d, l)), (u += Dm(0.01 * u, l)));
  let p = i,
    g = a;
  for (; p < 0; ) ((p += 2 * Math.PI), (g += 2 * Math.PI));
  g - p > 2 * Math.PI && ((p = 0), (g = 2 * Math.PI));
  const f = (2 * Math.PI) / l.curveStepCount,
    m = Math.min(f / 2, (g - p) / 2),
    b = Nm(m, c, h, d, u, p, g, 1, l);
  if (!l.disableMultiStroke) {
    const e = Nm(m, c, h, d, u, p, g, 1.5, l);
    b.push(...e);
  }
  return (
    o &&
      (s
        ? b.push(
            ...Am(c, h, c + d * Math.cos(p), h + u * Math.sin(p), l),
            ...Am(c, h, c + d * Math.cos(g), h + u * Math.sin(g), l)
          )
        : b.push(
            { op: 'lineTo', data: [c, h] },
            { op: 'lineTo', data: [c + d * Math.cos(p), h + u * Math.sin(p)] }
          )),
    { type: 'path', ops: b }
  );
}
function Cm(e, t) {
  const r = dm(hm(cm(e))),
    n = [];
  let i = [0, 0],
    a = [0, 0];
  for (const { key: o, data: s } of r)
    switch (o) {
      case 'M':
        ((a = [s[0], s[1]]), (i = [s[0], s[1]]));
        break;
      case 'L':
        (n.push(...Am(a[0], a[1], s[0], s[1], t)), (a = [s[0], s[1]]));
        break;
      case 'C': {
        const [e, r, i, o, l, c] = s;
        (n.push(...Lm(e, r, i, o, l, c, a, t)), (a = [l, c]));
        break;
      }
      case 'Z':
        (n.push(...Am(a[0], a[1], i[0], i[1], t)), (a = [i[0], i[1]]));
    }
  return { type: 'path', ops: n };
}
function wm(e, t) {
  const r = [];
  for (const n of e)
    if (n.length) {
      const e = t.maxRandomnessOffset || 0,
        i = n.length;
      if (i > 2) {
        r.push({ op: 'move', data: [n[0][0] + Dm(e, t), n[0][1] + Dm(e, t)] });
        for (let a = 1; a < i; a++)
          r.push({ op: 'lineTo', data: [n[a][0] + Dm(e, t), n[a][1] + Dm(e, t)] });
      }
    }
  return { type: 'fillPath', ops: r };
}
function vm(e, t) {
  return (function (e, t) {
    let r = e.fillStyle || 'hachure';
    if (!am[r])
      switch (r) {
        case 'zigzag':
          am[r] || (am[r] = new em(t));
          break;
        case 'cross-hatch':
          am[r] || (am[r] = new tm(t));
          break;
        case 'dots':
          am[r] || (am[r] = new rm(t));
          break;
        case 'dashed':
          am[r] || (am[r] = new nm(t));
          break;
        case 'zigzag-line':
          am[r] || (am[r] = new im(t));
          break;
        default:
          ((r = 'hachure'), am[r] || (am[r] = new Qf(t)));
      }
    return am[r];
  })(t, gm).fillPolygons(e, t);
}
function _m(e) {
  const t = Object.assign({}, e);
  return ((t.randomizer = void 0), e.seed && (t.seed = e.seed + 1), t);
}
function Sm(e) {
  return (e.randomizer || (e.randomizer = new om(e.seed || 0)), e.randomizer.next());
}
function Em(e, t, r, n = 1) {
  return r.roughness * n * (Sm(r) * (t - e) + e);
}
function Dm(e, t, r = 1) {
  return Em(-e, e, t, r);
}
function Am(e, t, r, n, i, a = !1) {
  const o = a ? i.disableMultiStrokeFill : i.disableMultiStroke,
    s = Tm(e, t, r, n, i, !0, !1);
  if (o) return s;
  const l = Tm(e, t, r, n, i, !0, !0);
  return s.concat(l);
}
function Tm(e, t, r, n, i, a, o) {
  const s = Math.pow(e - r, 2) + Math.pow(t - n, 2),
    l = Math.sqrt(s);
  let c = 1;
  c = l < 200 ? 1 : l > 500 ? 0.4 : -0.0016668 * l + 1.233334;
  let h = i.maxRandomnessOffset || 0;
  h * h * 100 > s && (h = l / 10);
  const d = h / 2,
    u = 0.2 + 0.2 * Sm(i);
  let p = (i.bowing * i.maxRandomnessOffset * (n - t)) / 200,
    g = (i.bowing * i.maxRandomnessOffset * (e - r)) / 200;
  ((p = Dm(p, i, c)), (g = Dm(g, i, c)));
  const f = [],
    m = () => Dm(d, i, c),
    b = () => Dm(h, i, c),
    y = i.preserveVertices;
  return (
    o
      ? f.push({ op: 'move', data: [e + (y ? 0 : m()), t + (y ? 0 : m())] })
      : f.push({ op: 'move', data: [e + (y ? 0 : Dm(h, i, c)), t + (y ? 0 : Dm(h, i, c))] }),
    o
      ? f.push({
          op: 'bcurveTo',
          data: [
            p + e + (r - e) * u + m(),
            g + t + (n - t) * u + m(),
            p + e + 2 * (r - e) * u + m(),
            g + t + 2 * (n - t) * u + m(),
            r + (y ? 0 : m()),
            n + (y ? 0 : m()),
          ],
        })
      : f.push({
          op: 'bcurveTo',
          data: [
            p + e + (r - e) * u + b(),
            g + t + (n - t) * u + b(),
            p + e + 2 * (r - e) * u + b(),
            g + t + 2 * (n - t) * u + b(),
            r + (y ? 0 : b()),
            n + (y ? 0 : b()),
          ],
        }),
    f
  );
}
function Fm(e, t, r) {
  if (!e.length) return [];
  const n = [];
  (n.push([e[0][0] + Dm(t, r), e[0][1] + Dm(t, r)]),
    n.push([e[0][0] + Dm(t, r), e[0][1] + Dm(t, r)]));
  for (let i = 1; i < e.length; i++)
    (n.push([e[i][0] + Dm(t, r), e[i][1] + Dm(t, r)]),
      i === e.length - 1 && n.push([e[i][0] + Dm(t, r), e[i][1] + Dm(t, r)]));
  return Bm(n, null, r);
}
function Bm(e, t, r) {
  const n = e.length,
    i = [];
  if (n > 3) {
    const t = [],
      a = 1 - r.curveTightness;
    i.push({ op: 'move', data: [e[1][0], e[1][1]] });
    for (let r = 1; r + 2 < n; r++) {
      const n = e[r];
      ((t[0] = [n[0], n[1]]),
        (t[1] = [
          n[0] + (a * e[r + 1][0] - a * e[r - 1][0]) / 6,
          n[1] + (a * e[r + 1][1] - a * e[r - 1][1]) / 6,
        ]),
        (t[2] = [
          e[r + 1][0] + (a * e[r][0] - a * e[r + 2][0]) / 6,
          e[r + 1][1] + (a * e[r][1] - a * e[r + 2][1]) / 6,
        ]),
        (t[3] = [e[r + 1][0], e[r + 1][1]]),
        i.push({ op: 'bcurveTo', data: [t[1][0], t[1][1], t[2][0], t[2][1], t[3][0], t[3][1]] }));
    }
  } else
    3 === n
      ? (i.push({ op: 'move', data: [e[1][0], e[1][1]] }),
        i.push({ op: 'bcurveTo', data: [e[1][0], e[1][1], e[2][0], e[2][1], e[2][0], e[2][1]] }))
      : 2 === n && i.push(...Tm(e[0][0], e[0][1], e[1][0], e[1][1], r, 0, !0));
  return i;
}
function Mm(e, t, r, n, i, a, o, s) {
  const l = [],
    c = [];
  if (0 === s.roughness) {
    ((e /= 4), c.push([t + n * Math.cos(-e), r + i * Math.sin(-e)]));
    for (let a = 0; a <= 2 * Math.PI; a += e) {
      const e = [t + n * Math.cos(a), r + i * Math.sin(a)];
      (l.push(e), c.push(e));
    }
    (c.push([t + n * Math.cos(0), r + i * Math.sin(0)]),
      c.push([t + n * Math.cos(e), r + i * Math.sin(e)]));
  } else {
    const h = Dm(0.5, s) - Math.PI / 2;
    c.push([Dm(a, s) + t + 0.9 * n * Math.cos(h - e), Dm(a, s) + r + 0.9 * i * Math.sin(h - e)]);
    const d = 2 * Math.PI + h - 0.01;
    for (let o = h; o < d; o += e) {
      const e = [Dm(a, s) + t + n * Math.cos(o), Dm(a, s) + r + i * Math.sin(o)];
      (l.push(e), c.push(e));
    }
    (c.push([
      Dm(a, s) + t + n * Math.cos(h + 2 * Math.PI + 0.5 * o),
      Dm(a, s) + r + i * Math.sin(h + 2 * Math.PI + 0.5 * o),
    ]),
      c.push([
        Dm(a, s) + t + 0.98 * n * Math.cos(h + o),
        Dm(a, s) + r + 0.98 * i * Math.sin(h + o),
      ]),
      c.push([
        Dm(a, s) + t + 0.9 * n * Math.cos(h + 0.5 * o),
        Dm(a, s) + r + 0.9 * i * Math.sin(h + 0.5 * o),
      ]));
  }
  return [c, l];
}
function Nm(e, t, r, n, i, a, o, s, l) {
  const c = a + Dm(0.1, l),
    h = [];
  h.push([Dm(s, l) + t + 0.9 * n * Math.cos(c - e), Dm(s, l) + r + 0.9 * i * Math.sin(c - e)]);
  for (let d = c; d <= o; d += e)
    h.push([Dm(s, l) + t + n * Math.cos(d), Dm(s, l) + r + i * Math.sin(d)]);
  return (
    h.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
    h.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
    Bm(h, 0, l)
  );
}
function Lm(e, t, r, n, i, a, o, s) {
  const l = [],
    c = [s.maxRandomnessOffset || 1, (s.maxRandomnessOffset || 1) + 0.3];
  let h = [0, 0];
  const d = s.disableMultiStroke ? 1 : 2,
    u = s.preserveVertices;
  for (let p = 0; p < d; p++)
    (0 === p
      ? l.push({ op: 'move', data: [o[0], o[1]] })
      : l.push({ op: 'move', data: [o[0] + (u ? 0 : Dm(c[0], s)), o[1] + (u ? 0 : Dm(c[0], s))] }),
      (h = u ? [i, a] : [i + Dm(c[p], s), a + Dm(c[p], s)]),
      l.push({
        op: 'bcurveTo',
        data: [e + Dm(c[p], s), t + Dm(c[p], s), r + Dm(c[p], s), n + Dm(c[p], s), h[0], h[1]],
      }));
  return l;
}
function Om(e) {
  return [...e];
}
function $m(e, t = 0) {
  const r = e.length;
  if (r < 3) throw new Error('A curve must have at least three points.');
  const n = [];
  if (3 === r) n.push(Om(e[0]), Om(e[1]), Om(e[2]), Om(e[2]));
  else {
    const r = [];
    r.push(e[0], e[0]);
    for (let t = 1; t < e.length; t++) (r.push(e[t]), t === e.length - 1 && r.push(e[t]));
    const i = [],
      a = 1 - t;
    n.push(Om(r[0]));
    for (let e = 1; e + 2 < r.length; e++) {
      const t = r[e];
      ((i[0] = [t[0], t[1]]),
        (i[1] = [
          t[0] + (a * r[e + 1][0] - a * r[e - 1][0]) / 6,
          t[1] + (a * r[e + 1][1] - a * r[e - 1][1]) / 6,
        ]),
        (i[2] = [
          r[e + 1][0] + (a * r[e][0] - a * r[e + 2][0]) / 6,
          r[e + 1][1] + (a * r[e][1] - a * r[e + 2][1]) / 6,
        ]),
        (i[3] = [r[e + 1][0], r[e + 1][1]]),
        n.push(i[1], i[2], i[3]));
    }
  }
  return n;
}
function Im(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
}
function Rm(e, t, r) {
  const n = Im(t, r);
  if (0 === n) return Im(e, t);
  let i = ((e[0] - t[0]) * (r[0] - t[0]) + (e[1] - t[1]) * (r[1] - t[1])) / n;
  return ((i = Math.max(0, Math.min(1, i))), Im(e, zm(t, r, i)));
}
function zm(e, t, r) {
  return [e[0] + (t[0] - e[0]) * r, e[1] + (t[1] - e[1]) * r];
}
function Pm(e, t, r, n) {
  const i = n || [];
  if (
    (function (e, t) {
      const r = e[t + 0],
        n = e[t + 1],
        i = e[t + 2],
        a = e[t + 3];
      let o = 3 * n[0] - 2 * r[0] - a[0];
      o *= o;
      let s = 3 * n[1] - 2 * r[1] - a[1];
      s *= s;
      let l = 3 * i[0] - 2 * a[0] - r[0];
      l *= l;
      let c = 3 * i[1] - 2 * a[1] - r[1];
      return ((c *= c), o < l && (o = l), s < c && (s = c), o + s);
    })(e, t) < r
  ) {
    const r = e[t + 0];
    (i.length ? ((a = i[i.length - 1]), (o = r), Math.sqrt(Im(a, o)) > 1 && i.push(r)) : i.push(r),
      i.push(e[t + 3]));
  } else {
    const n = 0.5,
      a = e[t + 0],
      o = e[t + 1],
      s = e[t + 2],
      l = e[t + 3],
      c = zm(a, o, n),
      h = zm(o, s, n),
      d = zm(s, l, n),
      u = zm(c, h, n),
      p = zm(h, d, n),
      g = zm(u, p, n);
    (Pm([a, c, u, g], 0, r, i), Pm([g, p, d, l], 0, r, i));
  }
  var a, o;
  return i;
}
function jm(e, t) {
  return qm(e, 0, e.length, t);
}
function qm(e, t, r, n, i) {
  const a = i || [],
    o = e[t],
    s = e[r - 1];
  let l = 0,
    c = 1;
  for (let h = t + 1; h < r - 1; ++h) {
    const t = Rm(e[h], o, s);
    t > l && ((l = t), (c = h));
  }
  return (
    Math.sqrt(l) > n
      ? (qm(e, t, c + 1, n, a), qm(e, c, r, n, a))
      : (a.length || a.push(o), a.push(s)),
    a
  );
}
function Wm(e, t = 0.15, r) {
  const n = [],
    i = (e.length - 1) / 3;
  for (let a = 0; a < i; a++) Pm(e, 3 * a, t, n);
  return r && r > 0 ? qm(n, 0, n.length, r) : n;
}
const Um = 'none';
class Hm {
  constructor(e) {
    ((this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: '#000',
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: 'hachure',
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: !1,
      disableMultiStrokeFill: !1,
      preserveVertices: !1,
      fillShapeRoughnessGain: 0.8,
    }),
      (this.config = e || {}),
      this.config.options && (this.defaultOptions = this._o(this.config.options)));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(e) {
    return e ? Object.assign({}, this.defaultOptions, e) : this.defaultOptions;
  }
  _d(e, t, r) {
    return { shape: e, sets: t || [], options: r || this.defaultOptions };
  }
  line(e, t, r, n, i) {
    const a = this._o(i);
    return this._d('line', [fm(e, t, r, n, a)], a);
  }
  rectangle(e, t, r, n, i) {
    const a = this._o(i),
      o = [],
      s = (function (e, t, r, n, i) {
        return mm(
          [
            [e, t],
            [e + r, t],
            [e + r, t + n],
            [e, t + n],
          ],
          !0,
          i
        );
      })(e, t, r, n, a);
    if (a.fill) {
      const i = [
        [e, t],
        [e + r, t],
        [e + r, t + n],
        [e, t + n],
      ];
      'solid' === a.fillStyle ? o.push(wm([i], a)) : o.push(vm([i], a));
    }
    return (a.stroke !== Um && o.push(s), this._d('rectangle', o, a));
  }
  ellipse(e, t, r, n, i) {
    const a = this._o(i),
      o = [],
      s = ym(r, n, a),
      l = xm(e, t, a, s);
    if (a.fill)
      if ('solid' === a.fillStyle) {
        const r = xm(e, t, a, s).opset;
        ((r.type = 'fillPath'), o.push(r));
      } else o.push(vm([l.estimatedPoints], a));
    return (a.stroke !== Um && o.push(l.opset), this._d('ellipse', o, a));
  }
  circle(e, t, r, n) {
    const i = this.ellipse(e, t, r, r, n);
    return ((i.shape = 'circle'), i);
  }
  linearPath(e, t) {
    const r = this._o(t);
    return this._d('linearPath', [mm(e, !1, r)], r);
  }
  arc(e, t, r, n, i, a, o = !1, s) {
    const l = this._o(s),
      c = [],
      h = km(e, t, r, n, i, a, o, !0, l);
    if (o && l.fill)
      if ('solid' === l.fillStyle) {
        const o = Object.assign({}, l);
        o.disableMultiStroke = !0;
        const s = km(e, t, r, n, i, a, !0, !1, o);
        ((s.type = 'fillPath'), c.push(s));
      } else
        c.push(
          (function (e, t, r, n, i, a, o) {
            const s = e,
              l = t;
            let c = Math.abs(r / 2),
              h = Math.abs(n / 2);
            ((c += Dm(0.01 * c, o)), (h += Dm(0.01 * h, o)));
            let d = i,
              u = a;
            for (; d < 0; ) ((d += 2 * Math.PI), (u += 2 * Math.PI));
            u - d > 2 * Math.PI && ((d = 0), (u = 2 * Math.PI));
            const p = (u - d) / o.curveStepCount,
              g = [];
            for (let f = d; f <= u; f += p) g.push([s + c * Math.cos(f), l + h * Math.sin(f)]);
            return (g.push([s + c * Math.cos(u), l + h * Math.sin(u)]), g.push([s, l]), vm([g], o));
          })(e, t, r, n, i, a, l)
        );
    return (l.stroke !== Um && c.push(h), this._d('arc', c, l));
  }
  curve(e, t) {
    const r = this._o(t),
      n = [],
      i = bm(e, r);
    if (r.fill && r.fill !== Um)
      if ('solid' === r.fillStyle) {
        const t = bm(
          e,
          Object.assign(Object.assign({}, r), {
            disableMultiStroke: !0,
            roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0,
          })
        );
        n.push({ type: 'fillPath', ops: this._mergedShape(t.ops) });
      } else {
        const t = [],
          i = e;
        if (i.length) {
          const e = 'number' == typeof i[0][0] ? [i] : i;
          for (const n of e)
            n.length < 3
              ? t.push(...n)
              : 3 === n.length
                ? t.push(...Wm($m([n[0], n[0], n[1], n[2]]), 10, (1 + r.roughness) / 2))
                : t.push(...Wm($m(n), 10, (1 + r.roughness) / 2));
        }
        t.length && n.push(vm([t], r));
      }
    return (r.stroke !== Um && n.push(i), this._d('curve', n, r));
  }
  polygon(e, t) {
    const r = this._o(t),
      n = [],
      i = mm(e, !0, r);
    return (
      r.fill && ('solid' === r.fillStyle ? n.push(wm([e], r)) : n.push(vm([e], r))),
      r.stroke !== Um && n.push(i),
      this._d('polygon', n, r)
    );
  }
  path(e, t) {
    const r = this._o(t),
      n = [];
    if (!e) return this._d('path', n, r);
    e = (e || '').replace(/\n/g, ' ').replace(/(-\s)/g, '-').replace('/(ss)/g', ' ');
    const i = r.fill && 'transparent' !== r.fill && r.fill !== Um,
      a = r.stroke !== Um,
      o = !!(r.simplification && r.simplification < 1),
      s = (function (e, t, r) {
        const n = dm(hm(cm(e))),
          i = [];
        let a = [],
          o = [0, 0],
          s = [];
        const l = () => {
            (s.length >= 4 && a.push(...Wm(s, 1)), (s = []));
          },
          c = () => {
            (l(), a.length && (i.push(a), (a = [])));
          };
        for (const { key: d, data: u } of n)
          switch (d) {
            case 'M':
              (c(), (o = [u[0], u[1]]), a.push(o));
              break;
            case 'L':
              (l(), a.push([u[0], u[1]]));
              break;
            case 'C':
              if (!s.length) {
                const e = a.length ? a[a.length - 1] : o;
                s.push([e[0], e[1]]);
              }
              (s.push([u[0], u[1]]), s.push([u[2], u[3]]), s.push([u[4], u[5]]));
              break;
            case 'Z':
              (l(), a.push([o[0], o[1]]));
          }
        if ((c(), !r)) return i;
        const h = [];
        for (const d of i) {
          const e = jm(d, r);
          e.length && h.push(e);
        }
        return h;
      })(e, 0, o ? 4 - 4 * (r.simplification || 1) : (1 + r.roughness) / 2),
      l = Cm(e, r);
    if (i)
      if ('solid' === r.fillStyle)
        if (1 === s.length) {
          const t = Cm(
            e,
            Object.assign(Object.assign({}, r), {
              disableMultiStroke: !0,
              roughness: r.roughness ? r.roughness + r.fillShapeRoughnessGain : 0,
            })
          );
          n.push({ type: 'fillPath', ops: this._mergedShape(t.ops) });
        } else n.push(wm(s, r));
      else n.push(vm(s, r));
    return (
      a &&
        (o
          ? s.forEach((e) => {
              n.push(mm(e, !1, r));
            })
          : n.push(l)),
      this._d('path', n, r)
    );
  }
  opsToPath(e, t) {
    let r = '';
    for (const n of e.ops) {
      const e = 'number' == typeof t && t >= 0 ? n.data.map((e) => +e.toFixed(t)) : n.data;
      switch (n.op) {
        case 'move':
          r += `M${e[0]} ${e[1]} `;
          break;
        case 'bcurveTo':
          r += `C${e[0]} ${e[1]}, ${e[2]} ${e[3]}, ${e[4]} ${e[5]} `;
          break;
        case 'lineTo':
          r += `L${e[0]} ${e[1]} `;
      }
    }
    return r.trim();
  }
  toPaths(e) {
    const t = e.sets || [],
      r = e.options || this.defaultOptions,
      n = [];
    for (const i of t) {
      let e = null;
      switch (i.type) {
        case 'path':
          e = { d: this.opsToPath(i), stroke: r.stroke, strokeWidth: r.strokeWidth, fill: Um };
          break;
        case 'fillPath':
          e = { d: this.opsToPath(i), stroke: Um, strokeWidth: 0, fill: r.fill || Um };
          break;
        case 'fillSketch':
          e = this.fillSketch(i, r);
      }
      e && n.push(e);
    }
    return n;
  }
  fillSketch(e, t) {
    let r = t.fillWeight;
    return (
      r < 0 && (r = t.strokeWidth / 2),
      { d: this.opsToPath(e), stroke: t.fill || Um, strokeWidth: r, fill: Um }
    );
  }
  _mergedShape(e) {
    return e.filter((e, t) => 0 === t || 'move' !== e.op);
  }
}
const Gm = 'http://www.w3.org/2000/svg';
class Vm {
  constructor(e, t) {
    ((this.svg = e), (this.gen = new Hm(t)));
  }
  draw(e) {
    const t = e.sets || [],
      r = e.options || this.getDefaultOptions(),
      n = this.svg.ownerDocument || window.document,
      i = n.createElementNS(Gm, 'g'),
      a = e.options.fixedDecimalPlaceDigits;
    for (const o of t) {
      let t = null;
      switch (o.type) {
        case 'path':
          ((t = n.createElementNS(Gm, 'path')),
            t.setAttribute('d', this.opsToPath(o, a)),
            t.setAttribute('stroke', r.stroke),
            t.setAttribute('stroke-width', r.strokeWidth + ''),
            t.setAttribute('fill', 'none'),
            r.strokeLineDash &&
              t.setAttribute('stroke-dasharray', r.strokeLineDash.join(' ').trim()),
            r.strokeLineDashOffset &&
              t.setAttribute('stroke-dashoffset', `${r.strokeLineDashOffset}`));
          break;
        case 'fillPath':
          ((t = n.createElementNS(Gm, 'path')),
            t.setAttribute('d', this.opsToPath(o, a)),
            t.setAttribute('stroke', 'none'),
            t.setAttribute('stroke-width', '0'),
            t.setAttribute('fill', r.fill || ''),
            ('curve' !== e.shape && 'polygon' !== e.shape) ||
              t.setAttribute('fill-rule', 'evenodd'));
          break;
        case 'fillSketch':
          t = this.fillSketch(n, o, r);
      }
      t && i.appendChild(t);
    }
    return i;
  }
  fillSketch(e, t, r) {
    let n = r.fillWeight;
    n < 0 && (n = r.strokeWidth / 2);
    const i = e.createElementNS(Gm, 'path');
    return (
      i.setAttribute('d', this.opsToPath(t, r.fixedDecimalPlaceDigits)),
      i.setAttribute('stroke', r.fill || ''),
      i.setAttribute('stroke-width', n + ''),
      i.setAttribute('fill', 'none'),
      r.fillLineDash && i.setAttribute('stroke-dasharray', r.fillLineDash.join(' ').trim()),
      r.fillLineDashOffset && i.setAttribute('stroke-dashoffset', `${r.fillLineDashOffset}`),
      i
    );
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(e, t) {
    return this.gen.opsToPath(e, t);
  }
  line(e, t, r, n, i) {
    const a = this.gen.line(e, t, r, n, i);
    return this.draw(a);
  }
  rectangle(e, t, r, n, i) {
    const a = this.gen.rectangle(e, t, r, n, i);
    return this.draw(a);
  }
  ellipse(e, t, r, n, i) {
    const a = this.gen.ellipse(e, t, r, n, i);
    return this.draw(a);
  }
  circle(e, t, r, n) {
    const i = this.gen.circle(e, t, r, n);
    return this.draw(i);
  }
  linearPath(e, t) {
    const r = this.gen.linearPath(e, t);
    return this.draw(r);
  }
  polygon(e, t) {
    const r = this.gen.polygon(e, t);
    return this.draw(r);
  }
  arc(e, t, r, n, i, a, o = !1, s) {
    const l = this.gen.arc(e, t, r, n, i, a, o, s);
    return this.draw(l);
  }
  curve(e, t) {
    const r = this.gen.curve(e, t);
    return this.draw(r);
  }
  path(e, t) {
    const r = this.gen.path(e, t);
    return this.draw(r);
  }
}
var Zm = (e, t) => new Vm(e, t),
  Km = ii(async (e, t, r) => {
    var n, i;
    let a;
    const o = t.useHtmlLabels || Go(null == (n = As()) ? void 0 : n.htmlLabels);
    a = r || 'node default';
    const s = e
        .insert('g')
        .attr('class', a)
        .attr('id', t.domId || t.id),
      l = s.insert('g').attr('class', 'label').attr('style', Hp(t.labelStyle));
    let c;
    c = void 0 === t.label ? '' : 'string' == typeof t.label ? t.label : t.label[0];
    const h = await Zf(l, zo(Wp(c), As()), {
      useHtmlLabels: o,
      width: t.width || (null == (i = As().flowchart) ? void 0 : i.wrappingWidth),
      cssClasses: 'markdown-node-label',
      style: t.labelStyle,
      addSvgBackground: !!t.icon || !!t.img,
    });
    let d = h.getBBox();
    const u = ((null == t ? void 0 : t.padding) ?? 0) / 2;
    if (o) {
      const e = h.children[0],
        t = S(h),
        r = e.getElementsByTagName('img');
      if (r) {
        const e = '' === c.replace(/<img[^>]*>/g, '').trim();
        await Promise.all(
          [...r].map(
            (t) =>
              new Promise((r) => {
                function n() {
                  if (((t.style.display = 'flex'), (t.style.flexDirection = 'column'), e)) {
                    const e = As().fontSize
                        ? As().fontSize
                        : window.getComputedStyle(document.body).fontSize,
                      r = 5,
                      [n = ho.fontSize] = zp(e),
                      i = n * r + 'px';
                    ((t.style.minWidth = i), (t.style.maxWidth = i));
                  } else t.style.width = '100%';
                  r(t);
                }
                (ii(n, 'setupImage'),
                  setTimeout(() => {
                    t.complete && n();
                  }),
                  t.addEventListener('error', n),
                  t.addEventListener('load', n));
              })
          )
        );
      }
      ((d = e.getBoundingClientRect()), t.attr('width', d.width), t.attr('height', d.height));
    }
    return (
      o
        ? l.attr('transform', 'translate(' + -d.width / 2 + ', ' + -d.height / 2 + ')')
        : l.attr('transform', 'translate(0, ' + -d.height / 2 + ')'),
      t.centerLabel &&
        l.attr('transform', 'translate(' + -d.width / 2 + ', ' + -d.height / 2 + ')'),
      l.insert('rect', ':first-child'),
      { shapeSvg: s, bbox: d, halfPadding: u, label: l }
    );
  }, 'labelHelper'),
  Ym = ii(async (e, t, r) => {
    var n, i, a, o, s, l;
    const c =
        r.useHtmlLabels ||
        Go(null == (i = null == (n = As()) ? void 0 : n.flowchart) ? void 0 : i.htmlLabels),
      h = e
        .insert('g')
        .attr('class', 'label')
        .attr('style', r.labelStyle || ''),
      d = await Zf(h, zo(Wp(t), As()), {
        useHtmlLabels: c,
        width:
          r.width ||
          (null == (o = null == (a = As()) ? void 0 : a.flowchart) ? void 0 : o.wrappingWidth),
        style: r.labelStyle,
        addSvgBackground: !!r.icon || !!r.img,
      });
    let u = d.getBBox();
    const p = r.padding / 2;
    if (Go(null == (l = null == (s = As()) ? void 0 : s.flowchart) ? void 0 : l.htmlLabels)) {
      const e = d.children[0],
        t = S(d);
      ((u = e.getBoundingClientRect()), t.attr('width', u.width), t.attr('height', u.height));
    }
    return (
      c
        ? h.attr('transform', 'translate(' + -u.width / 2 + ', ' + -u.height / 2 + ')')
        : h.attr('transform', 'translate(0, ' + -u.height / 2 + ')'),
      r.centerLabel &&
        h.attr('transform', 'translate(' + -u.width / 2 + ', ' + -u.height / 2 + ')'),
      h.insert('rect', ':first-child'),
      { shapeSvg: e, bbox: u, halfPadding: p, label: h }
    );
  }, 'insertLabel'),
  Xm = ii((e, t) => {
    const r = t.node().getBBox();
    ((e.width = r.width), (e.height = r.height));
  }, 'updateNodeBounds'),
  Qm = ii(
    (e, t) =>
      ('handDrawn' === e.look ? 'rough-node' : 'node') + ' ' + e.cssClasses + ' ' + (t || ''),
    'getNodeClasses'
  );
function Jm(e) {
  const t = e.map((e, t) => `${0 === t ? 'M' : 'L'}${e.x},${e.y}`);
  return (t.push('Z'), t.join(' '));
}
function eb(e, t, r, n, i, a) {
  const o = [],
    s = r - e,
    l = n - t,
    c = s / a,
    h = (2 * Math.PI) / c,
    d = t + l / 2;
  for (let u = 0; u <= 50; u++) {
    const t = e + (u / 50) * s,
      r = d + i * Math.sin(h * (t - e));
    o.push({ x: t, y: r });
  }
  return o;
}
function tb(e, t, r, n, i, a) {
  const o = [],
    s = (i * Math.PI) / 180,
    l = ((a * Math.PI) / 180 - s) / (n - 1);
  for (let c = 0; c < n; c++) {
    const n = s + c * l,
      i = e + r * Math.cos(n),
      a = t + r * Math.sin(n);
    o.push({ x: -i, y: -a });
  }
  return o;
}
(ii(Jm, 'createPathFromPoints'),
  ii(eb, 'generateFullSineWavePoints'),
  ii(tb, 'generateCirclePoints'));
var rb = ii((e, t) => {
  var r,
    n,
    i = e.x,
    a = e.y,
    o = t.x - i,
    s = t.y - a,
    l = e.width / 2,
    c = e.height / 2;
  return (
    Math.abs(s) * l > Math.abs(o) * c
      ? (s < 0 && (c = -c), (r = 0 === s ? 0 : (c * o) / s), (n = c))
      : (o < 0 && (l = -l), (r = l), (n = 0 === o ? 0 : (l * s) / o)),
    { x: i + r, y: a + n }
  );
}, 'intersectRect');
function nb(e, t) {
  t && e.attr('style', t);
}
async function ib(e) {
  const t = S(document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject')),
    r = t.append('xhtml:div'),
    n = As();
  let i = e.label;
  e.label && ts(e.label) && (i = await is(e.label.replace(as.lineBreakRegex, '\n'), n));
  const a =
    '<span class="' +
    (e.isNode ? 'nodeLabel' : 'edgeLabel') +
    '" ' +
    (e.labelStyle ? 'style="' + e.labelStyle + '"' : '') +
    '>' +
    i +
    '</span>';
  return (
    r.html(zo(a, n)),
    nb(r, e.labelStyle),
    r.style('display', 'inline-block'),
    r.style('padding-right', '1px'),
    r.style('white-space', 'nowrap'),
    r.attr('xmlns', 'http://www.w3.org/1999/xhtml'),
    t.node()
  );
}
(ii(nb, 'applyStyle'), ii(ib, 'addHtmlLabel'));
var ab = ii(async (e, t, r, n) => {
    let i = e || '';
    if (('object' == typeof i && (i = i[0]), Go(As().flowchart.htmlLabels))) {
      ((i = i.replace(/\\n|\n/g, '<br />')), si.info('vertexText' + i));
      const e = {
        isNode: n,
        label: Wp(i).replace(
          /fa[blrs]?:fa-[\w-]+/g,
          (e) => `<i class='${e.replace(':', ' ')}'></i>`
        ),
        labelStyle: t ? t.replace('fill:', 'color:') : t,
      };
      return await ib(e);
    }
    {
      const e = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      e.setAttribute('style', t.replace('color:', 'fill:'));
      let n = [];
      n = 'string' == typeof i ? i.split(/\\n|\n|<br\s*\/?>/gi) : Array.isArray(i) ? i : [];
      for (const t of n) {
        const n = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
        (n.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'),
          n.setAttribute('dy', '1em'),
          n.setAttribute('x', '0'),
          r ? n.setAttribute('class', 'title-row') : n.setAttribute('class', 'row'),
          (n.textContent = t.trim()),
          e.appendChild(n));
      }
      return e;
    }
  }, 'createLabel'),
  ob = ii(
    (e, t, r, n, i) =>
      [
        'M',
        e + i,
        t,
        'H',
        e + r - i,
        'A',
        i,
        i,
        0,
        0,
        1,
        e + r,
        t + i,
        'V',
        t + n - i,
        'A',
        i,
        i,
        0,
        0,
        1,
        e + r - i,
        t + n,
        'H',
        e + i,
        'A',
        i,
        i,
        0,
        0,
        1,
        e,
        t + n - i,
        'V',
        t + i,
        'A',
        i,
        i,
        0,
        0,
        1,
        e + i,
        t,
        'Z',
      ].join(' '),
    'createRoundedRectPathD'
  ),
  sb = ii(async (e, t) => {
    si.info('Creating subgraph rect for ', t.id, t);
    const r = As(),
      { themeVariables: n, handDrawnSeed: i } = r,
      { clusterBkg: a, clusterBorder: o } = n,
      { labelStyles: s, nodeStyles: l, borderStyles: c, backgroundStyles: h } = Hh(t),
      d = e
        .insert('g')
        .attr('class', 'cluster ' + t.cssClasses)
        .attr('id', t.id)
        .attr('data-look', t.look),
      u = Go(r.flowchart.htmlLabels),
      p = d.insert('g').attr('class', 'cluster-label '),
      g = await Zf(p, t.label, { style: t.labelStyle, useHtmlLabels: u, isNode: !0 });
    let f = g.getBBox();
    if (Go(r.flowchart.htmlLabels)) {
      const e = g.children[0],
        t = S(g);
      ((f = e.getBoundingClientRect()), t.attr('width', f.width), t.attr('height', f.height));
    }
    const m = t.width <= f.width + t.padding ? f.width + t.padding : t.width;
    t.width <= f.width + t.padding
      ? (t.diff = (m - t.width) / 2 - t.padding)
      : (t.diff = -t.padding);
    const b = t.height,
      y = t.x - m / 2,
      x = t.y - b / 2;
    let k;
    if ((si.trace('Data ', t, JSON.stringify(t)), 'handDrawn' === t.look)) {
      const e = Zm(d),
        r = Gh(t, { roughness: 0.7, fill: a, stroke: o, fillWeight: 3, seed: i }),
        n = e.path(ob(y, x, m, b, 0), r);
      ((k = d.insert(() => (si.debug('Rough node insert CXC', n), n), ':first-child')),
        k.select('path:nth-child(2)').attr('style', c.join(';')),
        k.select('path').attr('style', h.join(';').replace('fill', 'stroke')));
    } else
      ((k = d.insert('rect', ':first-child')),
        k
          .attr('style', l)
          .attr('rx', t.rx)
          .attr('ry', t.ry)
          .attr('x', y)
          .attr('y', x)
          .attr('width', m)
          .attr('height', b));
    const { subGraphTitleTopMargin: C } = Ph(r);
    if ((p.attr('transform', `translate(${t.x - f.width / 2}, ${t.y - t.height / 2 + C})`), s)) {
      const e = p.select('span');
      e && e.attr('style', s);
    }
    const w = k.node().getBBox();
    return (
      (t.offsetX = 0),
      (t.width = w.width),
      (t.height = w.height),
      (t.offsetY = f.height - t.padding / 2),
      (t.intersect = function (e) {
        return rb(t, e);
      }),
      { cluster: d, labelBBox: f }
    );
  }, 'rect'),
  lb = ii((e, t) => {
    const r = e.insert('g').attr('class', 'note-cluster').attr('id', t.id),
      n = r.insert('rect', ':first-child'),
      i = 0 * t.padding,
      a = i / 2;
    n.attr('rx', t.rx)
      .attr('ry', t.ry)
      .attr('x', t.x - t.width / 2 - a)
      .attr('y', t.y - t.height / 2 - a)
      .attr('width', t.width + i)
      .attr('height', t.height + i)
      .attr('fill', 'none');
    const o = n.node().getBBox();
    return (
      (t.width = o.width),
      (t.height = o.height),
      (t.intersect = function (e) {
        return rb(t, e);
      }),
      { cluster: r, labelBBox: { width: 0, height: 0 } }
    );
  }, 'noteGroup'),
  cb = ii(async (e, t) => {
    const r = As(),
      { themeVariables: n, handDrawnSeed: i } = r,
      { altBackground: a, compositeBackground: o, compositeTitleBackground: s, nodeBorder: l } = n,
      c = e
        .insert('g')
        .attr('class', t.cssClasses)
        .attr('id', t.id)
        .attr('data-id', t.id)
        .attr('data-look', t.look),
      h = c.insert('g', ':first-child'),
      d = c.insert('g').attr('class', 'cluster-label');
    let u = c.append('rect');
    const p = d.node().appendChild(await ab(t.label, t.labelStyle, void 0, !0));
    let g = p.getBBox();
    if (Go(r.flowchart.htmlLabels)) {
      const e = p.children[0],
        t = S(p);
      ((g = e.getBoundingClientRect()), t.attr('width', g.width), t.attr('height', g.height));
    }
    const f = 0 * t.padding,
      m = f / 2,
      b = (t.width <= g.width + t.padding ? g.width + t.padding : t.width) + f;
    t.width <= g.width + t.padding
      ? (t.diff = (b - t.width) / 2 - t.padding)
      : (t.diff = -t.padding);
    const y = t.height + f,
      x = t.height + f - g.height - 6,
      k = t.x - b / 2,
      C = t.y - y / 2;
    t.width = b;
    const w = t.y - t.height / 2 - m + g.height + 2;
    let v;
    if ('handDrawn' === t.look) {
      const e = t.cssClasses.includes('statediagram-cluster-alt'),
        r = Zm(c),
        n =
          t.rx || t.ry
            ? r.path(ob(k, C, b, y, 10), {
                roughness: 0.7,
                fill: s,
                fillStyle: 'solid',
                stroke: l,
                seed: i,
              })
            : r.rectangle(k, C, b, y, { seed: i });
      v = c.insert(() => n, ':first-child');
      const h = r.rectangle(k, w, b, x, {
        fill: e ? a : o,
        fillStyle: e ? 'hachure' : 'solid',
        stroke: l,
        seed: i,
      });
      ((v = c.insert(() => n, ':first-child')), (u = c.insert(() => h)));
    } else {
      v = h.insert('rect', ':first-child');
      const e = 'outer';
      (v
        .attr('class', e)
        .attr('x', k)
        .attr('y', C)
        .attr('width', b)
        .attr('height', y)
        .attr('data-look', t.look),
        u.attr('class', 'inner').attr('x', k).attr('y', w).attr('width', b).attr('height', x));
    }
    d.attr(
      'transform',
      `translate(${t.x - g.width / 2}, ${C + 1 - (Go(r.flowchart.htmlLabels) ? 0 : 3)})`
    );
    const _ = v.node().getBBox();
    return (
      (t.height = _.height),
      (t.offsetX = 0),
      (t.offsetY = g.height - t.padding / 2),
      (t.labelBBox = g),
      (t.intersect = function (e) {
        return rb(t, e);
      }),
      { cluster: c, labelBBox: g }
    );
  }, 'roundedWithTitle'),
  hb = ii(async (e, t) => {
    si.info('Creating subgraph rect for ', t.id, t);
    const r = As(),
      { themeVariables: n, handDrawnSeed: i } = r,
      { clusterBkg: a, clusterBorder: o } = n,
      { labelStyles: s, nodeStyles: l, borderStyles: c, backgroundStyles: h } = Hh(t),
      d = e
        .insert('g')
        .attr('class', 'cluster ' + t.cssClasses)
        .attr('id', t.id)
        .attr('data-look', t.look),
      u = Go(r.flowchart.htmlLabels),
      p = d.insert('g').attr('class', 'cluster-label '),
      g = await Zf(p, t.label, {
        style: t.labelStyle,
        useHtmlLabels: u,
        isNode: !0,
        width: t.width,
      });
    let f = g.getBBox();
    if (Go(r.flowchart.htmlLabels)) {
      const e = g.children[0],
        t = S(g);
      ((f = e.getBoundingClientRect()), t.attr('width', f.width), t.attr('height', f.height));
    }
    const m = t.width <= f.width + t.padding ? f.width + t.padding : t.width;
    t.width <= f.width + t.padding
      ? (t.diff = (m - t.width) / 2 - t.padding)
      : (t.diff = -t.padding);
    const b = t.height,
      y = t.x - m / 2,
      x = t.y - b / 2;
    let k;
    if ((si.trace('Data ', t, JSON.stringify(t)), 'handDrawn' === t.look)) {
      const e = Zm(d),
        r = Gh(t, { roughness: 0.7, fill: a, stroke: o, fillWeight: 4, seed: i }),
        n = e.path(ob(y, x, m, b, t.rx), r);
      ((k = d.insert(() => (si.debug('Rough node insert CXC', n), n), ':first-child')),
        k.select('path:nth-child(2)').attr('style', c.join(';')),
        k.select('path').attr('style', h.join(';').replace('fill', 'stroke')));
    } else
      ((k = d.insert('rect', ':first-child')),
        k
          .attr('style', l)
          .attr('rx', t.rx)
          .attr('ry', t.ry)
          .attr('x', y)
          .attr('y', x)
          .attr('width', m)
          .attr('height', b));
    const { subGraphTitleTopMargin: C } = Ph(r);
    if ((p.attr('transform', `translate(${t.x - f.width / 2}, ${t.y - t.height / 2 + C})`), s)) {
      const e = p.select('span');
      e && e.attr('style', s);
    }
    const w = k.node().getBBox();
    return (
      (t.offsetX = 0),
      (t.width = w.width),
      (t.height = w.height),
      (t.offsetY = f.height - t.padding / 2),
      (t.intersect = function (e) {
        return rb(t, e);
      }),
      { cluster: d, labelBBox: f }
    );
  }, 'kanbanSection'),
  db = {
    rect: sb,
    squareRect: sb,
    roundedWithTitle: cb,
    noteGroup: lb,
    divider: ii((e, t) => {
      const r = As(),
        { themeVariables: n, handDrawnSeed: i } = r,
        { nodeBorder: a } = n,
        o = e.insert('g').attr('class', t.cssClasses).attr('id', t.id).attr('data-look', t.look),
        s = o.insert('g', ':first-child'),
        l = 0 * t.padding,
        c = t.width + l;
      t.diff = -t.padding;
      const h = t.height + l,
        d = t.x - c / 2,
        u = t.y - h / 2;
      let p;
      if (((t.width = c), 'handDrawn' === t.look)) {
        const e = Zm(o).rectangle(d, u, c, h, {
          fill: 'lightgrey',
          roughness: 0.5,
          strokeLineDash: [5],
          stroke: a,
          seed: i,
        });
        p = o.insert(() => e, ':first-child');
      } else {
        p = s.insert('rect', ':first-child');
        const e = 'divider';
        p.attr('class', e)
          .attr('x', d)
          .attr('y', u)
          .attr('width', c)
          .attr('height', h)
          .attr('data-look', t.look);
      }
      const g = p.node().getBBox();
      return (
        (t.height = g.height),
        (t.offsetX = 0),
        (t.offsetY = 0),
        (t.intersect = function (e) {
          return rb(t, e);
        }),
        { cluster: o, labelBBox: {} }
      );
    }, 'divider'),
    kanbanSection: hb,
  },
  ub = new Map(),
  pb = ii(async (e, t) => {
    const r = t.shape || 'rect',
      n = await db[r](e, t);
    return (ub.set(t.id, n), n);
  }, 'insertCluster'),
  gb = ii(() => {
    ub = new Map();
  }, 'clear');
function fb(e, t) {
  return e.intersect(t);
}
ii(fb, 'intersectNode');
var mb = fb;
function bb(e, t, r, n) {
  var i = e.x,
    a = e.y,
    o = i - n.x,
    s = a - n.y,
    l = Math.sqrt(t * t * s * s + r * r * o * o),
    c = Math.abs((t * r * o) / l);
  n.x < i && (c = -c);
  var h = Math.abs((t * r * s) / l);
  return (n.y < a && (h = -h), { x: i + c, y: a + h });
}
ii(bb, 'intersectEllipse');
var yb = bb;
function xb(e, t, r) {
  return yb(e, t, t, r);
}
ii(xb, 'intersectCircle');
var kb = xb;
function Cb(e, t, r, n) {
  {
    const i = t.y - e.y,
      a = e.x - t.x,
      o = t.x * e.y - e.x * t.y,
      s = i * r.x + a * r.y + o,
      l = i * n.x + a * n.y + o,
      c = 1e-6;
    if (0 !== s && 0 !== l && wb(s, l)) return;
    const h = n.y - r.y,
      d = r.x - n.x,
      u = n.x * r.y - r.x * n.y,
      p = h * e.x + d * e.y + u,
      g = h * t.x + d * t.y + u;
    if (Math.abs(p) < c && Math.abs(g) < c && wb(p, g)) return;
    const f = i * d - h * a;
    if (0 === f) return;
    const m = Math.abs(f / 2);
    let b = a * u - d * o;
    const y = b < 0 ? (b - m) / f : (b + m) / f;
    b = h * o - i * u;
    return { x: y, y: b < 0 ? (b - m) / f : (b + m) / f };
  }
}
function wb(e, t) {
  return e * t > 0;
}
(ii(Cb, 'intersectLine'), ii(wb, 'sameSign'));
var vb = Cb;
function _b(e, t, r) {
  let n = e.x,
    i = e.y,
    a = [],
    o = Number.POSITIVE_INFINITY,
    s = Number.POSITIVE_INFINITY;
  'function' == typeof t.forEach
    ? t.forEach(function (e) {
        ((o = Math.min(o, e.x)), (s = Math.min(s, e.y)));
      })
    : ((o = Math.min(o, t.x)), (s = Math.min(s, t.y)));
  let l = n - e.width / 2 - o,
    c = i - e.height / 2 - s;
  for (let h = 0; h < t.length; h++) {
    let n = t[h],
      i = t[h < t.length - 1 ? h + 1 : 0],
      o = vb(e, r, { x: l + n.x, y: c + n.y }, { x: l + i.x, y: c + i.y });
    o && a.push(o);
  }
  return a.length
    ? (a.length > 1 &&
        a.sort(function (e, t) {
          let n = e.x - r.x,
            i = e.y - r.y,
            a = Math.sqrt(n * n + i * i),
            o = t.x - r.x,
            s = t.y - r.y,
            l = Math.sqrt(o * o + s * s);
          return a < l ? -1 : a === l ? 0 : 1;
        }),
      a[0])
    : e;
}
ii(_b, 'intersectPolygon');
var Sb = { node: mb, circle: kb, ellipse: yb, polygon: _b, rect: rb };
function Eb(e, t) {
  const { labelStyles: r } = Hh(t);
  t.labelStyle = r;
  const n = Qm(t);
  let i = n;
  n || (i = 'anchor');
  const a = e
      .insert('g')
      .attr('class', i)
      .attr('id', t.domId || t.id),
    { cssStyles: o } = t,
    s = Zm(a),
    l = Gh(t, { fill: 'black', stroke: 'none', fillStyle: 'solid' });
  'handDrawn' !== t.look && (l.roughness = 0);
  const c = s.circle(0, 0, 2, l),
    h = a.insert(() => c, ':first-child');
  return (
    h.attr('class', 'anchor').attr('style', Hp(o)),
    Xm(t, h),
    (t.intersect = function (e) {
      return (si.info('Circle intersect', t, 1, e), Sb.circle(t, 1, e));
    }),
    a
  );
}
function Db(e, t, r, n, i, a, o) {
  const s = (e + r) / 2,
    l = (t + n) / 2,
    c = Math.atan2(n - t, r - e),
    h = (r - e) / 2 / i,
    d = (n - t) / 2 / a,
    u = Math.sqrt(h ** 2 + d ** 2);
  if (u > 1) throw new Error('The given radii are too small to create an arc between the points.');
  const p = Math.sqrt(1 - u ** 2),
    g = s + p * a * Math.sin(c) * (o ? -1 : 1),
    f = l - p * i * Math.cos(c) * (o ? -1 : 1),
    m = Math.atan2((t - f) / a, (e - g) / i);
  let b = Math.atan2((n - f) / a, (r - g) / i) - m;
  (o && b < 0 && (b += 2 * Math.PI), !o && b > 0 && (b -= 2 * Math.PI));
  const y = [];
  for (let x = 0; x < 20; x++) {
    const e = m + (x / 19) * b,
      t = g + i * Math.cos(e),
      r = f + a * Math.sin(e);
    y.push({ x: t, y: r });
  }
  return y;
}
async function Ab(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.width + t.padding + 20,
    s = a.height + t.padding,
    l = s / 2,
    c = l / (2.5 + s / 50),
    { cssStyles: h } = t,
    d = [
      { x: o / 2, y: -s / 2 },
      { x: -o / 2, y: -s / 2 },
      ...Db(-o / 2, -s / 2, -o / 2, s / 2, c, l, !1),
      { x: o / 2, y: s / 2 },
      ...Db(o / 2, s / 2, o / 2, -s / 2, c, l, !0),
    ],
    u = Zm(i),
    p = Gh(t, {});
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = Jm(d),
    f = u.path(g, p),
    m = i.insert(() => f, ':first-child');
  return (
    m.attr('class', 'basic label-container'),
    h && 'handDrawn' !== t.look && m.selectAll('path').attr('style', h),
    n && 'handDrawn' !== t.look && m.selectAll('path').attr('style', n),
    m.attr('transform', `translate(${c / 2}, 0)`),
    Xm(t, m),
    (t.intersect = function (e) {
      return Sb.polygon(t, d, e);
    }),
    i
  );
}
function Tb(e, t, r, n) {
  return e
    .insert('polygon', ':first-child')
    .attr(
      'points',
      n
        .map(function (e) {
          return e.x + ',' + e.y;
        })
        .join(' ')
    )
    .attr('class', 'label-container')
    .attr('transform', 'translate(' + -t / 2 + ',' + r / 2 + ')');
}
async function Fb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.height + t.padding,
    s = a.width + t.padding + 12,
    l = -o,
    c = [
      { x: 12, y: l },
      { x: s, y: l },
      { x: s, y: 0 },
      { x: 0, y: 0 },
      { x: 0, y: l + 12 },
      { x: 12, y: l },
    ];
  let h;
  const { cssStyles: d } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = Jm(c),
      a = e.path(n, r);
    ((h = i.insert(() => a, ':first-child').attr('transform', `translate(${-s / 2}, ${o / 2})`)),
      d && h.attr('style', d));
  } else h = Tb(i, s, o, c);
  return (
    n && h.attr('style', n),
    Xm(t, h),
    (t.intersect = function (e) {
      return Sb.polygon(t, c, e);
    }),
    i
  );
}
function Bb(e, t) {
  const { nodeStyles: r } = Hh(t);
  t.label = '';
  const n = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId ?? t.id),
    { cssStyles: i } = t,
    a = Math.max(28, t.width ?? 0),
    o = [
      { x: 0, y: a / 2 },
      { x: a / 2, y: 0 },
      { x: 0, y: -a / 2 },
      { x: -a / 2, y: 0 },
    ],
    s = Zm(n),
    l = Gh(t, {});
  'handDrawn' !== t.look && ((l.roughness = 0), (l.fillStyle = 'solid'));
  const c = Jm(o),
    h = s.path(c, l),
    d = n.insert(() => h, ':first-child');
  return (
    i && 'handDrawn' !== t.look && d.selectAll('path').attr('style', i),
    r && 'handDrawn' !== t.look && d.selectAll('path').attr('style', r),
    (t.width = 28),
    (t.height = 28),
    (t.intersect = function (e) {
      return Sb.polygon(t, o, e);
    }),
    n
  );
}
async function Mb(e, t, r) {
  const { labelStyles: n, nodeStyles: i } = Hh(t);
  t.labelStyle = n;
  const { shapeSvg: a, bbox: o, halfPadding: s } = await Km(e, t, Qm(t)),
    l = (null == r ? void 0 : r.padding) ?? s,
    c = o.width / 2 + l;
  let h;
  const { cssStyles: d } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(a),
      r = Gh(t, {}),
      n = e.circle(0, 0, 2 * c, r);
    ((h = a.insert(() => n, ':first-child')),
      h.attr('class', 'basic label-container').attr('style', Hp(d)));
  } else
    h = a
      .insert('circle', ':first-child')
      .attr('class', 'basic label-container')
      .attr('style', i)
      .attr('r', c)
      .attr('cx', 0)
      .attr('cy', 0);
  return (
    Xm(t, h),
    (t.calcIntersect = function (e, t) {
      const r = e.width / 2;
      return Sb.circle(e, r, t);
    }),
    (t.intersect = function (e) {
      return (si.info('Circle intersect', t, c, e), Sb.circle(t, c, e));
    }),
    a
  );
}
function Nb(e) {
  const t = Math.cos(Math.PI / 4),
    r = Math.sin(Math.PI / 4),
    n = 2 * e;
  return `M ${(-n / 2) * t},${(n / 2) * r} L ${(n / 2) * t},${(-n / 2) * r}\n                   M ${(n / 2) * t},${(n / 2) * r} L ${(-n / 2) * t},${(-n / 2) * r}`;
}
function Lb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  ((t.labelStyle = r), (t.label = ''));
  const i = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId ?? t.id),
    a = Math.max(30, (null == t ? void 0 : t.width) ?? 0),
    { cssStyles: o } = t,
    s = Zm(i),
    l = Gh(t, {});
  'handDrawn' !== t.look && ((l.roughness = 0), (l.fillStyle = 'solid'));
  const c = s.circle(0, 0, 2 * a, l),
    h = Nb(a),
    d = s.path(h, l),
    u = i.insert(() => c, ':first-child');
  return (
    u.insert(() => d),
    o && 'handDrawn' !== t.look && u.selectAll('path').attr('style', o),
    n && 'handDrawn' !== t.look && u.selectAll('path').attr('style', n),
    Xm(t, u),
    (t.intersect = function (e) {
      si.info('crossedCircle intersect', t, { radius: a, point: e });
      return Sb.circle(t, a, e);
    }),
    i
  );
}
function Ob(e, t, r, n = 100, i = 0, a = 180) {
  const o = [],
    s = (i * Math.PI) / 180,
    l = ((a * Math.PI) / 180 - s) / (n - 1);
  for (let c = 0; c < n; c++) {
    const n = s + c * l,
      i = e + r * Math.cos(n),
      a = t + r * Math.sin(n);
    o.push({ x: -i, y: -a });
  }
  return o;
}
async function $b(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = a.width + (t.padding ?? 0),
    l = a.height + (t.padding ?? 0),
    c = Math.max(5, 0.1 * l),
    { cssStyles: h } = t,
    d = [
      ...Ob(s / 2, -l / 2, c, 30, -90, 0),
      { x: -s / 2 - c, y: c },
      ...Ob(s / 2 + 2 * c, -c, c, 20, -180, -270),
      ...Ob(s / 2 + 2 * c, c, c, 20, -90, -180),
      { x: -s / 2 - c, y: -l / 2 },
      ...Ob(s / 2, l / 2, c, 20, 0, 90),
    ],
    u = [
      { x: s / 2, y: -l / 2 - c },
      { x: -s / 2, y: -l / 2 - c },
      ...Ob(s / 2, -l / 2, c, 20, -90, 0),
      { x: -s / 2 - c, y: -c },
      ...Ob(s / 2 + 0.1 * s, -c, c, 20, -180, -270),
      ...Ob(s / 2 + 0.1 * s, c, c, 20, -90, -180),
      { x: -s / 2 - c, y: l / 2 },
      ...Ob(s / 2, l / 2, c, 20, 0, 90),
      { x: -s / 2, y: l / 2 + c },
      { x: s / 2, y: l / 2 + c },
    ],
    p = Zm(i),
    g = Gh(t, { fill: 'none' });
  'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid'));
  const f = Jm(d).replace('Z', ''),
    m = p.path(f, g),
    b = Jm(u),
    y = p.path(b, { ...g }),
    x = i.insert('g', ':first-child');
  return (
    x.insert(() => y, ':first-child').attr('stroke-opacity', 0),
    x.insert(() => m, ':first-child'),
    x.attr('class', 'text'),
    h && 'handDrawn' !== t.look && x.selectAll('path').attr('style', h),
    n && 'handDrawn' !== t.look && x.selectAll('path').attr('style', n),
    x.attr('transform', `translate(${c}, 0)`),
    o.attr(
      'transform',
      `translate(${-s / 2 + c - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, x),
    (t.intersect = function (e) {
      return Sb.polygon(t, u, e);
    }),
    i
  );
}
function Ib(e, t, r, n = 100, i = 0, a = 180) {
  const o = [],
    s = (i * Math.PI) / 180,
    l = ((a * Math.PI) / 180 - s) / (n - 1);
  for (let c = 0; c < n; c++) {
    const n = s + c * l,
      i = e + r * Math.cos(n),
      a = t + r * Math.sin(n);
    o.push({ x: i, y: a });
  }
  return o;
}
async function Rb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = a.width + (t.padding ?? 0),
    l = a.height + (t.padding ?? 0),
    c = Math.max(5, 0.1 * l),
    { cssStyles: h } = t,
    d = [
      ...Ib(s / 2, -l / 2, c, 20, -90, 0),
      { x: s / 2 + c, y: -c },
      ...Ib(s / 2 + 2 * c, -c, c, 20, -180, -270),
      ...Ib(s / 2 + 2 * c, c, c, 20, -90, -180),
      { x: s / 2 + c, y: l / 2 },
      ...Ib(s / 2, l / 2, c, 20, 0, 90),
    ],
    u = [
      { x: -s / 2, y: -l / 2 - c },
      { x: s / 2, y: -l / 2 - c },
      ...Ib(s / 2, -l / 2, c, 20, -90, 0),
      { x: s / 2 + c, y: -c },
      ...Ib(s / 2 + 2 * c, -c, c, 20, -180, -270),
      ...Ib(s / 2 + 2 * c, c, c, 20, -90, -180),
      { x: s / 2 + c, y: l / 2 },
      ...Ib(s / 2, l / 2, c, 20, 0, 90),
      { x: s / 2, y: l / 2 + c },
      { x: -s / 2, y: l / 2 + c },
    ],
    p = Zm(i),
    g = Gh(t, { fill: 'none' });
  'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid'));
  const f = Jm(d).replace('Z', ''),
    m = p.path(f, g),
    b = Jm(u),
    y = p.path(b, { ...g }),
    x = i.insert('g', ':first-child');
  return (
    x.insert(() => y, ':first-child').attr('stroke-opacity', 0),
    x.insert(() => m, ':first-child'),
    x.attr('class', 'text'),
    h && 'handDrawn' !== t.look && x.selectAll('path').attr('style', h),
    n && 'handDrawn' !== t.look && x.selectAll('path').attr('style', n),
    x.attr('transform', `translate(${-c}, 0)`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, x),
    (t.intersect = function (e) {
      return Sb.polygon(t, u, e);
    }),
    i
  );
}
function zb(e, t, r, n = 100, i = 0, a = 180) {
  const o = [],
    s = (i * Math.PI) / 180,
    l = ((a * Math.PI) / 180 - s) / (n - 1);
  for (let c = 0; c < n; c++) {
    const n = s + c * l,
      i = e + r * Math.cos(n),
      a = t + r * Math.sin(n);
    o.push({ x: -i, y: -a });
  }
  return o;
}
async function Pb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = a.width + (t.padding ?? 0),
    l = a.height + (t.padding ?? 0),
    c = Math.max(5, 0.1 * l),
    { cssStyles: h } = t,
    d = [
      ...zb(s / 2, -l / 2, c, 30, -90, 0),
      { x: -s / 2 - c, y: c },
      ...zb(s / 2 + 2 * c, -c, c, 20, -180, -270),
      ...zb(s / 2 + 2 * c, c, c, 20, -90, -180),
      { x: -s / 2 - c, y: -l / 2 },
      ...zb(s / 2, l / 2, c, 20, 0, 90),
    ],
    u = [
      ...zb(-s / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
      { x: s / 2 - c / 2, y: c },
      ...zb(-s / 2 - c / 2, -c, c, 20, 0, 90),
      ...zb(-s / 2 - c / 2, c, c, 20, -90, 0),
      { x: s / 2 - c / 2, y: -c },
      ...zb(-s / 2 + c + c / 2, l / 2, c, 30, -180, -270),
    ],
    p = [
      { x: s / 2, y: -l / 2 - c },
      { x: -s / 2, y: -l / 2 - c },
      ...zb(s / 2, -l / 2, c, 20, -90, 0),
      { x: -s / 2 - c, y: -c },
      ...zb(s / 2 + 2 * c, -c, c, 20, -180, -270),
      ...zb(s / 2 + 2 * c, c, c, 20, -90, -180),
      { x: -s / 2 - c, y: l / 2 },
      ...zb(s / 2, l / 2, c, 20, 0, 90),
      { x: -s / 2, y: l / 2 + c },
      { x: s / 2 - c - c / 2, y: l / 2 + c },
      ...zb(-s / 2 + c + c / 2, -l / 2, c, 20, -90, -180),
      { x: s / 2 - c / 2, y: c },
      ...zb(-s / 2 - c / 2, -c, c, 20, 0, 90),
      ...zb(-s / 2 - c / 2, c, c, 20, -90, 0),
      { x: s / 2 - c / 2, y: -c },
      ...zb(-s / 2 + c + c / 2, l / 2, c, 30, -180, -270),
    ],
    g = Zm(i),
    f = Gh(t, { fill: 'none' });
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = Jm(d).replace('Z', ''),
    b = g.path(m, f),
    y = Jm(u).replace('Z', ''),
    x = g.path(y, f),
    k = Jm(p),
    C = g.path(k, { ...f }),
    w = i.insert('g', ':first-child');
  return (
    w.insert(() => C, ':first-child').attr('stroke-opacity', 0),
    w.insert(() => b, ':first-child'),
    w.insert(() => x, ':first-child'),
    w.attr('class', 'text'),
    h && 'handDrawn' !== t.look && w.selectAll('path').attr('style', h),
    n && 'handDrawn' !== t.look && w.selectAll('path').attr('style', n),
    w.attr('transform', `translate(${c - c / 4}, 0)`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, w),
    (t.intersect = function (e) {
      return Sb.polygon(t, p, e);
    }),
    i
  );
}
async function jb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(80, 1.25 * (a.width + 2 * (t.padding ?? 0)), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(20, a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = s / 2,
    { cssStyles: c } = t,
    h = Zm(i),
    d = Gh(t, {});
  'handDrawn' !== t.look && ((d.roughness = 0), (d.fillStyle = 'solid'));
  const u = o - l,
    p = s / 4,
    g = [
      { x: u, y: 0 },
      { x: p, y: 0 },
      { x: 0, y: s / 2 },
      { x: p, y: s },
      { x: u, y: s },
      ...tb(-u, -s / 2, l, 50, 270, 90),
    ],
    f = Jm(g),
    m = h.path(f, d),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container'),
    c && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', c),
    n && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', n),
    b.attr('transform', `translate(${-o / 2}, ${-s / 2})`),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
(ii(Eb, 'anchor'),
  ii(Db, 'generateArcPoints'),
  ii(Ab, 'bowTieRect'),
  ii(Tb, 'insertPolygonShape'),
  ii(Fb, 'card'),
  ii(Bb, 'choice'),
  ii(Mb, 'circle'),
  ii(Nb, 'createLine'),
  ii(Lb, 'crossedCircle'),
  ii(Ob, 'generateCirclePoints'),
  ii($b, 'curlyBraceLeft'),
  ii(Ib, 'generateCirclePoints'),
  ii(Rb, 'curlyBraceRight'),
  ii(zb, 'generateCirclePoints'),
  ii(Pb, 'curlyBraces'),
  ii(jb, 'curvedTrapezoid'));
var qb = ii(
    (e, t, r, n, i, a) =>
      [
        `M${e},${t + a}`,
        `a${i},${a} 0,0,0 ${r},0`,
        `a${i},${a} 0,0,0 ${-r},0`,
        `l0,${n}`,
        `a${i},${a} 0,0,0 ${r},0`,
        'l0,' + -n,
      ].join(' '),
    'createCylinderPathD'
  ),
  Wb = ii(
    (e, t, r, n, i, a) =>
      [
        `M${e},${t + a}`,
        `M${e + r},${t + a}`,
        `a${i},${a} 0,0,0 ${-r},0`,
        `l0,${n}`,
        `a${i},${a} 0,0,0 ${r},0`,
        'l0,' + -n,
      ].join(' '),
    'createOuterCylinderPathD'
  ),
  Ub = ii(
    (e, t, r, n, i, a) => [`M${e - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(' '),
    'createInnerCylinderPathD'
  );
async function Hb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + t.padding, t.width ?? 0),
    l = s / 2,
    c = l / (2.5 + s / 50),
    h = Math.max(a.height + c + t.padding, t.height ?? 0);
  let d;
  const { cssStyles: u } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Wb(0, 0, s, h, l, c),
      n = Ub(0, c, s, h, l, c),
      a = e.path(r, Gh(t, {})),
      o = e.path(n, Gh(t, { fill: 'none' }));
    ((d = i.insert(() => o, ':first-child')),
      (d = i.insert(() => a, ':first-child')),
      d.attr('class', 'basic label-container'),
      u && d.attr('style', u));
  } else {
    const e = qb(0, 0, s, h, l, c);
    d = i
      .insert('path', ':first-child')
      .attr('d', e)
      .attr('class', 'basic label-container')
      .attr('style', Hp(u))
      .attr('style', n);
  }
  return (
    d.attr('label-offset-y', c),
    d.attr('transform', `translate(${-s / 2}, ${-(h / 2 + c)})`),
    Xm(t, d),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-a.height / 2 + (t.padding ?? 0) / 1.5 - (a.y - (a.top ?? 0))})`
    ),
    (t.intersect = function (e) {
      const r = Sb.rect(t, e),
        n = r.x - (t.x ?? 0);
      if (
        0 != l &&
        (Math.abs(n) < (t.width ?? 0) / 2 ||
          (Math.abs(n) == (t.width ?? 0) / 2 &&
            Math.abs(r.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - c))
      ) {
        let i = c * c * (1 - (n * n) / (l * l));
        (i > 0 && (i = Math.sqrt(i)), (i = c - i), e.y - (t.y ?? 0) > 0 && (i = -i), (r.y += i));
      }
      return r;
    }),
    i
  );
}
async function Gb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = a.width + t.padding,
    l = a.height + t.padding,
    c = 0.2 * l,
    h = -s / 2,
    d = -l / 2 - c / 2,
    { cssStyles: u } = t,
    p = Zm(i),
    g = Gh(t, {});
  'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid'));
  const f = [
      { x: h, y: d + c },
      { x: -h, y: d + c },
      { x: -h, y: -d },
      { x: h, y: -d },
      { x: h, y: d },
      { x: -h, y: d },
      { x: -h, y: d + c },
    ],
    m = p.polygon(
      f.map((e) => [e.x, e.y]),
      g
    ),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container'),
    u && 'handDrawn' !== t.look && b.selectAll('path').attr('style', u),
    n && 'handDrawn' !== t.look && b.selectAll('path').attr('style', n),
    o.attr(
      'transform',
      `translate(${h + (t.padding ?? 0) / 2 - (a.x - (a.left ?? 0))}, ${d + c + (t.padding ?? 0) / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    i
  );
}
async function Vb(e, t) {
  var r, n;
  const { labelStyles: i, nodeStyles: a } = Hh(t);
  t.labelStyle = i;
  const { shapeSvg: o, bbox: s, halfPadding: l } = await Km(e, t, Qm(t)),
    c = s.width / 2 + l + 5,
    h = s.width / 2 + l;
  let d;
  const { cssStyles: u } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(o),
      i = Gh(t, { roughness: 0.2, strokeWidth: 2.5 }),
      a = Gh(t, { roughness: 0.2, strokeWidth: 1.5 }),
      s = e.circle(0, 0, 2 * c, i),
      l = e.circle(0, 0, 2 * h, a);
    ((d = o.insert('g', ':first-child')),
      d.attr('class', Hp(t.cssClasses)).attr('style', Hp(u)),
      null == (r = d.node()) || r.appendChild(s),
      null == (n = d.node()) || n.appendChild(l));
  } else {
    d = o.insert('g', ':first-child');
    const e = d.insert('circle', ':first-child'),
      t = d.insert('circle');
    (d.attr('class', 'basic label-container').attr('style', a),
      e.attr('class', 'outer-circle').attr('style', a).attr('r', c).attr('cx', 0).attr('cy', 0),
      t.attr('class', 'inner-circle').attr('style', a).attr('r', h).attr('cx', 0).attr('cy', 0));
  }
  return (
    Xm(t, d),
    (t.intersect = function (e) {
      return (si.info('DoubleCircle intersect', t, c, e), Sb.circle(t, c, e));
    }),
    o
  );
}
function Zb(e, t, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Hh(t);
  ((t.label = ''), (t.labelStyle = n));
  const a = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId ?? t.id),
    { cssStyles: o } = t,
    s = Zm(a),
    { nodeBorder: l } = r,
    c = Gh(t, { fillStyle: 'solid' });
  'handDrawn' !== t.look && (c.roughness = 0);
  const h = s.circle(0, 0, 14, c),
    d = a.insert(() => h, ':first-child');
  return (
    d.selectAll('path').attr('style', `fill: ${l} !important;`),
    o && o.length > 0 && 'handDrawn' !== t.look && d.selectAll('path').attr('style', o),
    i && 'handDrawn' !== t.look && d.selectAll('path').attr('style', i),
    Xm(t, d),
    (t.intersect = function (e) {
      si.info('filledCircle intersect', t, { radius: 7, point: e });
      return Sb.circle(t, 7, e);
    }),
    a
  );
}
async function Kb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = a.width + (t.padding ?? 0),
    l = s + a.height,
    c = s + a.height,
    h = [
      { x: 0, y: -l },
      { x: c, y: -l },
      { x: c / 2, y: 0 },
    ],
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {});
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = Jm(h),
    f = u.path(g, p),
    m = i.insert(() => f, ':first-child').attr('transform', `translate(${-l / 2}, ${l / 2})`);
  return (
    d && 'handDrawn' !== t.look && m.selectChildren('path').attr('style', d),
    n && 'handDrawn' !== t.look && m.selectChildren('path').attr('style', n),
    (t.width = s),
    (t.height = l),
    Xm(t, m),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-l / 2 + (t.padding ?? 0) / 2 + (a.y - (a.top ?? 0))})`
    ),
    (t.intersect = function (e) {
      return (si.info('Triangle intersect', t, h, e), Sb.polygon(t, h, e));
    }),
    i
  );
}
function Yb(e, t, { dir: r, config: { state: n, themeVariables: i } }) {
  const { nodeStyles: a } = Hh(t);
  t.label = '';
  const o = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId ?? t.id),
    { cssStyles: s } = t;
  let l = Math.max(70, (null == t ? void 0 : t.width) ?? 0),
    c = Math.max(10, (null == t ? void 0 : t.height) ?? 0);
  'LR' === r &&
    ((l = Math.max(10, (null == t ? void 0 : t.width) ?? 0)),
    (c = Math.max(70, (null == t ? void 0 : t.height) ?? 0)));
  const h = (-1 * l) / 2,
    d = (-1 * c) / 2,
    u = Zm(o),
    p = Gh(t, { stroke: i.lineColor, fill: i.lineColor });
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = u.rectangle(h, d, l, c, p),
    f = o.insert(() => g, ':first-child');
  (s && 'handDrawn' !== t.look && f.selectAll('path').attr('style', s),
    a && 'handDrawn' !== t.look && f.selectAll('path').attr('style', a),
    Xm(t, f));
  const m = (null == n ? void 0 : n.padding) ?? 0;
  return (
    t.width && t.height && ((t.width += m / 2 || 0), (t.height += m / 2 || 0)),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    o
  );
}
async function Xb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(80, a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(50, a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = s / 2,
    { cssStyles: c } = t,
    h = Zm(i),
    d = Gh(t, {});
  'handDrawn' !== t.look && ((d.roughness = 0), (d.fillStyle = 'solid'));
  const u = [
      { x: -o / 2, y: -s / 2 },
      { x: o / 2 - l, y: -s / 2 },
      ...tb(-o / 2 + l, 0, l, 50, 90, 270),
      { x: o / 2 - l, y: s / 2 },
      { x: -o / 2, y: s / 2 },
    ],
    p = Jm(u),
    g = h.path(p, d),
    f = i.insert(() => g, ':first-child');
  return (
    f.attr('class', 'basic label-container'),
    c && 'handDrawn' !== t.look && f.selectChildren('path').attr('style', c),
    n && 'handDrawn' !== t.look && f.selectChildren('path').attr('style', n),
    Xm(t, f),
    (t.intersect = function (e) {
      si.info('Pill intersect', t, { radius: l, point: e });
      return Sb.polygon(t, u, e);
    }),
    i
  );
}
async function Qb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.height + (t.padding ?? 0),
    s = a.width + 2.5 * (t.padding ?? 0),
    { cssStyles: l } = t,
    c = Zm(i),
    h = Gh(t, {});
  'handDrawn' !== t.look && ((h.roughness = 0), (h.fillStyle = 'solid'));
  let d = s / 2;
  d += d / 6;
  const u = o / 2,
    p = d - u / 2,
    g = [
      { x: -p, y: -u },
      { x: 0, y: -u },
      { x: p, y: -u },
      { x: d, y: 0 },
      { x: p, y: u },
      { x: 0, y: u },
      { x: -p, y: u },
      { x: -d, y: 0 },
    ],
    f = Jm(g),
    m = c.path(f, h),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container'),
    l && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', l),
    n && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', n),
    (t.width = s),
    (t.height = o),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
async function Jb(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  ((t.label = ''), (t.labelStyle = r));
  const { shapeSvg: i } = await Km(e, t, Qm(t)),
    a = Math.max(30, (null == t ? void 0 : t.width) ?? 0),
    o = Math.max(30, (null == t ? void 0 : t.height) ?? 0),
    { cssStyles: s } = t,
    l = Zm(i),
    c = Gh(t, {});
  'handDrawn' !== t.look && ((c.roughness = 0), (c.fillStyle = 'solid'));
  const h = [
      { x: 0, y: 0 },
      { x: a, y: 0 },
      { x: 0, y: o },
      { x: a, y: o },
    ],
    d = Jm(h),
    u = l.path(d, c),
    p = i.insert(() => u, ':first-child');
  return (
    p.attr('class', 'basic label-container'),
    s && 'handDrawn' !== t.look && p.selectChildren('path').attr('style', s),
    n && 'handDrawn' !== t.look && p.selectChildren('path').attr('style', n),
    p.attr('transform', `translate(${-a / 2}, ${-o / 2})`),
    Xm(t, p),
    (t.intersect = function (e) {
      si.info('Pill intersect', t, { points: h });
      return Sb.polygon(t, h, e);
    }),
    i
  );
}
async function ey(e, t, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Hh(t);
  t.labelStyle = i;
  const a = t.assetHeight ?? 48,
    o = t.assetWidth ?? 48,
    s = Math.max(a, o),
    l = null == n ? void 0 : n.wrappingWidth;
  t.width = Math.max(s, l ?? 0);
  const { shapeSvg: c, bbox: h, label: d } = await Km(e, t, 'icon-shape default'),
    u = 't' === t.pos,
    p = s,
    g = s,
    { nodeBorder: f } = r,
    { stylesMap: m } = qh(t),
    b = -g / 2,
    y = -p / 2,
    x = t.label ? 8 : 0,
    k = Zm(c),
    C = Gh(t, { stroke: 'none', fill: 'none' });
  'handDrawn' !== t.look && ((C.roughness = 0), (C.fillStyle = 'solid'));
  const w = k.rectangle(b, y, g, p, C),
    v = Math.max(g, h.width),
    _ = p + h.height + x,
    S = k.rectangle(-v / 2, -_ / 2, v, _, { ...C, fill: 'transparent', stroke: 'none' }),
    E = c.insert(() => w, ':first-child'),
    D = c.insert(() => S);
  if (t.icon) {
    const e = c.append('g');
    e.html(`<g>${await Bf(t.icon, { height: s, width: s, fallbackPrefix: '' })}</g>`);
    const r = e.node().getBBox(),
      n = r.width,
      i = r.height,
      a = r.x,
      o = r.y;
    (e.attr(
      'transform',
      `translate(${-n / 2 - a},${u ? h.height / 2 + x / 2 - i / 2 - o : -h.height / 2 - x / 2 - i / 2 - o})`
    ),
      e.attr('style', `color: ${m.get('stroke') ?? f};`));
  }
  return (
    d.attr(
      'transform',
      `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${u ? -_ / 2 : _ / 2 - h.height})`
    ),
    E.attr('transform', `translate(0,${u ? h.height / 2 + x / 2 : -h.height / 2 - x / 2})`),
    Xm(t, D),
    (t.intersect = function (e) {
      if ((si.info('iconSquare intersect', t, e), !t.label)) return Sb.rect(t, e);
      const r = t.x ?? 0,
        n = t.y ?? 0,
        i = t.height ?? 0;
      let a = [];
      a = u
        ? [
            { x: r - h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 + h.height + x },
            { x: r + g / 2, y: n - i / 2 + h.height + x },
            { x: r + g / 2, y: n + i / 2 },
            { x: r - g / 2, y: n + i / 2 },
            { x: r - g / 2, y: n - i / 2 + h.height + x },
            { x: r - h.width / 2, y: n - i / 2 + h.height + x },
          ]
        : [
            { x: r - g / 2, y: n - i / 2 },
            { x: r + g / 2, y: n - i / 2 },
            { x: r + g / 2, y: n - i / 2 + p },
            { x: r + h.width / 2, y: n - i / 2 + p },
            { x: r + h.width / 2 / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n - i / 2 + p },
            { x: r - g / 2, y: n - i / 2 + p },
          ];
      return Sb.polygon(t, a, e);
    }),
    c
  );
}
async function ty(e, t, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Hh(t);
  t.labelStyle = i;
  const a = t.assetHeight ?? 48,
    o = t.assetWidth ?? 48,
    s = Math.max(a, o),
    l = null == n ? void 0 : n.wrappingWidth;
  t.width = Math.max(s, l ?? 0);
  const { shapeSvg: c, bbox: h, label: d } = await Km(e, t, 'icon-shape default'),
    u = t.label ? 8 : 0,
    p = 't' === t.pos,
    { nodeBorder: g, mainBkg: f } = r,
    { stylesMap: m } = qh(t),
    b = Zm(c),
    y = Gh(t, {});
  'handDrawn' !== t.look && ((y.roughness = 0), (y.fillStyle = 'solid'));
  const x = m.get('fill');
  y.stroke = x ?? f;
  const k = c.append('g');
  t.icon && k.html(`<g>${await Bf(t.icon, { height: s, width: s, fallbackPrefix: '' })}</g>`);
  const C = k.node().getBBox(),
    w = C.width,
    v = C.height,
    _ = C.x,
    S = C.y,
    E = Math.max(w, v) * Math.SQRT2 + 40,
    D = b.circle(0, 0, E, y),
    A = Math.max(E, h.width),
    T = E + h.height + u,
    F = b.rectangle(-A / 2, -T / 2, A, T, { ...y, fill: 'transparent', stroke: 'none' }),
    B = c.insert(() => D, ':first-child'),
    M = c.insert(() => F);
  return (
    k.attr(
      'transform',
      `translate(${-w / 2 - _},${p ? h.height / 2 + u / 2 - v / 2 - S : -h.height / 2 - u / 2 - v / 2 - S})`
    ),
    k.attr('style', `color: ${m.get('stroke') ?? g};`),
    d.attr(
      'transform',
      `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -T / 2 : T / 2 - h.height})`
    ),
    B.attr('transform', `translate(0,${p ? h.height / 2 + u / 2 : -h.height / 2 - u / 2})`),
    Xm(t, M),
    (t.intersect = function (e) {
      si.info('iconSquare intersect', t, e);
      return Sb.rect(t, e);
    }),
    c
  );
}
async function ry(e, t, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Hh(t);
  t.labelStyle = i;
  const a = t.assetHeight ?? 48,
    o = t.assetWidth ?? 48,
    s = Math.max(a, o),
    l = null == n ? void 0 : n.wrappingWidth;
  t.width = Math.max(s, l ?? 0);
  const { shapeSvg: c, bbox: h, halfPadding: d, label: u } = await Km(e, t, 'icon-shape default'),
    p = 't' === t.pos,
    g = s + 2 * d,
    f = s + 2 * d,
    { nodeBorder: m, mainBkg: b } = r,
    { stylesMap: y } = qh(t),
    x = -f / 2,
    k = -g / 2,
    C = t.label ? 8 : 0,
    w = Zm(c),
    v = Gh(t, {});
  'handDrawn' !== t.look && ((v.roughness = 0), (v.fillStyle = 'solid'));
  const _ = y.get('fill');
  v.stroke = _ ?? b;
  const S = w.path(ob(x, k, f, g, 5), v),
    E = Math.max(f, h.width),
    D = g + h.height + C,
    A = w.rectangle(-E / 2, -D / 2, E, D, { ...v, fill: 'transparent', stroke: 'none' }),
    T = c.insert(() => S, ':first-child').attr('class', 'icon-shape2'),
    F = c.insert(() => A);
  if (t.icon) {
    const e = c.append('g');
    e.html(`<g>${await Bf(t.icon, { height: s, width: s, fallbackPrefix: '' })}</g>`);
    const r = e.node().getBBox(),
      n = r.width,
      i = r.height,
      a = r.x,
      o = r.y;
    (e.attr(
      'transform',
      `translate(${-n / 2 - a},${p ? h.height / 2 + C / 2 - i / 2 - o : -h.height / 2 - C / 2 - i / 2 - o})`
    ),
      e.attr('style', `color: ${y.get('stroke') ?? m};`));
  }
  return (
    u.attr(
      'transform',
      `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -D / 2 : D / 2 - h.height})`
    ),
    T.attr('transform', `translate(0,${p ? h.height / 2 + C / 2 : -h.height / 2 - C / 2})`),
    Xm(t, F),
    (t.intersect = function (e) {
      if ((si.info('iconSquare intersect', t, e), !t.label)) return Sb.rect(t, e);
      const r = t.x ?? 0,
        n = t.y ?? 0,
        i = t.height ?? 0;
      let a = [];
      a = p
        ? [
            { x: r - h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 + h.height + C },
            { x: r + f / 2, y: n - i / 2 + h.height + C },
            { x: r + f / 2, y: n + i / 2 },
            { x: r - f / 2, y: n + i / 2 },
            { x: r - f / 2, y: n - i / 2 + h.height + C },
            { x: r - h.width / 2, y: n - i / 2 + h.height + C },
          ]
        : [
            { x: r - f / 2, y: n - i / 2 },
            { x: r + f / 2, y: n - i / 2 },
            { x: r + f / 2, y: n - i / 2 + g },
            { x: r + h.width / 2, y: n - i / 2 + g },
            { x: r + h.width / 2 / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n - i / 2 + g },
            { x: r - f / 2, y: n - i / 2 + g },
          ];
      return Sb.polygon(t, a, e);
    }),
    c
  );
}
async function ny(e, t, { config: { themeVariables: r, flowchart: n } }) {
  const { labelStyles: i } = Hh(t);
  t.labelStyle = i;
  const a = t.assetHeight ?? 48,
    o = t.assetWidth ?? 48,
    s = Math.max(a, o),
    l = null == n ? void 0 : n.wrappingWidth;
  t.width = Math.max(s, l ?? 0);
  const { shapeSvg: c, bbox: h, halfPadding: d, label: u } = await Km(e, t, 'icon-shape default'),
    p = 't' === t.pos,
    g = s + 2 * d,
    f = s + 2 * d,
    { nodeBorder: m, mainBkg: b } = r,
    { stylesMap: y } = qh(t),
    x = -f / 2,
    k = -g / 2,
    C = t.label ? 8 : 0,
    w = Zm(c),
    v = Gh(t, {});
  'handDrawn' !== t.look && ((v.roughness = 0), (v.fillStyle = 'solid'));
  const _ = y.get('fill');
  v.stroke = _ ?? b;
  const S = w.path(ob(x, k, f, g, 0.1), v),
    E = Math.max(f, h.width),
    D = g + h.height + C,
    A = w.rectangle(-E / 2, -D / 2, E, D, { ...v, fill: 'transparent', stroke: 'none' }),
    T = c.insert(() => S, ':first-child'),
    F = c.insert(() => A);
  if (t.icon) {
    const e = c.append('g');
    e.html(`<g>${await Bf(t.icon, { height: s, width: s, fallbackPrefix: '' })}</g>`);
    const r = e.node().getBBox(),
      n = r.width,
      i = r.height,
      a = r.x,
      o = r.y;
    (e.attr(
      'transform',
      `translate(${-n / 2 - a},${p ? h.height / 2 + C / 2 - i / 2 - o : -h.height / 2 - C / 2 - i / 2 - o})`
    ),
      e.attr('style', `color: ${y.get('stroke') ?? m};`));
  }
  return (
    u.attr(
      'transform',
      `translate(${-h.width / 2 - (h.x - (h.left ?? 0))},${p ? -D / 2 : D / 2 - h.height})`
    ),
    T.attr('transform', `translate(0,${p ? h.height / 2 + C / 2 : -h.height / 2 - C / 2})`),
    Xm(t, F),
    (t.intersect = function (e) {
      if ((si.info('iconSquare intersect', t, e), !t.label)) return Sb.rect(t, e);
      const r = t.x ?? 0,
        n = t.y ?? 0,
        i = t.height ?? 0;
      let a = [];
      a = p
        ? [
            { x: r - h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 },
            { x: r + h.width / 2, y: n - i / 2 + h.height + C },
            { x: r + f / 2, y: n - i / 2 + h.height + C },
            { x: r + f / 2, y: n + i / 2 },
            { x: r - f / 2, y: n + i / 2 },
            { x: r - f / 2, y: n - i / 2 + h.height + C },
            { x: r - h.width / 2, y: n - i / 2 + h.height + C },
          ]
        : [
            { x: r - f / 2, y: n - i / 2 },
            { x: r + f / 2, y: n - i / 2 },
            { x: r + f / 2, y: n - i / 2 + g },
            { x: r + h.width / 2, y: n - i / 2 + g },
            { x: r + h.width / 2 / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n + i / 2 },
            { x: r - h.width / 2, y: n - i / 2 + g },
            { x: r - f / 2, y: n - i / 2 + g },
          ];
      return Sb.polygon(t, a, e);
    }),
    c
  );
}
async function iy(e, t, { config: { flowchart: r } }) {
  const n = new Image();
  ((n.src = (null == t ? void 0 : t.img) ?? ''), await n.decode());
  const i = Number(n.naturalWidth.toString().replace('px', '')),
    a = Number(n.naturalHeight.toString().replace('px', ''));
  t.imageAspectRatio = i / a;
  const { labelStyles: o } = Hh(t);
  t.labelStyle = o;
  const s = null == r ? void 0 : r.wrappingWidth;
  t.defaultWidth = null == r ? void 0 : r.wrappingWidth;
  const l = Math.max(t.label ? (s ?? 0) : 0, (null == t ? void 0 : t.assetWidth) ?? i),
    c =
      'on' === t.constraint && (null == t ? void 0 : t.assetHeight)
        ? t.assetHeight * t.imageAspectRatio
        : l,
    h =
      'on' === t.constraint ? c / t.imageAspectRatio : ((null == t ? void 0 : t.assetHeight) ?? a);
  t.width = Math.max(c, s ?? 0);
  const { shapeSvg: d, bbox: u, label: p } = await Km(e, t, 'image-shape default'),
    g = 't' === t.pos,
    f = -c / 2,
    m = -h / 2,
    b = t.label ? 8 : 0,
    y = Zm(d),
    x = Gh(t, {});
  'handDrawn' !== t.look && ((x.roughness = 0), (x.fillStyle = 'solid'));
  const k = y.rectangle(f, m, c, h, x),
    C = Math.max(c, u.width),
    w = h + u.height + b,
    v = y.rectangle(-C / 2, -w / 2, C, w, { ...x, fill: 'none', stroke: 'none' }),
    _ = d.insert(() => k, ':first-child'),
    S = d.insert(() => v);
  if (t.img) {
    const e = d.append('image');
    (e.attr('href', t.img),
      e.attr('width', c),
      e.attr('height', h),
      e.attr('preserveAspectRatio', 'none'),
      e.attr('transform', `translate(${-c / 2},${g ? w / 2 - h : -w / 2})`));
  }
  return (
    p.attr(
      'transform',
      `translate(${-u.width / 2 - (u.x - (u.left ?? 0))},${g ? -h / 2 - u.height / 2 - b / 2 : h / 2 - u.height / 2 + b / 2})`
    ),
    _.attr('transform', `translate(0,${g ? u.height / 2 + b / 2 : -u.height / 2 - b / 2})`),
    Xm(t, S),
    (t.intersect = function (e) {
      if ((si.info('iconSquare intersect', t, e), !t.label)) return Sb.rect(t, e);
      const r = t.x ?? 0,
        n = t.y ?? 0,
        i = t.height ?? 0;
      let a = [];
      a = g
        ? [
            { x: r - u.width / 2, y: n - i / 2 },
            { x: r + u.width / 2, y: n - i / 2 },
            { x: r + u.width / 2, y: n - i / 2 + u.height + b },
            { x: r + c / 2, y: n - i / 2 + u.height + b },
            { x: r + c / 2, y: n + i / 2 },
            { x: r - c / 2, y: n + i / 2 },
            { x: r - c / 2, y: n - i / 2 + u.height + b },
            { x: r - u.width / 2, y: n - i / 2 + u.height + b },
          ]
        : [
            { x: r - c / 2, y: n - i / 2 },
            { x: r + c / 2, y: n - i / 2 },
            { x: r + c / 2, y: n - i / 2 + h },
            { x: r + u.width / 2, y: n - i / 2 + h },
            { x: r + u.width / 2 / 2, y: n + i / 2 },
            { x: r - u.width / 2, y: n + i / 2 },
            { x: r - u.width / 2, y: n - i / 2 + h },
            { x: r - c / 2, y: n - i / 2 + h },
          ];
      return Sb.polygon(t, a, e);
    }),
    d
  );
}
async function ay(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = [
      { x: 0, y: 0 },
      { x: o, y: 0 },
      { x: o + (3 * s) / 6, y: -s },
      { x: (-3 * s) / 6, y: -s },
    ];
  let c;
  const { cssStyles: h } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = Jm(l),
      a = e.path(n, r);
    ((c = i.insert(() => a, ':first-child').attr('transform', `translate(${-o / 2}, ${s / 2})`)),
      h && c.attr('style', h));
  } else c = Tb(i, o, s, l);
  return (
    n && c.attr('style', n),
    (t.width = o),
    (t.height = s),
    Xm(t, c),
    (t.intersect = function (e) {
      return Sb.polygon(t, l, e);
    }),
    i
  );
}
async function oy(e, t, r) {
  const { labelStyles: n, nodeStyles: i } = Hh(t);
  t.labelStyle = n;
  const { shapeSvg: a, bbox: o } = await Km(e, t, Qm(t)),
    s = Math.max(o.width + 2 * r.labelPaddingX, (null == t ? void 0 : t.width) || 0),
    l = Math.max(o.height + 2 * r.labelPaddingY, (null == t ? void 0 : t.height) || 0),
    c = -s / 2,
    h = -l / 2;
  let d,
    { rx: u, ry: p } = t;
  const { cssStyles: g } = t;
  if (((null == r ? void 0 : r.rx) && r.ry && ((u = r.rx), (p = r.ry)), 'handDrawn' === t.look)) {
    const e = Zm(a),
      r = Gh(t, {}),
      n = u || p ? e.path(ob(c, h, s, l, u || 0), r) : e.rectangle(c, h, s, l, r);
    ((d = a.insert(() => n, ':first-child')),
      d.attr('class', 'basic label-container').attr('style', Hp(g)));
  } else
    ((d = a.insert('rect', ':first-child')),
      d
        .attr('class', 'basic label-container')
        .attr('style', i)
        .attr('rx', Hp(u))
        .attr('ry', Hp(p))
        .attr('x', c)
        .attr('y', h)
        .attr('width', s)
        .attr('height', l));
  return (
    Xm(t, d),
    (t.calcIntersect = function (e, t) {
      return Sb.rect(e, t);
    }),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    a
  );
}
async function sy(e, t) {
  const { shapeSvg: r, bbox: n, label: i } = await Km(e, t, 'label'),
    a = r.insert('rect', ':first-child');
  return (
    a.attr('width', 0.1).attr('height', 0.1),
    r.attr('class', 'label edgeLabel'),
    i.attr(
      'transform',
      `translate(${-n.width / 2 - (n.x - (n.left ?? 0))}, ${-n.height / 2 - (n.y - (n.top ?? 0))})`
    ),
    Xm(t, a),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    r
  );
}
async function ly(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(a.height + (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = [
      { x: 0, y: 0 },
      { x: o + (3 * s) / 6, y: 0 },
      { x: o, y: -s },
      { x: (-3 * s) / 6, y: -s },
    ];
  let c;
  const { cssStyles: h } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = Jm(l),
      a = e.path(n, r);
    ((c = i.insert(() => a, ':first-child').attr('transform', `translate(${-o / 2}, ${s / 2})`)),
      h && c.attr('style', h));
  } else c = Tb(i, o, s, l);
  return (
    n && c.attr('style', n),
    (t.width = o),
    (t.height = s),
    Xm(t, c),
    (t.intersect = function (e) {
      return Sb.polygon(t, l, e);
    }),
    i
  );
}
async function cy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(a.height + (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = [
      { x: (-3 * s) / 6, y: 0 },
      { x: o, y: 0 },
      { x: o + (3 * s) / 6, y: -s },
      { x: 0, y: -s },
    ];
  let c;
  const { cssStyles: h } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = Jm(l),
      a = e.path(n, r);
    ((c = i.insert(() => a, ':first-child').attr('transform', `translate(${-o / 2}, ${s / 2})`)),
      h && c.attr('style', h));
  } else c = Tb(i, o, s, l);
  return (
    n && c.attr('style', n),
    (t.width = o),
    (t.height = s),
    Xm(t, c),
    (t.intersect = function (e) {
      return Sb.polygon(t, l, e);
    }),
    i
  );
}
function hy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  ((t.label = ''), (t.labelStyle = r));
  const i = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId ?? t.id),
    { cssStyles: a } = t,
    o = Math.max(35, (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(35, (null == t ? void 0 : t.height) ?? 0),
    l = [
      { x: o, y: 0 },
      { x: 0, y: s + 3.5 },
      { x: o - 14, y: s + 3.5 },
      { x: 0, y: 2 * s },
      { x: o, y: s - 3.5 },
      { x: 14, y: s - 3.5 },
    ],
    c = Zm(i),
    h = Gh(t, {});
  'handDrawn' !== t.look && ((h.roughness = 0), (h.fillStyle = 'solid'));
  const d = Jm(l),
    u = c.path(d, h),
    p = i.insert(() => u, ':first-child');
  return (
    a && 'handDrawn' !== t.look && p.selectAll('path').attr('style', a),
    n && 'handDrawn' !== t.look && p.selectAll('path').attr('style', n),
    p.attr('transform', `translate(-${o / 2},${-s})`),
    Xm(t, p),
    (t.intersect = function (e) {
      si.info('lightningBolt intersect', t, e);
      return Sb.polygon(t, l, e);
    }),
    i
  );
}
(ii(Hb, 'cylinder'),
  ii(Gb, 'dividedRectangle'),
  ii(Vb, 'doublecircle'),
  ii(Zb, 'filledCircle'),
  ii(Kb, 'flippedTriangle'),
  ii(Yb, 'forkJoin'),
  ii(Xb, 'halfRoundedRectangle'),
  ii(Qb, 'hexagon'),
  ii(Jb, 'hourglass'),
  ii(ey, 'icon'),
  ii(ty, 'iconCircle'),
  ii(ry, 'iconRounded'),
  ii(ny, 'iconSquare'),
  ii(iy, 'imageSquare'),
  ii(ay, 'inv_trapezoid'),
  ii(oy, 'drawRect'),
  ii(sy, 'labelRect'),
  ii(ly, 'lean_left'),
  ii(cy, 'lean_right'),
  ii(hy, 'lightningBolt'));
var dy = ii(
    (e, t, r, n, i, a, o) =>
      [
        `M${e},${t + a}`,
        `a${i},${a} 0,0,0 ${r},0`,
        `a${i},${a} 0,0,0 ${-r},0`,
        `l0,${n}`,
        `a${i},${a} 0,0,0 ${r},0`,
        'l0,' + -n,
        `M${e},${t + a + o}`,
        `a${i},${a} 0,0,0 ${r},0`,
      ].join(' '),
    'createCylinderPathD'
  ),
  uy = ii(
    (e, t, r, n, i, a, o) =>
      [
        `M${e},${t + a}`,
        `M${e + r},${t + a}`,
        `a${i},${a} 0,0,0 ${-r},0`,
        `l0,${n}`,
        `a${i},${a} 0,0,0 ${r},0`,
        'l0,' + -n,
        `M${e},${t + a + o}`,
        `a${i},${a} 0,0,0 ${r},0`,
      ].join(' '),
    'createOuterCylinderPathD'
  ),
  py = ii(
    (e, t, r, n, i, a) => [`M${e - r / 2},${-n / 2}`, `a${i},${a} 0,0,0 ${r},0`].join(' '),
    'createInnerCylinderPathD'
  );
async function gy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + (t.padding ?? 0), t.width ?? 0),
    l = s / 2,
    c = l / (2.5 + s / 50),
    h = Math.max(a.height + c + (t.padding ?? 0), t.height ?? 0),
    d = 0.1 * h;
  let u;
  const { cssStyles: p } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = uy(0, 0, s, h, l, c, d),
      n = py(0, c, s, h, l, c),
      a = Gh(t, {}),
      o = e.path(r, a),
      g = e.path(n, a);
    (i.insert(() => g, ':first-child').attr('class', 'line'),
      (u = i.insert(() => o, ':first-child')),
      u.attr('class', 'basic label-container'),
      p && u.attr('style', p));
  } else {
    const e = dy(0, 0, s, h, l, c, d);
    u = i
      .insert('path', ':first-child')
      .attr('d', e)
      .attr('class', 'basic label-container')
      .attr('style', Hp(p))
      .attr('style', n);
  }
  return (
    u.attr('label-offset-y', c),
    u.attr('transform', `translate(${-s / 2}, ${-(h / 2 + c)})`),
    Xm(t, u),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - (a.x - (a.left ?? 0))}, ${-a.height / 2 + c - (a.y - (a.top ?? 0))})`
    ),
    (t.intersect = function (e) {
      const r = Sb.rect(t, e),
        n = r.x - (t.x ?? 0);
      if (
        0 != l &&
        (Math.abs(n) < (t.width ?? 0) / 2 ||
          (Math.abs(n) == (t.width ?? 0) / 2 &&
            Math.abs(r.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - c))
      ) {
        let i = c * c * (1 - (n * n) / (l * l));
        (i > 0 && (i = Math.sqrt(i)), (i = c - i), e.y - (t.y ?? 0) > 0 && (i = -i), (r.y += i));
      }
      return r;
    }),
    i
  );
}
async function fy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = l / 4,
    h = l + c,
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {});
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = [
      { x: -s / 2 - (s / 2) * 0.1, y: -h / 2 },
      { x: -s / 2 - (s / 2) * 0.1, y: h / 2 },
      ...eb(-s / 2 - (s / 2) * 0.1, h / 2, s / 2 + (s / 2) * 0.1, h / 2, c, 0.8),
      { x: s / 2 + (s / 2) * 0.1, y: -h / 2 },
      { x: -s / 2 - (s / 2) * 0.1, y: -h / 2 },
      { x: -s / 2, y: -h / 2 },
      { x: -s / 2, y: (h / 2) * 1.1 },
      { x: -s / 2, y: -h / 2 },
    ],
    f = u.polygon(
      g.map((e) => [e.x, e.y]),
      p
    ),
    m = i.insert(() => f, ':first-child');
  return (
    m.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && m.selectAll('path').attr('style', d),
    n && 'handDrawn' !== t.look && m.selectAll('path').attr('style', n),
    m.attr('transform', `translate(0,${-c / 2})`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) + ((s / 2) * 0.1) / 2 - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - c / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, m),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
async function my(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = -s / 2,
    h = -l / 2,
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {}),
    g = [
      { x: c - 5, y: h + 5 },
      { x: c - 5, y: h + l + 5 },
      { x: c + s - 5, y: h + l + 5 },
      { x: c + s - 5, y: h + l },
      { x: c + s, y: h + l },
      { x: c + s, y: h + l - 5 },
      { x: c + s + 5, y: h + l - 5 },
      { x: c + s + 5, y: h - 5 },
      { x: c + 5, y: h - 5 },
      { x: c + 5, y: h },
      { x: c, y: h },
      { x: c, y: h + 5 },
    ],
    f = [
      { x: c, y: h + 5 },
      { x: c + s - 5, y: h + 5 },
      { x: c + s - 5, y: h + l },
      { x: c + s, y: h + l },
      { x: c + s, y: h },
      { x: c, y: h },
    ];
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const m = Jm(g),
    b = u.path(m, p),
    y = Jm(f),
    x = u.path(y, { ...p, fill: 'none' }),
    k = i.insert(() => x, ':first-child');
  return (
    k.insert(() => b, ':first-child'),
    k.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && k.selectAll('path').attr('style', d),
    n && 'handDrawn' !== t.look && k.selectAll('path').attr('style', n),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - 5 - (a.x - (a.left ?? 0))}, ${-a.height / 2 + 5 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, k),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
async function by(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = l / 4,
    h = l + c,
    d = -s / 2,
    u = -h / 2,
    { cssStyles: p } = t,
    g = eb(d - 5, u + h + 5, d + s - 5, u + h + 5, c, 0.8),
    f = null == g ? void 0 : g[g.length - 1],
    m = [
      { x: d - 5, y: u + 5 },
      { x: d - 5, y: u + h + 5 },
      ...g,
      { x: d + s - 5, y: f.y - 5 },
      { x: d + s, y: f.y - 5 },
      { x: d + s, y: f.y - 10 },
      { x: d + s + 5, y: f.y - 10 },
      { x: d + s + 5, y: u - 5 },
      { x: d + 5, y: u - 5 },
      { x: d + 5, y: u },
      { x: d, y: u },
      { x: d, y: u + 5 },
    ],
    b = [
      { x: d, y: u + 5 },
      { x: d + s - 5, y: u + 5 },
      { x: d + s - 5, y: f.y - 5 },
      { x: d + s, y: f.y - 5 },
      { x: d + s, y: u },
      { x: d, y: u },
    ],
    y = Zm(i),
    x = Gh(t, {});
  'handDrawn' !== t.look && ((x.roughness = 0), (x.fillStyle = 'solid'));
  const k = Jm(m),
    C = y.path(k, x),
    w = Jm(b),
    v = y.path(w, x),
    _ = i.insert(() => C, ':first-child');
  return (
    _.insert(() => v),
    _.attr('class', 'basic label-container'),
    p && 'handDrawn' !== t.look && _.selectAll('path').attr('style', p),
    n && 'handDrawn' !== t.look && _.selectAll('path').attr('style', n),
    _.attr('transform', `translate(0,${-c / 2})`),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - 5 - (a.x - (a.left ?? 0))}, ${-a.height / 2 + 5 - c / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, _),
    (t.intersect = function (e) {
      return Sb.polygon(t, m, e);
    }),
    i
  );
}
async function yy(e, t, { config: { themeVariables: r } }) {
  var n;
  const { labelStyles: i, nodeStyles: a } = Hh(t);
  t.labelStyle = i;
  t.useHtmlLabels ||
    !1 !== (null == (n = _o().flowchart) ? void 0 : n.htmlLabels) ||
    (t.centerLabel = !0);
  const { shapeSvg: o, bbox: s, label: l } = await Km(e, t, Qm(t)),
    c = Math.max(s.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    h = Math.max(s.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    d = -c / 2,
    u = -h / 2,
    { cssStyles: p } = t,
    g = Zm(o),
    f = Gh(t, { fill: r.noteBkgColor, stroke: r.noteBorderColor });
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = g.rectangle(d, u, c, h, f),
    b = o.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container'),
    p && 'handDrawn' !== t.look && b.selectAll('path').attr('style', p),
    a && 'handDrawn' !== t.look && b.selectAll('path').attr('style', a),
    l.attr(
      'transform',
      `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-s.height / 2 - (s.y - (s.top ?? 0))})`
    ),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    o
  );
}
(ii(gy, 'linedCylinder'),
  ii(fy, 'linedWaveEdgedRect'),
  ii(my, 'multiRect'),
  ii(by, 'multiWaveEdgedRectangle'),
  ii(yy, 'note'));
var xy = ii(
  (e, t, r) =>
    [
      `M${e + r / 2},${t}`,
      `L${e + r},${t - r / 2}`,
      `L${e + r / 2},${t - r}`,
      `L${e},${t - r / 2}`,
      'Z',
    ].join(' '),
  'createDecisionBoxPathD'
);
async function ky(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.width + t.padding + (a.height + t.padding),
    s = [
      { x: o / 2, y: 0 },
      { x: o, y: -o / 2 },
      { x: o / 2, y: -o },
      { x: 0, y: -o / 2 },
    ];
  let l;
  const { cssStyles: c } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = xy(0, 0, o),
      a = e.path(n, r);
    ((l = i
      .insert(() => a, ':first-child')
      .attr('transform', `translate(${-o / 2 + 0.5}, ${o / 2})`)),
      c && l.attr('style', c));
  } else ((l = Tb(i, o, o, s)), l.attr('transform', `translate(${-o / 2 + 0.5}, ${o / 2})`));
  return (
    n && l.attr('style', n),
    Xm(t, l),
    (t.calcIntersect = function (e, t) {
      const r = e.width,
        n = [
          { x: r / 2, y: 0 },
          { x: r, y: -r / 2 },
          { x: r / 2, y: -r },
          { x: 0, y: -r / 2 },
        ],
        i = Sb.polygon(e, n, t);
      return { x: i.x - 0.5, y: i.y - 0.5 };
    }),
    (t.intersect = function (e) {
      return this.calcIntersect(t, e);
    }),
    i
  );
}
async function Cy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = -Math.max(a.width + (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0) / 2,
    l = -Math.max(a.height + (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0) / 2,
    c = l / 2,
    h = [
      { x: s + c, y: l },
      { x: s, y: 0 },
      { x: s + c, y: -l },
      { x: -s, y: -l },
      { x: -s, y: l },
    ],
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {});
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = Jm(h),
    f = u.path(g, p),
    m = i.insert(() => f, ':first-child');
  return (
    m.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && m.selectAll('path').attr('style', d),
    n && 'handDrawn' !== t.look && m.selectAll('path').attr('style', n),
    m.attr('transform', `translate(${-c / 2},0)`),
    o.attr(
      'transform',
      `translate(${-c / 2 - a.width / 2 - (a.x - (a.left ?? 0))}, ${-a.height / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, m),
    (t.intersect = function (e) {
      return Sb.polygon(t, h, e);
    }),
    i
  );
}
async function wy(e, t) {
  var r, n;
  const { labelStyles: i, nodeStyles: a } = Hh(t);
  let o;
  ((t.labelStyle = i), (o = t.cssClasses ? 'node ' + t.cssClasses : 'node default'));
  const s = e
      .insert('g')
      .attr('class', o)
      .attr('id', t.domId || t.id),
    l = s.insert('g'),
    c = s.insert('g').attr('class', 'label').attr('style', a),
    h = t.description,
    d = t.label,
    u = c.node().appendChild(await ab(d, t.labelStyle, !0, !0));
  let p = { width: 0, height: 0 };
  if (Go(null == (n = null == (r = As()) ? void 0 : r.flowchart) ? void 0 : n.htmlLabels)) {
    const e = u.children[0],
      t = S(u);
    ((p = e.getBoundingClientRect()), t.attr('width', p.width), t.attr('height', p.height));
  }
  si.info('Text 2', h);
  const g = h || [],
    f = u.getBBox(),
    m = c.node().appendChild(await ab(g.join ? g.join('<br/>') : g, t.labelStyle, !0, !0)),
    b = m.children[0],
    y = S(m);
  ((p = b.getBoundingClientRect()), y.attr('width', p.width), y.attr('height', p.height));
  const x = (t.padding || 0) / 2;
  (S(m).attr(
    'transform',
    'translate( ' +
      (p.width > f.width ? 0 : (f.width - p.width) / 2) +
      ', ' +
      (f.height + x + 5) +
      ')'
  ),
    S(u).attr(
      'transform',
      'translate( ' + (p.width < f.width ? 0 : -(f.width - p.width) / 2) + ', 0)'
    ),
    (p = c.node().getBBox()),
    c.attr('transform', 'translate(' + -p.width / 2 + ', ' + (-p.height / 2 - x + 3) + ')'));
  const k = p.width + (t.padding || 0),
    C = p.height + (t.padding || 0),
    w = -p.width / 2 - x,
    v = -p.height / 2 - x;
  let _, E;
  if ('handDrawn' === t.look) {
    const e = Zm(s),
      r = Gh(t, {}),
      n = e.path(ob(w, v, k, C, t.rx || 0), r),
      i = e.line(
        -p.width / 2 - x,
        -p.height / 2 - x + f.height + x,
        p.width / 2 + x,
        -p.height / 2 - x + f.height + x,
        r
      );
    ((E = s.insert(() => (si.debug('Rough node insert CXC', n), i), ':first-child')),
      (_ = s.insert(() => (si.debug('Rough node insert CXC', n), n), ':first-child')));
  } else
    ((_ = l.insert('rect', ':first-child')),
      (E = l.insert('line')),
      _.attr('class', 'outer title-state')
        .attr('style', a)
        .attr('x', -p.width / 2 - x)
        .attr('y', -p.height / 2 - x)
        .attr('width', p.width + (t.padding || 0))
        .attr('height', p.height + (t.padding || 0)),
      E.attr('class', 'divider')
        .attr('x1', -p.width / 2 - x)
        .attr('x2', p.width / 2 + x)
        .attr('y1', -p.height / 2 - x + f.height + x)
        .attr('y2', -p.height / 2 - x + f.height + x));
  return (
    Xm(t, _),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    s
  );
}
function vy(e, t, r, n, i, a, o) {
  const s = (e + r) / 2,
    l = (t + n) / 2,
    c = Math.atan2(n - t, r - e),
    h = (r - e) / 2 / i,
    d = (n - t) / 2 / a,
    u = Math.sqrt(h ** 2 + d ** 2);
  if (u > 1) throw new Error('The given radii are too small to create an arc between the points.');
  const p = Math.sqrt(1 - u ** 2),
    g = s + p * a * Math.sin(c) * (o ? -1 : 1),
    f = l - p * i * Math.cos(c) * (o ? -1 : 1),
    m = Math.atan2((t - f) / a, (e - g) / i);
  let b = Math.atan2((n - f) / a, (r - g) / i) - m;
  (o && b < 0 && (b += 2 * Math.PI), !o && b > 0 && (b -= 2 * Math.PI));
  const y = [];
  for (let x = 0; x < 20; x++) {
    const e = m + (x / 19) * b,
      t = g + i * Math.cos(e),
      r = f + a * Math.sin(e);
    y.push({ x: t, y: r });
  }
  return y;
}
async function _y(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = (null == t ? void 0 : t.padding) ?? 0,
    s = (null == t ? void 0 : t.padding) ?? 0,
    l = ((null == t ? void 0 : t.width) ? (null == t ? void 0 : t.width) : a.width) + 2 * o,
    c = ((null == t ? void 0 : t.height) ? (null == t ? void 0 : t.height) : a.height) + 2 * s,
    h = t.radius || 5,
    d = t.taper || 5,
    { cssStyles: u } = t,
    p = Zm(i),
    g = Gh(t, {});
  (t.stroke && (g.stroke = t.stroke),
    'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid')));
  const f = [
      { x: -l / 2 + d, y: -c / 2 },
      { x: l / 2 - d, y: -c / 2 },
      ...vy(l / 2 - d, -c / 2, l / 2, -c / 2 + d, h, h, !0),
      { x: l / 2, y: -c / 2 + d },
      { x: l / 2, y: c / 2 - d },
      ...vy(l / 2, c / 2 - d, l / 2 - d, c / 2, h, h, !0),
      { x: l / 2 - d, y: c / 2 },
      { x: -l / 2 + d, y: c / 2 },
      ...vy(-l / 2 + d, c / 2, -l / 2, c / 2 - d, h, h, !0),
      { x: -l / 2, y: c / 2 - d },
      { x: -l / 2, y: -c / 2 + d },
      ...vy(-l / 2, -c / 2 + d, -l / 2 + d, -c / 2, h, h, !0),
    ],
    m = Jm(f),
    b = p.path(m, g),
    y = i.insert(() => b, ':first-child');
  return (
    y.attr('class', 'basic label-container outer-path'),
    u && 'handDrawn' !== t.look && y.selectChildren('path').attr('style', u),
    n && 'handDrawn' !== t.look && y.selectChildren('path').attr('style', n),
    Xm(t, y),
    (t.intersect = function (e) {
      return Sb.polygon(t, f, e);
    }),
    i
  );
}
async function Sy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = (null == t ? void 0 : t.padding) ?? 0,
    l = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    c = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    h = -a.width / 2 - s,
    d = -a.height / 2 - s,
    { cssStyles: u } = t,
    p = Zm(i),
    g = Gh(t, {});
  'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid'));
  const f = [
      { x: h, y: d },
      { x: h + l + 8, y: d },
      { x: h + l + 8, y: d + c },
      { x: h - 8, y: d + c },
      { x: h - 8, y: d },
      { x: h, y: d },
      { x: h, y: d + c },
    ],
    m = p.polygon(
      f.map((e) => [e.x, e.y]),
      g
    ),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container').attr('style', Hp(u)),
    n && 'handDrawn' !== t.look && b.selectAll('path').attr('style', n),
    u && 'handDrawn' !== t.look && b.selectAll('path').attr('style', n),
    o.attr(
      'transform',
      `translate(${-l / 2 + 4 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-c / 2 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    i
  );
}
async function Ey(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = -s / 2,
    h = -l / 2,
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {});
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const g = [
      { x: c, y: h },
      { x: c, y: h + l },
      { x: c + s, y: h + l },
      { x: c + s, y: h - l / 2 },
    ],
    f = Jm(g),
    m = u.path(f, p),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', d),
    n && 'handDrawn' !== t.look && b.selectChildren('path').attr('style', n),
    b.attr('transform', `translate(0, ${l / 4})`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))}, ${-l / 4 + (t.padding ?? 0) - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
async function Dy(e, t) {
  return oy(e, t, {
    rx: 0,
    ry: 0,
    labelPaddingX: t.labelPaddingX ?? 2 * ((null == t ? void 0 : t.padding) || 0),
    labelPaddingY: 1 * ((null == t ? void 0 : t.padding) || 0),
  });
}
async function Ay(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.height + t.padding,
    s = a.width + o / 4 + t.padding,
    l = o / 2,
    { cssStyles: c } = t,
    h = Zm(i),
    d = Gh(t, {});
  'handDrawn' !== t.look && ((d.roughness = 0), (d.fillStyle = 'solid'));
  const u = [
      { x: -s / 2 + l, y: -o / 2 },
      { x: s / 2 - l, y: -o / 2 },
      ...tb(-s / 2 + l, 0, l, 50, 90, 270),
      { x: s / 2 - l, y: o / 2 },
      ...tb(s / 2 - l, 0, l, 50, 270, 450),
    ],
    p = Jm(u),
    g = h.path(p, d),
    f = i.insert(() => g, ':first-child');
  return (
    f.attr('class', 'basic label-container outer-path'),
    c && 'handDrawn' !== t.look && f.selectChildren('path').attr('style', c),
    n && 'handDrawn' !== t.look && f.selectChildren('path').attr('style', n),
    Xm(t, f),
    (t.intersect = function (e) {
      return Sb.polygon(t, u, e);
    }),
    i
  );
}
async function Ty(e, t) {
  return oy(e, t, { rx: 5, ry: 5 });
}
function Fy(e, t, { config: { themeVariables: r } }) {
  const { labelStyles: n, nodeStyles: i } = Hh(t);
  t.labelStyle = n;
  const { cssStyles: a } = t,
    { lineColor: o, stateBorder: s, nodeBorder: l } = r,
    c = e
      .insert('g')
      .attr('class', 'node default')
      .attr('id', t.domId || t.id),
    h = Zm(c),
    d = Gh(t, {});
  'handDrawn' !== t.look && ((d.roughness = 0), (d.fillStyle = 'solid'));
  const u = h.circle(0, 0, 14, { ...d, stroke: o, strokeWidth: 2 }),
    p = s ?? l,
    g = h.circle(0, 0, 5, { ...d, fill: p, stroke: p, strokeWidth: 2, fillStyle: 'solid' }),
    f = c.insert(() => u, ':first-child');
  return (
    f.insert(() => g),
    a && f.selectAll('path').attr('style', a),
    i && f.selectAll('path').attr('style', i),
    Xm(t, f),
    (t.intersect = function (e) {
      return Sb.circle(t, 7, e);
    }),
    c
  );
}
function By(e, t, { config: { themeVariables: r } }) {
  const { lineColor: n } = r,
    i = e
      .insert('g')
      .attr('class', 'node default')
      .attr('id', t.domId || t.id);
  let a;
  if ('handDrawn' === t.look) {
    const e = Zm(i).circle(0, 0, 14, jh(n));
    ((a = i.insert(() => e)),
      a.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14));
  } else
    ((a = i.insert('circle', ':first-child')),
      a.attr('class', 'state-start').attr('r', 7).attr('width', 14).attr('height', 14));
  return (
    Xm(t, a),
    (t.intersect = function (e) {
      return Sb.circle(t, 7, e);
    }),
    i
  );
}
async function My(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = ((null == t ? void 0 : t.padding) || 0) / 2,
    s = a.width + t.padding,
    l = a.height + t.padding,
    c = -a.width / 2 - o,
    h = -a.height / 2 - o,
    d = [
      { x: 0, y: 0 },
      { x: s, y: 0 },
      { x: s, y: -l },
      { x: 0, y: -l },
      { x: 0, y: 0 },
      { x: -8, y: 0 },
      { x: s + 8, y: 0 },
      { x: s + 8, y: -l },
      { x: -8, y: -l },
      { x: -8, y: 0 },
    ];
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = e.rectangle(c - 8, h, s + 16, l, r),
      a = e.line(c, h, c, h + l, r),
      o = e.line(c + s, h, c + s, h + l, r);
    (i.insert(() => a, ':first-child'), i.insert(() => o, ':first-child'));
    const d = i.insert(() => n, ':first-child'),
      { cssStyles: u } = t;
    (d.attr('class', 'basic label-container').attr('style', Hp(u)), Xm(t, d));
  } else {
    const e = Tb(i, s, l, d);
    (n && e.attr('style', n), Xm(t, e));
  }
  return (
    (t.intersect = function (e) {
      return Sb.polygon(t, d, e);
    }),
    i
  );
}
async function Ny(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = -o / 2,
    c = -s / 2,
    h = 0.2 * s,
    d = 0.2 * s,
    { cssStyles: u } = t,
    p = Zm(i),
    g = Gh(t, {}),
    f = [
      { x: l - h / 2, y: c },
      { x: l + o + h / 2, y: c },
      { x: l + o + h / 2, y: c + s },
      { x: l - h / 2, y: c + s },
    ],
    m = [
      { x: l + o - h / 2, y: c + s },
      { x: l + o + h / 2, y: c + s },
      { x: l + o + h / 2, y: c + s - d },
    ];
  'handDrawn' !== t.look && ((g.roughness = 0), (g.fillStyle = 'solid'));
  const b = Jm(f),
    y = p.path(b, g),
    x = Jm(m),
    k = p.path(x, { ...g, fillStyle: 'solid' }),
    C = i.insert(() => k, ':first-child');
  return (
    C.insert(() => y, ':first-child'),
    C.attr('class', 'basic label-container'),
    u && 'handDrawn' !== t.look && C.selectAll('path').attr('style', u),
    n && 'handDrawn' !== t.look && C.selectAll('path').attr('style', n),
    Xm(t, C),
    (t.intersect = function (e) {
      return Sb.polygon(t, f, e);
    }),
    i
  );
}
async function Ly(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = l / 4,
    h = 0.2 * s,
    d = 0.2 * l,
    u = l + c,
    { cssStyles: p } = t,
    g = Zm(i),
    f = Gh(t, {});
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = [
      { x: -s / 2 - (s / 2) * 0.1, y: u / 2 },
      ...eb(-s / 2 - (s / 2) * 0.1, u / 2, s / 2 + (s / 2) * 0.1, u / 2, c, 0.8),
      { x: s / 2 + (s / 2) * 0.1, y: -u / 2 },
      { x: -s / 2 - (s / 2) * 0.1, y: -u / 2 },
    ],
    b = -s / 2 + (s / 2) * 0.1,
    y = -u / 2 - 0.4 * d,
    x = [
      { x: b + s - h, y: 1.4 * (y + l) },
      { x: b + s, y: y + l - d },
      { x: b + s, y: 0.9 * (y + l) },
      ...eb(b + s, 1.3 * (y + l), b + s - h, 1.5 * (y + l), 0.03 * -l, 0.5),
    ],
    k = Jm(m),
    C = g.path(k, f),
    w = Jm(x),
    v = g.path(w, { ...f, fillStyle: 'solid' }),
    _ = i.insert(() => v, ':first-child');
  return (
    _.insert(() => C, ':first-child'),
    _.attr('class', 'basic label-container'),
    p && 'handDrawn' !== t.look && _.selectAll('path').attr('style', p),
    n && 'handDrawn' !== t.look && _.selectAll('path').attr('style', n),
    _.attr('transform', `translate(0,${-c / 2})`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - c / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, _),
    (t.intersect = function (e) {
      return Sb.polygon(t, m, e);
    }),
    i
  );
}
async function Oy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + t.padding, (null == t ? void 0 : t.width) || 0),
    s = Math.max(a.height + t.padding, (null == t ? void 0 : t.height) || 0),
    l = -o / 2,
    c = -s / 2,
    h = i.insert('rect', ':first-child');
  return (
    h
      .attr('class', 'text')
      .attr('style', n)
      .attr('rx', 0)
      .attr('ry', 0)
      .attr('x', l)
      .attr('y', c)
      .attr('width', o)
      .attr('height', s),
    Xm(t, h),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    i
  );
}
(ii(ky, 'question'),
  ii(Cy, 'rect_left_inv_arrow'),
  ii(wy, 'rectWithTitle'),
  ii(vy, 'generateArcPoints'),
  ii(_y, 'roundedRect'),
  ii(Sy, 'shadedProcess'),
  ii(Ey, 'slopedRect'),
  ii(Dy, 'squareRect'),
  ii(Ay, 'stadium'),
  ii(Ty, 'state'),
  ii(Fy, 'stateEnd'),
  ii(By, 'stateStart'),
  ii(My, 'subroutine'),
  ii(Ny, 'taggedRect'),
  ii(Ly, 'taggedWaveEdgedRectangle'),
  ii(Oy, 'text'));
var $y = ii(
    (e, t, r, n, i, a) =>
      `M${e},${t}\n    a${i},${a} 0,0,1 0,${-n}\n    l${r},0\n    a${i},${a} 0,0,1 0,${n}\n    M${r},${-n}\n    a${i},${a} 0,0,0 0,${n}\n    l${-r},0`,
    'createCylinderPathD'
  ),
  Iy = ii(
    (e, t, r, n, i, a) =>
      [
        `M${e},${t}`,
        `M${e + r},${t}`,
        `a${i},${a} 0,0,0 0,${-n}`,
        `l${-r},0`,
        `a${i},${a} 0,0,0 0,${n}`,
        `l${r},0`,
      ].join(' '),
    'createOuterCylinderPathD'
  ),
  Ry = ii(
    (e, t, r, n, i, a) => [`M${e + r / 2},${-n / 2}`, `a${i},${a} 0,0,0 0,${n}`].join(' '),
    'createInnerCylinderPathD'
  );
async function zy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o, halfPadding: s } = await Km(e, t, Qm(t)),
    l = 'neo' === t.look ? 2 * s : s,
    c = a.height + l,
    h = c / 2,
    d = h / (2.5 + c / 50),
    u = a.width + d + l,
    { cssStyles: p } = t;
  let g;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Iy(0, 0, u, c, d, h),
      n = Ry(0, 0, u, c, d, h),
      a = e.path(r, Gh(t, {})),
      o = e.path(n, Gh(t, { fill: 'none' }));
    ((g = i.insert(() => o, ':first-child')),
      (g = i.insert(() => a, ':first-child')),
      g.attr('class', 'basic label-container'),
      p && g.attr('style', p));
  } else {
    const e = $y(0, 0, u, c, d, h);
    ((g = i
      .insert('path', ':first-child')
      .attr('d', e)
      .attr('class', 'basic label-container')
      .attr('style', Hp(p))
      .attr('style', n)),
      g.attr('class', 'basic label-container'),
      p && g.selectAll('path').attr('style', p),
      n && g.selectAll('path').attr('style', n));
  }
  return (
    g.attr('label-offset-x', d),
    g.attr('transform', `translate(${-u / 2}, ${c / 2} )`),
    o.attr(
      'transform',
      `translate(${-a.width / 2 - d - (a.x - (a.left ?? 0))}, ${-a.height / 2 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, g),
    (t.intersect = function (e) {
      const r = Sb.rect(t, e),
        n = r.y - (t.y ?? 0);
      if (
        0 != h &&
        (Math.abs(n) < (t.height ?? 0) / 2 ||
          (Math.abs(n) == (t.height ?? 0) / 2 &&
            Math.abs(r.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - d))
      ) {
        let i = d * d * (1 - (n * n) / (h * h));
        (0 != i && (i = Math.sqrt(Math.abs(i))),
          (i = d - i),
          e.x - (t.x ?? 0) > 0 && (i = -i),
          (r.x += i));
      }
      return r;
    }),
    i
  );
}
async function Py(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = a.width + t.padding,
    s = a.height + t.padding,
    l = [
      { x: (-3 * s) / 6, y: 0 },
      { x: o + (3 * s) / 6, y: 0 },
      { x: o, y: -s },
      { x: 0, y: -s },
    ];
  let c;
  const { cssStyles: h } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = Jm(l),
      a = e.path(n, r);
    ((c = i.insert(() => a, ':first-child').attr('transform', `translate(${-o / 2}, ${s / 2})`)),
      h && c.attr('style', h));
  } else c = Tb(i, o, s, l);
  return (
    n && c.attr('style', n),
    (t.width = o),
    (t.height = s),
    Xm(t, c),
    (t.intersect = function (e) {
      return Sb.polygon(t, l, e);
    }),
    i
  );
}
async function jy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(60, a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(20, a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    { cssStyles: l } = t,
    c = Zm(i),
    h = Gh(t, {});
  'handDrawn' !== t.look && ((h.roughness = 0), (h.fillStyle = 'solid'));
  const d = [
      { x: (-o / 2) * 0.8, y: -s / 2 },
      { x: (o / 2) * 0.8, y: -s / 2 },
      { x: o / 2, y: (-s / 2) * 0.6 },
      { x: o / 2, y: s / 2 },
      { x: -o / 2, y: s / 2 },
      { x: -o / 2, y: (-s / 2) * 0.6 },
    ],
    u = Jm(d),
    p = c.path(u, h),
    g = i.insert(() => p, ':first-child');
  return (
    g.attr('class', 'basic label-container'),
    l && 'handDrawn' !== t.look && g.selectChildren('path').attr('style', l),
    n && 'handDrawn' !== t.look && g.selectChildren('path').attr('style', n),
    Xm(t, g),
    (t.intersect = function (e) {
      return Sb.polygon(t, d, e);
    }),
    i
  );
}
async function qy(e, t) {
  var r;
  const { labelStyles: n, nodeStyles: i } = Hh(t);
  t.labelStyle = n;
  const { shapeSvg: a, bbox: o, label: s } = await Km(e, t, Qm(t)),
    l = Go(null == (r = As().flowchart) ? void 0 : r.htmlLabels),
    c = o.width + (t.padding ?? 0),
    h = c + o.height,
    d = c + o.height,
    u = [
      { x: 0, y: 0 },
      { x: d, y: 0 },
      { x: d / 2, y: -h },
    ],
    { cssStyles: p } = t,
    g = Zm(a),
    f = Gh(t, {});
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = Jm(u),
    b = g.path(m, f),
    y = a.insert(() => b, ':first-child').attr('transform', `translate(${-h / 2}, ${h / 2})`);
  return (
    p && 'handDrawn' !== t.look && y.selectChildren('path').attr('style', p),
    i && 'handDrawn' !== t.look && y.selectChildren('path').attr('style', i),
    (t.width = c),
    (t.height = h),
    Xm(t, y),
    s.attr(
      'transform',
      `translate(${-o.width / 2 - (o.x - (o.left ?? 0))}, ${h / 2 - (o.height + (t.padding ?? 0) / (l ? 2 : 1) - (o.y - (o.top ?? 0)))})`
    ),
    (t.intersect = function (e) {
      return (si.info('Triangle intersect', t, u, e), Sb.polygon(t, u, e));
    }),
    a
  );
}
async function Wy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = l / 8,
    h = l + c,
    { cssStyles: d } = t,
    u = 70 - s,
    p = u > 0 ? u / 2 : 0,
    g = Zm(i),
    f = Gh(t, {});
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = [
      { x: -s / 2 - p, y: h / 2 },
      ...eb(-s / 2 - p, h / 2, s / 2 + p, h / 2, c, 0.8),
      { x: s / 2 + p, y: -h / 2 },
      { x: -s / 2 - p, y: -h / 2 },
    ],
    b = Jm(m),
    y = g.path(b, f),
    x = i.insert(() => y, ':first-child');
  return (
    x.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && x.selectAll('path').attr('style', d),
    n && 'handDrawn' !== t.look && x.selectAll('path').attr('style', n),
    x.attr('transform', `translate(0,${-c / 2})`),
    o.attr(
      'transform',
      `translate(${-s / 2 + (t.padding ?? 0) - (a.x - (a.left ?? 0))},${-l / 2 + (t.padding ?? 0) - c - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, x),
    (t.intersect = function (e) {
      return Sb.polygon(t, m, e);
    }),
    i
  );
}
async function Uy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a } = await Km(e, t, Qm(t)),
    o = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    s = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    l = o / s;
  let c = o,
    h = s;
  (c > h * l ? (h = c / l) : (c = h * l), (c = Math.max(c, 100)), (h = Math.max(h, 50)));
  const d = Math.min(0.2 * h, h / 4),
    u = h + 2 * d,
    { cssStyles: p } = t,
    g = Zm(i),
    f = Gh(t, {});
  'handDrawn' !== t.look && ((f.roughness = 0), (f.fillStyle = 'solid'));
  const m = [
      { x: -c / 2, y: u / 2 },
      ...eb(-c / 2, u / 2, c / 2, u / 2, d, 1),
      { x: c / 2, y: -u / 2 },
      ...eb(c / 2, -u / 2, -c / 2, -u / 2, d, -1),
    ],
    b = Jm(m),
    y = g.path(b, f),
    x = i.insert(() => y, ':first-child');
  return (
    x.attr('class', 'basic label-container'),
    p && 'handDrawn' !== t.look && x.selectAll('path').attr('style', p),
    n && 'handDrawn' !== t.look && x.selectAll('path').attr('style', n),
    Xm(t, x),
    (t.intersect = function (e) {
      return Sb.polygon(t, m, e);
    }),
    i
  );
}
async function Hy(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, label: o } = await Km(e, t, Qm(t)),
    s = Math.max(a.width + 2 * (t.padding ?? 0), (null == t ? void 0 : t.width) ?? 0),
    l = Math.max(a.height + 2 * (t.padding ?? 0), (null == t ? void 0 : t.height) ?? 0),
    c = -s / 2,
    h = -l / 2,
    { cssStyles: d } = t,
    u = Zm(i),
    p = Gh(t, {}),
    g = [
      { x: c - 5, y: h - 5 },
      { x: c - 5, y: h + l },
      { x: c + s, y: h + l },
      { x: c + s, y: h - 5 },
    ],
    f = `M${c - 5},${h - 5} L${c + s},${h - 5} L${c + s},${h + l} L${c - 5},${h + l} L${c - 5},${h - 5}\n                M${c - 5},${h} L${c + s},${h}\n                M${c},${h - 5} L${c},${h + l}`;
  'handDrawn' !== t.look && ((p.roughness = 0), (p.fillStyle = 'solid'));
  const m = u.path(f, p),
    b = i.insert(() => m, ':first-child');
  return (
    b.attr('transform', 'translate(2.5, 2.5)'),
    b.attr('class', 'basic label-container'),
    d && 'handDrawn' !== t.look && b.selectAll('path').attr('style', d),
    n && 'handDrawn' !== t.look && b.selectAll('path').attr('style', n),
    o.attr(
      'transform',
      `translate(${-a.width / 2 + 2.5 - (a.x - (a.left ?? 0))}, ${-a.height / 2 + 2.5 - (a.y - (a.top ?? 0))})`
    ),
    Xm(t, b),
    (t.intersect = function (e) {
      return Sb.polygon(t, g, e);
    }),
    i
  );
}
async function Gy(e, t) {
  var r, n, i, a;
  const o = t;
  if ((o.alias && (t.label = o.alias), 'handDrawn' === t.look)) {
    const { themeVariables: r } = _o(),
      { background: n } = r,
      i = {
        ...t,
        id: t.id + '-background',
        look: 'default',
        cssStyles: ['stroke: none', `fill: ${n}`],
      };
    await Gy(e, i);
  }
  const s = _o();
  t.useHtmlLabels = s.htmlLabels;
  let l = (null == (r = s.er) ? void 0 : r.diagramPadding) ?? 10,
    c = (null == (n = s.er) ? void 0 : n.entityPadding) ?? 6;
  const { cssStyles: h } = t,
    { labelStyles: d, nodeStyles: u } = Hh(t);
  if (0 === o.attributes.length && t.label) {
    const r = { rx: 0, ry: 0, labelPaddingX: l, labelPaddingY: 1.5 * l };
    Mp(t.label, s) + 2 * r.labelPaddingX < s.er.minEntityWidth && (t.width = s.er.minEntityWidth);
    const n = await oy(e, t, r);
    if (!Go(s.htmlLabels)) {
      const e = n.select('text'),
        t = null == (i = e.node()) ? void 0 : i.getBBox();
      e.attr('transform', `translate(${-t.width / 2}, 0)`);
    }
    return n;
  }
  s.htmlLabels || ((l *= 1.25), (c *= 1.25));
  let p = Qm(t);
  p || (p = 'node default');
  const g = e
      .insert('g')
      .attr('class', p)
      .attr('id', t.domId || t.id),
    f = await Vy(g, t.label ?? '', s, 0, 0, ['name'], d);
  f.height += c;
  let m = 0;
  const b = [],
    y = [];
  let x = 0,
    k = 0,
    C = 0,
    w = 0,
    v = !0,
    _ = !0;
  for (const S of o.attributes) {
    const e = await Vy(g, S.type, s, 0, m, ['attribute-type'], d);
    x = Math.max(x, e.width + l);
    const t = await Vy(g, S.name, s, 0, m, ['attribute-name'], d);
    k = Math.max(k, t.width + l);
    const r = await Vy(g, S.keys.join(), s, 0, m, ['attribute-keys'], d);
    C = Math.max(C, r.width + l);
    const n = await Vy(g, S.comment, s, 0, m, ['attribute-comment'], d);
    w = Math.max(w, n.width + l);
    const i = Math.max(e.height, t.height, r.height, n.height) + c;
    (y.push({ yOffset: m, rowHeight: i }), (m += i));
  }
  let E = 4;
  (C <= l && ((v = !1), (C = 0), E--), w <= l && ((_ = !1), (w = 0), E--));
  const D = g.node().getBBox();
  if (f.width + 2 * l - (x + k + C + w) > 0) {
    const e = f.width + 2 * l - (x + k + C + w);
    ((x += e / E), (k += e / E), C > 0 && (C += e / E), w > 0 && (w += e / E));
  }
  const A = x + k + C + w,
    T = Zm(g),
    F = Gh(t, {});
  'handDrawn' !== t.look && ((F.roughness = 0), (F.fillStyle = 'solid'));
  let B = 0;
  y.length > 0 && (B = y.reduce((e, t) => e + ((null == t ? void 0 : t.rowHeight) ?? 0), 0));
  const M = Math.max(D.width + 2 * l, (null == t ? void 0 : t.width) || 0, A),
    N = Math.max((B ?? 0) + f.height, (null == t ? void 0 : t.height) || 0),
    L = -M / 2,
    O = -N / 2;
  (g.selectAll('g:not(:first-child)').each((e, t, r) => {
    const n = S(r[t]),
      i = n.attr('transform');
    let a = 0,
      o = 0;
    if (i) {
      const e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(i);
      e &&
        ((a = parseFloat(e[1])),
        (o = parseFloat(e[2])),
        n.attr('class').includes('attribute-name')
          ? (a += x)
          : n.attr('class').includes('attribute-keys')
            ? (a += x + k)
            : n.attr('class').includes('attribute-comment') && (a += x + k + C));
    }
    n.attr('transform', `translate(${L + l / 2 + a}, ${o + O + f.height + c / 2})`);
  }),
    g.select('.name').attr('transform', 'translate(' + -f.width / 2 + ', ' + (O + c / 2) + ')'));
  const $ = T.rectangle(L, O, M, N, F),
    I = g.insert(() => $, ':first-child').attr('style', h.join('')),
    { themeVariables: R } = _o(),
    { rowEven: z, rowOdd: P, nodeBorder: j } = R;
  b.push(0);
  for (const [S, W] of y.entries()) {
    const e = (S + 1) % 2 == 0 && 0 !== W.yOffset,
      t = T.rectangle(
        L,
        f.height + O + (null == W ? void 0 : W.yOffset),
        M,
        null == W ? void 0 : W.rowHeight,
        { ...F, fill: e ? z : P, stroke: j }
      );
    g.insert(() => t, 'g.label')
      .attr('style', h.join(''))
      .attr('class', 'row-rect-' + (e ? 'even' : 'odd'));
  }
  let q = T.line(L, f.height + O, M + L, f.height + O, F);
  (g.insert(() => q).attr('class', 'divider'),
    (q = T.line(x + L, f.height + O, x + L, N + O, F)),
    g.insert(() => q).attr('class', 'divider'),
    v &&
      ((q = T.line(x + k + L, f.height + O, x + k + L, N + O, F)),
      g.insert(() => q).attr('class', 'divider')),
    _ &&
      ((q = T.line(x + k + C + L, f.height + O, x + k + C + L, N + O, F)),
      g.insert(() => q).attr('class', 'divider')));
  for (const S of b)
    ((q = T.line(L, f.height + O + S, M + L, f.height + O + S, F)),
      g.insert(() => q).attr('class', 'divider'));
  if ((Xm(t, I), u && 'handDrawn' !== t.look)) {
    const e = u.split(';'),
      t =
        null == (a = null == e ? void 0 : e.filter((e) => e.includes('stroke')))
          ? void 0
          : a.map((e) => `${e}`).join('; ');
    (g.selectAll('path').attr('style', t ?? ''),
      g.selectAll('.row-rect-even path').attr('style', u));
  }
  return (
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    g
  );
}
async function Vy(e, t, r, n = 0, i = 0, a = [], o = '') {
  const s = e
    .insert('g')
    .attr('class', `label ${a.join(' ')}`)
    .attr('transform', `translate(${n}, ${i})`)
    .attr('style', o);
  t !== Ko(t) && (t = (t = Ko(t)).replaceAll('<', '&lt;').replaceAll('>', '&gt;'));
  const l = s
    .node()
    .appendChild(
      await Zf(s, t, { width: Mp(t, r) + 100, style: o, useHtmlLabels: r.htmlLabels }, r)
    );
  if (t.includes('&lt;') || t.includes('&gt;')) {
    let e = l.children[0];
    for (
      e.textContent = e.textContent.replaceAll('&lt;', '<').replaceAll('&gt;', '>');
      e.childNodes[0];
    )
      ((e = e.childNodes[0]),
        (e.textContent = e.textContent.replaceAll('&lt;', '<').replaceAll('&gt;', '>')));
  }
  let c = l.getBBox();
  if (Go(r.htmlLabels)) {
    const e = l.children[0];
    e.style.textAlign = 'start';
    const t = S(l);
    ((c = e.getBoundingClientRect()), t.attr('width', c.width), t.attr('height', c.height));
  }
  return c;
}
async function Zy(e, t, r, n, i = r.class.padding ?? 12) {
  const a = n ? 0 : 3,
    o = e
      .insert('g')
      .attr('class', Qm(t))
      .attr('id', t.domId || t.id);
  let s = null,
    l = null,
    c = null,
    h = null,
    d = 0,
    u = 0,
    p = 0;
  if (((s = o.insert('g').attr('class', 'annotation-group text')), t.annotations.length > 0)) {
    const e = t.annotations[0];
    await Ky(s, { text: `«${e}»` }, 0);
    d = s.node().getBBox().height;
  }
  ((l = o.insert('g').attr('class', 'label-group text')),
    await Ky(l, t, 0, ['font-weight: bolder']));
  const g = l.node().getBBox();
  ((u = g.height), (c = o.insert('g').attr('class', 'members-group text')));
  let f = 0;
  for (const y of t.members) {
    f += (await Ky(c, y, f, [y.parseClassifier()])) + a;
  }
  ((p = c.node().getBBox().height),
    p <= 0 && (p = i / 2),
    (h = o.insert('g').attr('class', 'methods-group text')));
  let m = 0;
  for (const y of t.methods) {
    m += (await Ky(h, y, m, [y.parseClassifier()])) + a;
  }
  let b = o.node().getBBox();
  if (null !== s) {
    const e = s.node().getBBox();
    s.attr('transform', `translate(${-e.width / 2})`);
  }
  return (
    l.attr('transform', `translate(${-g.width / 2}, ${d})`),
    (b = o.node().getBBox()),
    c.attr('transform', `translate(0, ${d + u + 2 * i})`),
    (b = o.node().getBBox()),
    h.attr('transform', `translate(0, ${d + u + (p ? p + 4 * i : 2 * i)})`),
    (b = o.node().getBBox()),
    { shapeSvg: o, bbox: b }
  );
}
async function Ky(e, t, r, n = []) {
  const i = e.insert('g').attr('class', 'label').attr('style', n.join('; ')),
    a = _o();
  let o = 'useHtmlLabels' in t ? t.useHtmlLabels : (Go(a.htmlLabels) ?? !0),
    s = '';
  ((s = 'text' in t ? t.text : t.label),
    !o && s.startsWith('\\') && (s = s.substring(1)),
    ts(s) && (o = !0));
  const l = await Zf(
    i,
    Bs(Wp(s)),
    { width: Mp(s, a) + 50, classes: 'markdown-node-label', useHtmlLabels: o },
    a
  );
  let c,
    h = 1;
  if (o) {
    const e = l.children[0],
      t = S(l);
    ((h = e.innerHTML.split('<br>').length),
      e.innerHTML.includes('</math>') && (h += e.innerHTML.split('<mrow>').length - 1));
    const r = e.getElementsByTagName('img');
    if (r) {
      const e = '' === s.replace(/<img[^>]*>/g, '').trim();
      await Promise.all(
        [...r].map(
          (t) =>
            new Promise((r) => {
              function n() {
                var n;
                if (((t.style.display = 'flex'), (t.style.flexDirection = 'column'), e)) {
                  const e =
                      (null == (n = a.fontSize) ? void 0 : n.toString()) ??
                      window.getComputedStyle(document.body).fontSize,
                    r = 5,
                    i = parseInt(e, 10) * r + 'px';
                  ((t.style.minWidth = i), (t.style.maxWidth = i));
                } else t.style.width = '100%';
                r(t);
              }
              (ii(n, 'setupImage'),
                setTimeout(() => {
                  t.complete && n();
                }),
                t.addEventListener('error', n),
                t.addEventListener('load', n));
            })
        )
      );
    }
    ((c = e.getBoundingClientRect()), t.attr('width', c.width), t.attr('height', c.height));
  } else {
    (n.includes('font-weight: bolder') && S(l).selectAll('tspan').attr('font-weight', ''),
      (h = l.children.length));
    const e = l.children[0];
    if ('' === l.textContent || l.textContent.includes('&gt')) {
      e.textContent = s[0] + s.substring(1).replaceAll('&gt;', '>').replaceAll('&lt;', '<').trim();
      ' ' === s[1] && (e.textContent = e.textContent[0] + ' ' + e.textContent.substring(1));
    }
    ('undefined' === e.textContent && (e.textContent = ''), (c = l.getBBox()));
  }
  return (i.attr('transform', 'translate(0,' + (-c.height / (2 * h) + r) + ')'), c.height);
}
async function Yy(e, t) {
  var r, n;
  const i = As(),
    a = i.class.padding ?? 12,
    o = a,
    s = t.useHtmlLabels ?? Go(i.htmlLabels) ?? !0,
    l = t;
  ((l.annotations = l.annotations ?? []),
    (l.members = l.members ?? []),
    (l.methods = l.methods ?? []));
  const { shapeSvg: c, bbox: h } = await Zy(e, t, i, s, o),
    { labelStyles: d, nodeStyles: u } = Hh(t);
  ((t.labelStyle = d), (t.cssStyles = l.styles || ''));
  const p = (null == (r = l.styles) ? void 0 : r.join(';')) || u || '';
  t.cssStyles || (t.cssStyles = p.replaceAll('!important', '').split(';'));
  const g =
      0 === l.members.length &&
      0 === l.methods.length &&
      !(null == (n = i.class) ? void 0 : n.hideEmptyMembersBox),
    f = Zm(c),
    m = Gh(t, {});
  'handDrawn' !== t.look && ((m.roughness = 0), (m.fillStyle = 'solid'));
  const b = h.width;
  let y = h.height;
  0 === l.members.length && 0 === l.methods.length
    ? (y += o)
    : l.members.length > 0 && 0 === l.methods.length && (y += 2 * o);
  const x = -b / 2,
    k = -y / 2,
    C = f.rectangle(
      x - a,
      k - a - (g ? a : 0 === l.members.length && 0 === l.methods.length ? -a / 2 : 0),
      b + 2 * a,
      y + 2 * a + (g ? 2 * a : 0 === l.members.length && 0 === l.methods.length ? -a : 0),
      m
    ),
    w = c.insert(() => C, ':first-child');
  w.attr('class', 'basic label-container');
  const v = w.node().getBBox();
  c.selectAll('.text').each((e, t, r) => {
    var n;
    const i = S(r[t]),
      o = i.attr('transform');
    let h = 0;
    if (o) {
      const e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(o);
      e && (h = parseFloat(e[2]));
    }
    let d = h + k + a - (g ? a : 0 === l.members.length && 0 === l.methods.length ? -a / 2 : 0);
    s || (d -= 4);
    let u = x;
    ((i.attr('class').includes('label-group') || i.attr('class').includes('annotation-group')) &&
      ((u = -(null == (n = i.node()) ? void 0 : n.getBBox().width) / 2 || 0),
      c.selectAll('text').each(function (e, t, r) {
        'middle' === window.getComputedStyle(r[t]).textAnchor && (u = 0);
      })),
      i.attr('transform', `translate(${u}, ${d})`));
  });
  const _ = c.select('.annotation-group').node().getBBox().height - (g ? a / 2 : 0) || 0,
    E = c.select('.label-group').node().getBBox().height - (g ? a / 2 : 0) || 0,
    D = c.select('.members-group').node().getBBox().height - (g ? a / 2 : 0) || 0;
  if (l.members.length > 0 || l.methods.length > 0 || g) {
    const e = f.line(v.x, _ + E + k + a, v.x + v.width, _ + E + k + a, m);
    c.insert(() => e)
      .attr('class', 'divider')
      .attr('style', p);
  }
  if (g || l.members.length > 0 || l.methods.length > 0) {
    const e = f.line(v.x, _ + E + D + k + 2 * o + a, v.x + v.width, _ + E + D + k + a + 2 * o, m);
    c.insert(() => e)
      .attr('class', 'divider')
      .attr('style', p);
  }
  if (
    ('handDrawn' !== l.look && c.selectAll('path').attr('style', p),
    w.select(':nth-child(2)').attr('style', p),
    c.selectAll('.divider').select('path').attr('style', p),
    t.labelStyle
      ? c.selectAll('span').attr('style', t.labelStyle)
      : c.selectAll('span').attr('style', p),
    !s)
  ) {
    const e = RegExp(/color\s*:\s*([^;]*)/),
      t = e.exec(p);
    if (t) {
      const e = t[0].replace('color', 'fill');
      c.selectAll('tspan').attr('style', e);
    } else if (d) {
      const t = e.exec(d);
      if (t) {
        const e = t[0].replace('color', 'fill');
        c.selectAll('tspan').attr('style', e);
      }
    }
  }
  return (
    Xm(t, w),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    c
  );
}
async function Xy(e, t) {
  var r, n;
  const { labelStyles: i, nodeStyles: a } = Hh(t);
  t.labelStyle = i;
  const o = t,
    s = t,
    l = 'verifyMethod' in t,
    c = Qm(t),
    h = e
      .insert('g')
      .attr('class', c)
      .attr('id', t.domId ?? t.id);
  let d;
  d = l
    ? await Qy(h, `&lt;&lt;${o.type}&gt;&gt;`, 0, t.labelStyle)
    : await Qy(h, '&lt;&lt;Element&gt;&gt;', 0, t.labelStyle);
  let u = d;
  const p = await Qy(h, o.name, u, t.labelStyle + '; font-weight: bold;');
  if (((u += p + 20), l)) {
    u += await Qy(h, '' + (o.requirementId ? `ID: ${o.requirementId}` : ''), u, t.labelStyle);
    u += await Qy(h, '' + (o.text ? `Text: ${o.text}` : ''), u, t.labelStyle);
    ((u += await Qy(h, '' + (o.risk ? `Risk: ${o.risk}` : ''), u, t.labelStyle)),
      await Qy(h, '' + (o.verifyMethod ? `Verification: ${o.verifyMethod}` : ''), u, t.labelStyle));
  } else {
    ((u += await Qy(h, '' + (s.type ? `Type: ${s.type}` : ''), u, t.labelStyle)),
      await Qy(h, '' + (s.docRef ? `Doc Ref: ${s.docRef}` : ''), u, t.labelStyle));
  }
  const g = ((null == (r = h.node()) ? void 0 : r.getBBox().width) ?? 200) + 20,
    f = ((null == (n = h.node()) ? void 0 : n.getBBox().height) ?? 200) + 20,
    m = -g / 2,
    b = -f / 2,
    y = Zm(h),
    x = Gh(t, {});
  'handDrawn' !== t.look && ((x.roughness = 0), (x.fillStyle = 'solid'));
  const k = y.rectangle(m, b, g, f, x),
    C = h.insert(() => k, ':first-child');
  if (
    (C.attr('class', 'basic label-container').attr('style', a),
    h.selectAll('.label').each((e, t, r) => {
      const n = S(r[t]),
        i = n.attr('transform');
      let a = 0,
        o = 0;
      if (i) {
        const e = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(i);
        e && ((a = parseFloat(e[1])), (o = parseFloat(e[2])));
      }
      const s = o - f / 2;
      let l = m + 10;
      ((0 !== t && 1 !== t) || (l = a), n.attr('transform', `translate(${l}, ${s + 20})`));
    }),
    u > d + p + 20)
  ) {
    const e = y.line(m, b + d + p + 20, m + g, b + d + p + 20, x);
    h.insert(() => e).attr('style', a);
  }
  return (
    Xm(t, C),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    h
  );
}
async function Qy(e, t, r, n = '') {
  if ('' === t) return 0;
  const i = e.insert('g').attr('class', 'label').attr('style', n),
    a = As(),
    o = a.htmlLabels ?? !0,
    s = await Zf(
      i,
      Bs(Wp(t)),
      { width: Mp(t, a) + 50, classes: 'markdown-node-label', useHtmlLabels: o, style: n },
      a
    );
  let l;
  if (o) {
    const e = s.children[0],
      t = S(s);
    ((l = e.getBoundingClientRect()), t.attr('width', l.width), t.attr('height', l.height));
  } else {
    const e = s.children[0];
    for (const t of e.children)
      ((t.textContent = t.textContent.replaceAll('&gt;', '>').replaceAll('&lt;', '<')),
        n && t.setAttribute('style', n));
    ((l = s.getBBox()), (l.height += 6));
  }
  return (i.attr('transform', `translate(${-l.width / 2},${-l.height / 2 + r})`), l.height);
}
(ii(zy, 'tiltedCylinder'),
  ii(Py, 'trapezoid'),
  ii(jy, 'trapezoidalPentagon'),
  ii(qy, 'triangle'),
  ii(Wy, 'waveEdgedRectangle'),
  ii(Uy, 'waveRectangle'),
  ii(Hy, 'windowPane'),
  ii(Gy, 'erBox'),
  ii(Vy, 'addText'),
  ii(Zy, 'textHelper'),
  ii(Ky, 'addText'),
  ii(Yy, 'classBox'),
  ii(Xy, 'requirementBox'),
  ii(Qy, 'addText'));
var Jy = ii((e) => {
  switch (e) {
    case 'Very High':
      return 'red';
    case 'High':
      return 'orange';
    case 'Medium':
      return null;
    case 'Low':
      return 'blue';
    case 'Very Low':
      return 'lightblue';
  }
}, 'colorFromPriority');
async function ex(e, t, { config: r }) {
  var n, i;
  const { labelStyles: a, nodeStyles: o } = Hh(t);
  t.labelStyle = a || '';
  const s = t.width;
  t.width = (t.width ?? 200) - 10;
  const { shapeSvg: l, bbox: c, label: h } = await Km(e, t, Qm(t)),
    d = t.padding || 10;
  let u,
    p = '';
  'ticket' in t &&
    t.ticket &&
    (null == (n = null == r ? void 0 : r.kanban) ? void 0 : n.ticketBaseUrl) &&
    ((p =
      null == (i = null == r ? void 0 : r.kanban)
        ? void 0
        : i.ticketBaseUrl.replace('#TICKET#', t.ticket)),
    (u = l
      .insert('svg:a', ':first-child')
      .attr('class', 'kanban-ticket-link')
      .attr('xlink:href', p)
      .attr('target', '_blank')));
  const g = {
    useHtmlLabels: t.useHtmlLabels,
    labelStyle: t.labelStyle || '',
    width: t.width,
    img: t.img,
    padding: t.padding || 8,
    centerLabel: !1,
  };
  let f, m;
  ({ label: f, bbox: m } = u
    ? await Ym(u, ('ticket' in t && t.ticket) || '', g)
    : await Ym(l, ('ticket' in t && t.ticket) || '', g));
  const { label: b, bbox: y } = await Ym(l, ('assigned' in t && t.assigned) || '', g);
  t.width = s;
  const x = (null == t ? void 0 : t.width) || 0,
    k = Math.max(m.height, y.height) / 2,
    C = Math.max(c.height + 20, (null == t ? void 0 : t.height) || 0) + k,
    w = -x / 2,
    v = -C / 2;
  let _;
  (h.attr('transform', 'translate(' + (d - x / 2) + ', ' + (-k - c.height / 2) + ')'),
    f.attr('transform', 'translate(' + (d - x / 2) + ', ' + (-k + c.height / 2) + ')'),
    b.attr(
      'transform',
      'translate(' + (d + x / 2 - y.width - 20) + ', ' + (-k + c.height / 2) + ')'
    ));
  const { rx: S, ry: E } = t,
    { cssStyles: D } = t;
  if ('handDrawn' === t.look) {
    const e = Zm(l),
      r = Gh(t, {}),
      n = S || E ? e.path(ob(w, v, x, C, S || 0), r) : e.rectangle(w, v, x, C, r);
    ((_ = l.insert(() => n, ':first-child')),
      _.attr('class', 'basic label-container').attr('style', D || null));
  } else {
    ((_ = l.insert('rect', ':first-child')),
      _.attr('class', 'basic label-container __APA__')
        .attr('style', o)
        .attr('rx', S ?? 5)
        .attr('ry', E ?? 5)
        .attr('x', w)
        .attr('y', v)
        .attr('width', x)
        .attr('height', C));
    const e = 'priority' in t && t.priority;
    if (e) {
      const t = l.append('line'),
        r = w + 2,
        n = v + Math.floor((S ?? 0) / 2),
        i = v + C - Math.floor((S ?? 0) / 2);
      t.attr('x1', r)
        .attr('y1', n)
        .attr('x2', r)
        .attr('y2', i)
        .attr('stroke-width', '4')
        .attr('stroke', Jy(e));
    }
  }
  return (
    Xm(t, _),
    (t.height = C),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    l
  );
}
async function tx(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: o, label: s } = await Km(e, t, Qm(t)),
    l = a.width + 10 * o,
    c = a.height + 8 * o,
    h = 0.15 * l,
    { cssStyles: d } = t,
    u = a.width + 20,
    p = a.height + 20,
    g = Math.max(l, u),
    f = Math.max(c, p);
  let m;
  s.attr('transform', `translate(${-a.width / 2}, ${-a.height / 2})`);
  const b = `M0 0 \n    a${h},${h} 1 0,0 ${0.25 * g},${-1 * f * 0.1}\n    a${h},${h} 1 0,0 ${0.25 * g},0\n    a${h},${h} 1 0,0 ${0.25 * g},0\n    a${h},${h} 1 0,0 ${0.25 * g},${0.1 * f}\n\n    a${h},${h} 1 0,0 ${0.15 * g},${0.33 * f}\n    a${0.8 * h},${0.8 * h} 1 0,0 0,${0.34 * f}\n    a${h},${h} 1 0,0 ${-1 * g * 0.15},${0.33 * f}\n\n    a${h},${h} 1 0,0 ${-1 * g * 0.25},${0.15 * f}\n    a${h},${h} 1 0,0 ${-1 * g * 0.25},0\n    a${h},${h} 1 0,0 ${-1 * g * 0.25},0\n    a${h},${h} 1 0,0 ${-1 * g * 0.25},${-1 * f * 0.15}\n\n    a${h},${h} 1 0,0 ${-1 * g * 0.1},${-1 * f * 0.33}\n    a${0.8 * h},${0.8 * h} 1 0,0 0,${-1 * f * 0.34}\n    a${h},${h} 1 0,0 ${0.1 * g},${-1 * f * 0.33}\n  H0 V0 Z`;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = e.path(b, r);
    ((m = i.insert(() => n, ':first-child')),
      m.attr('class', 'basic label-container').attr('style', Hp(d)));
  } else
    m = i
      .insert('path', ':first-child')
      .attr('class', 'basic label-container')
      .attr('style', n)
      .attr('d', b);
  return (
    m.attr('transform', `translate(${-g / 2}, ${-f / 2})`),
    Xm(t, m),
    (t.calcIntersect = function (e, t) {
      return Sb.rect(e, t);
    }),
    (t.intersect = function (e) {
      return (si.info('Bang intersect', t, e), Sb.rect(t, e));
    }),
    i
  );
}
async function rx(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: o, label: s } = await Km(e, t, Qm(t)),
    l = a.width + 2 * o,
    c = a.height + 2 * o,
    h = 0.15 * l,
    d = 0.25 * l,
    u = 0.35 * l,
    p = 0.2 * l,
    { cssStyles: g } = t;
  let f;
  const m = `M0 0 \n    a${h},${h} 0 0,1 ${0.25 * l},${-1 * l * 0.1}\n    a${u},${u} 1 0,1 ${0.4 * l},${-1 * l * 0.1}\n    a${d},${d} 1 0,1 ${0.35 * l},${0.2 * l}\n\n    a${h},${h} 1 0,1 ${0.15 * l},${0.35 * c}\n    a${p},${p} 1 0,1 ${-1 * l * 0.15},${0.65 * c}\n\n    a${d},${h} 1 0,1 ${-1 * l * 0.25},${0.15 * l}\n    a${u},${u} 1 0,1 ${-1 * l * 0.5},0\n    a${h},${h} 1 0,1 ${-1 * l * 0.25},${-1 * l * 0.15}\n\n    a${h},${h} 1 0,1 ${-1 * l * 0.1},${-1 * c * 0.35}\n    a${p},${p} 1 0,1 ${0.1 * l},${-1 * c * 0.65}\n  H0 V0 Z`;
  if ('handDrawn' === t.look) {
    const e = Zm(i),
      r = Gh(t, {}),
      n = e.path(m, r);
    ((f = i.insert(() => n, ':first-child')),
      f.attr('class', 'basic label-container').attr('style', Hp(g)));
  } else
    f = i
      .insert('path', ':first-child')
      .attr('class', 'basic label-container')
      .attr('style', n)
      .attr('d', m);
  return (
    s.attr('transform', `translate(${-a.width / 2}, ${-a.height / 2})`),
    f.attr('transform', `translate(${-l / 2}, ${-c / 2})`),
    Xm(t, f),
    (t.calcIntersect = function (e, t) {
      return Sb.rect(e, t);
    }),
    (t.intersect = function (e) {
      return (si.info('Cloud intersect', t, e), Sb.rect(t, e));
    }),
    i
  );
}
async function nx(e, t) {
  const { labelStyles: r, nodeStyles: n } = Hh(t);
  t.labelStyle = r;
  const { shapeSvg: i, bbox: a, halfPadding: o, label: s } = await Km(e, t, Qm(t)),
    l = a.width + 8 * o,
    c = a.height + 2 * o,
    h = `\n    M${-l / 2} ${c / 2 - 5}\n    v${10 - c}\n    q0,-5 5,-5\n    h${l - 10}\n    q5,0 5,5\n    v${c - 10}\n    q0,5 -5,5\n    h${10 - l}\n    q-5,0 -5,-5\n    Z\n  `,
    d = i
      .append('path')
      .attr('id', 'node-' + t.id)
      .attr('class', 'node-bkg node-' + t.type)
      .attr('style', n)
      .attr('d', h);
  return (
    i
      .append('line')
      .attr('class', 'node-line-')
      .attr('x1', -l / 2)
      .attr('y1', c / 2)
      .attr('x2', l / 2)
      .attr('y2', c / 2),
    s.attr('transform', `translate(${-a.width / 2}, ${-a.height / 2})`),
    i.append(() => s.node()),
    Xm(t, d),
    (t.calcIntersect = function (e, t) {
      return Sb.rect(e, t);
    }),
    (t.intersect = function (e) {
      return Sb.rect(t, e);
    }),
    i
  );
}
async function ix(e, t) {
  return Mb(e, t, { padding: t.padding ?? 0 });
}
(ii(ex, 'kanbanItem'),
  ii(tx, 'bang'),
  ii(rx, 'cloud'),
  ii(nx, 'defaultMindmapNode'),
  ii(ix, 'mindmapCircle'));
var ax = [
    {
      semanticName: 'Process',
      name: 'Rectangle',
      shortName: 'rect',
      description: 'Standard process shape',
      aliases: ['proc', 'process', 'rectangle'],
      internalAliases: ['squareRect'],
      handler: Dy,
    },
    {
      semanticName: 'Event',
      name: 'Rounded Rectangle',
      shortName: 'rounded',
      description: 'Represents an event',
      aliases: ['event'],
      internalAliases: ['roundedRect'],
      handler: _y,
    },
    {
      semanticName: 'Terminal Point',
      name: 'Stadium',
      shortName: 'stadium',
      description: 'Terminal point',
      aliases: ['terminal', 'pill'],
      handler: Ay,
    },
    {
      semanticName: 'Subprocess',
      name: 'Framed Rectangle',
      shortName: 'fr-rect',
      description: 'Subprocess',
      aliases: ['subprocess', 'subproc', 'framed-rectangle', 'subroutine'],
      handler: My,
    },
    {
      semanticName: 'Database',
      name: 'Cylinder',
      shortName: 'cyl',
      description: 'Database storage',
      aliases: ['db', 'database', 'cylinder'],
      handler: Hb,
    },
    {
      semanticName: 'Start',
      name: 'Circle',
      shortName: 'circle',
      description: 'Starting point',
      aliases: ['circ'],
      handler: Mb,
    },
    {
      semanticName: 'Bang',
      name: 'Bang',
      shortName: 'bang',
      description: 'Bang',
      aliases: ['bang'],
      handler: tx,
    },
    {
      semanticName: 'Cloud',
      name: 'Cloud',
      shortName: 'cloud',
      description: 'cloud',
      aliases: ['cloud'],
      handler: rx,
    },
    {
      semanticName: 'Decision',
      name: 'Diamond',
      shortName: 'diam',
      description: 'Decision-making step',
      aliases: ['decision', 'diamond', 'question'],
      handler: ky,
    },
    {
      semanticName: 'Prepare Conditional',
      name: 'Hexagon',
      shortName: 'hex',
      description: 'Preparation or condition step',
      aliases: ['hexagon', 'prepare'],
      handler: Qb,
    },
    {
      semanticName: 'Data Input/Output',
      name: 'Lean Right',
      shortName: 'lean-r',
      description: 'Represents input or output',
      aliases: ['lean-right', 'in-out'],
      internalAliases: ['lean_right'],
      handler: cy,
    },
    {
      semanticName: 'Data Input/Output',
      name: 'Lean Left',
      shortName: 'lean-l',
      description: 'Represents output or input',
      aliases: ['lean-left', 'out-in'],
      internalAliases: ['lean_left'],
      handler: ly,
    },
    {
      semanticName: 'Priority Action',
      name: 'Trapezoid Base Bottom',
      shortName: 'trap-b',
      description: 'Priority action',
      aliases: ['priority', 'trapezoid-bottom', 'trapezoid'],
      handler: Py,
    },
    {
      semanticName: 'Manual Operation',
      name: 'Trapezoid Base Top',
      shortName: 'trap-t',
      description: 'Represents a manual task',
      aliases: ['manual', 'trapezoid-top', 'inv-trapezoid'],
      internalAliases: ['inv_trapezoid'],
      handler: ay,
    },
    {
      semanticName: 'Stop',
      name: 'Double Circle',
      shortName: 'dbl-circ',
      description: 'Represents a stop point',
      aliases: ['double-circle'],
      internalAliases: ['doublecircle'],
      handler: Vb,
    },
    {
      semanticName: 'Text Block',
      name: 'Text Block',
      shortName: 'text',
      description: 'Text block',
      handler: Oy,
    },
    {
      semanticName: 'Card',
      name: 'Notched Rectangle',
      shortName: 'notch-rect',
      description: 'Represents a card',
      aliases: ['card', 'notched-rectangle'],
      handler: Fb,
    },
    {
      semanticName: 'Lined/Shaded Process',
      name: 'Lined Rectangle',
      shortName: 'lin-rect',
      description: 'Lined process shape',
      aliases: ['lined-rectangle', 'lined-process', 'lin-proc', 'shaded-process'],
      handler: Sy,
    },
    {
      semanticName: 'Start',
      name: 'Small Circle',
      shortName: 'sm-circ',
      description: 'Small starting point',
      aliases: ['start', 'small-circle'],
      internalAliases: ['stateStart'],
      handler: By,
    },
    {
      semanticName: 'Stop',
      name: 'Framed Circle',
      shortName: 'fr-circ',
      description: 'Stop point',
      aliases: ['stop', 'framed-circle'],
      internalAliases: ['stateEnd'],
      handler: Fy,
    },
    {
      semanticName: 'Fork/Join',
      name: 'Filled Rectangle',
      shortName: 'fork',
      description: 'Fork or join in process flow',
      aliases: ['join'],
      internalAliases: ['forkJoin'],
      handler: Yb,
    },
    {
      semanticName: 'Collate',
      name: 'Hourglass',
      shortName: 'hourglass',
      description: 'Represents a collate operation',
      aliases: ['hourglass', 'collate'],
      handler: Jb,
    },
    {
      semanticName: 'Comment',
      name: 'Curly Brace',
      shortName: 'brace',
      description: 'Adds a comment',
      aliases: ['comment', 'brace-l'],
      handler: $b,
    },
    {
      semanticName: 'Comment Right',
      name: 'Curly Brace',
      shortName: 'brace-r',
      description: 'Adds a comment',
      handler: Rb,
    },
    {
      semanticName: 'Comment with braces on both sides',
      name: 'Curly Braces',
      shortName: 'braces',
      description: 'Adds a comment',
      handler: Pb,
    },
    {
      semanticName: 'Com Link',
      name: 'Lightning Bolt',
      shortName: 'bolt',
      description: 'Communication link',
      aliases: ['com-link', 'lightning-bolt'],
      handler: hy,
    },
    {
      semanticName: 'Document',
      name: 'Document',
      shortName: 'doc',
      description: 'Represents a document',
      aliases: ['doc', 'document'],
      handler: Wy,
    },
    {
      semanticName: 'Delay',
      name: 'Half-Rounded Rectangle',
      shortName: 'delay',
      description: 'Represents a delay',
      aliases: ['half-rounded-rectangle'],
      handler: Xb,
    },
    {
      semanticName: 'Direct Access Storage',
      name: 'Horizontal Cylinder',
      shortName: 'h-cyl',
      description: 'Direct access storage',
      aliases: ['das', 'horizontal-cylinder'],
      handler: zy,
    },
    {
      semanticName: 'Disk Storage',
      name: 'Lined Cylinder',
      shortName: 'lin-cyl',
      description: 'Disk storage',
      aliases: ['disk', 'lined-cylinder'],
      handler: gy,
    },
    {
      semanticName: 'Display',
      name: 'Curved Trapezoid',
      shortName: 'curv-trap',
      description: 'Represents a display',
      aliases: ['curved-trapezoid', 'display'],
      handler: jb,
    },
    {
      semanticName: 'Divided Process',
      name: 'Divided Rectangle',
      shortName: 'div-rect',
      description: 'Divided process shape',
      aliases: ['div-proc', 'divided-rectangle', 'divided-process'],
      handler: Gb,
    },
    {
      semanticName: 'Extract',
      name: 'Triangle',
      shortName: 'tri',
      description: 'Extraction process',
      aliases: ['extract', 'triangle'],
      handler: qy,
    },
    {
      semanticName: 'Internal Storage',
      name: 'Window Pane',
      shortName: 'win-pane',
      description: 'Internal storage',
      aliases: ['internal-storage', 'window-pane'],
      handler: Hy,
    },
    {
      semanticName: 'Junction',
      name: 'Filled Circle',
      shortName: 'f-circ',
      description: 'Junction point',
      aliases: ['junction', 'filled-circle'],
      handler: Zb,
    },
    {
      semanticName: 'Loop Limit',
      name: 'Trapezoidal Pentagon',
      shortName: 'notch-pent',
      description: 'Loop limit step',
      aliases: ['loop-limit', 'notched-pentagon'],
      handler: jy,
    },
    {
      semanticName: 'Manual File',
      name: 'Flipped Triangle',
      shortName: 'flip-tri',
      description: 'Manual file operation',
      aliases: ['manual-file', 'flipped-triangle'],
      handler: Kb,
    },
    {
      semanticName: 'Manual Input',
      name: 'Sloped Rectangle',
      shortName: 'sl-rect',
      description: 'Manual input step',
      aliases: ['manual-input', 'sloped-rectangle'],
      handler: Ey,
    },
    {
      semanticName: 'Multi-Document',
      name: 'Stacked Document',
      shortName: 'docs',
      description: 'Multiple documents',
      aliases: ['documents', 'st-doc', 'stacked-document'],
      handler: by,
    },
    {
      semanticName: 'Multi-Process',
      name: 'Stacked Rectangle',
      shortName: 'st-rect',
      description: 'Multiple processes',
      aliases: ['procs', 'processes', 'stacked-rectangle'],
      handler: my,
    },
    {
      semanticName: 'Stored Data',
      name: 'Bow Tie Rectangle',
      shortName: 'bow-rect',
      description: 'Stored data',
      aliases: ['stored-data', 'bow-tie-rectangle'],
      handler: Ab,
    },
    {
      semanticName: 'Summary',
      name: 'Crossed Circle',
      shortName: 'cross-circ',
      description: 'Summary',
      aliases: ['summary', 'crossed-circle'],
      handler: Lb,
    },
    {
      semanticName: 'Tagged Document',
      name: 'Tagged Document',
      shortName: 'tag-doc',
      description: 'Tagged document',
      aliases: ['tag-doc', 'tagged-document'],
      handler: Ly,
    },
    {
      semanticName: 'Tagged Process',
      name: 'Tagged Rectangle',
      shortName: 'tag-rect',
      description: 'Tagged process',
      aliases: ['tagged-rectangle', 'tag-proc', 'tagged-process'],
      handler: Ny,
    },
    {
      semanticName: 'Paper Tape',
      name: 'Flag',
      shortName: 'flag',
      description: 'Paper tape',
      aliases: ['paper-tape'],
      handler: Uy,
    },
    {
      semanticName: 'Odd',
      name: 'Odd',
      shortName: 'odd',
      description: 'Odd shape',
      internalAliases: ['rect_left_inv_arrow'],
      handler: Cy,
    },
    {
      semanticName: 'Lined Document',
      name: 'Lined Document',
      shortName: 'lin-doc',
      description: 'Lined document',
      aliases: ['lined-document'],
      handler: fy,
    },
  ],
  ox = ii(() => {
    const e = {
        state: Ty,
        choice: Bb,
        note: yy,
        rectWithTitle: wy,
        labelRect: sy,
        iconSquare: ny,
        iconCircle: ty,
        icon: ey,
        iconRounded: ry,
        imageSquare: iy,
        anchor: Eb,
        kanbanItem: ex,
        mindmapCircle: ix,
        defaultMindmapNode: nx,
        classBox: Yy,
        erBox: Gy,
        requirementBox: Xy,
      },
      t = [
        ...Object.entries(e),
        ...ax.flatMap((e) =>
          [
            e.shortName,
            ...('aliases' in e ? e.aliases : []),
            ...('internalAliases' in e ? e.internalAliases : []),
          ].map((t) => [t, e.handler])
        ),
      ];
    return Object.fromEntries(t);
  }, 'generateShapeMap')();
function sx(e) {
  return e in ox;
}
ii(sx, 'isValidShape');
var lx = new Map();
async function cx(e, t, r) {
  let n, i;
  'rect' === t.shape && (t.rx && t.ry ? (t.shape = 'roundedRect') : (t.shape = 'squareRect'));
  const a = t.shape ? ox[t.shape] : void 0;
  if (!a) throw new Error(`No such shape: ${t.shape}. Please check your syntax.`);
  if (t.link) {
    let o;
    ('sandbox' === r.config.securityLevel
      ? (o = '_top')
      : t.linkTarget && (o = t.linkTarget || '_blank'),
      (n = e
        .insert('svg:a')
        .attr('xlink:href', t.link)
        .attr('target', o ?? null)),
      (i = await a(n, t, r)));
  } else ((i = await a(e, t, r)), (n = i));
  return (
    t.tooltip && i.attr('title', t.tooltip),
    lx.set(t.id, n),
    t.haveCallback && n.attr('class', n.attr('class') + ' clickable'),
    n
  );
}
ii(cx, 'insertNode');
var hx = ii((e, t) => {
    lx.set(t.id, e);
  }, 'setNodeElem'),
  dx = ii(() => {
    lx.clear();
  }, 'clear'),
  ux = ii((e) => {
    const t = lx.get(e.id);
    si.trace(
      'Transforming node',
      e.diff,
      e,
      'translate(' + (e.x - e.width / 2 - 5) + ', ' + e.width / 2 + ')'
    );
    const r = e.diff || 0;
    return (
      e.clusterNode
        ? t.attr(
            'transform',
            'translate(' + (e.x + r - e.width / 2) + ', ' + (e.y - e.height / 2 - 8) + ')'
          )
        : t.attr('transform', 'translate(' + e.x + ', ' + e.y + ')'),
      r
    );
  }, 'positionNode'),
  px = ii((e, t, r, n, i, a) => {
    (t.arrowTypeStart && fx(e, 'start', t.arrowTypeStart, r, n, i, a),
      t.arrowTypeEnd && fx(e, 'end', t.arrowTypeEnd, r, n, i, a));
  }, 'addEdgeMarkers'),
  gx = {
    arrow_cross: { type: 'cross', fill: !1 },
    arrow_point: { type: 'point', fill: !0 },
    arrow_barb: { type: 'barb', fill: !0 },
    arrow_circle: { type: 'circle', fill: !1 },
    aggregation: { type: 'aggregation', fill: !1 },
    extension: { type: 'extension', fill: !1 },
    composition: { type: 'composition', fill: !0 },
    dependency: { type: 'dependency', fill: !0 },
    lollipop: { type: 'lollipop', fill: !1 },
    only_one: { type: 'onlyOne', fill: !1 },
    zero_or_one: { type: 'zeroOrOne', fill: !1 },
    one_or_more: { type: 'oneOrMore', fill: !1 },
    zero_or_more: { type: 'zeroOrMore', fill: !1 },
    requirement_arrow: { type: 'requirement_arrow', fill: !1 },
    requirement_contains: { type: 'requirement_contains', fill: !1 },
  },
  fx = ii((e, t, r, n, i, a, o) => {
    var s;
    const l = gx[r];
    if (!l) return void si.warn(`Unknown arrow type: ${r}`);
    const c = `${i}_${a}-${l.type}${'start' === t ? 'Start' : 'End'}`;
    if (o && '' !== o.trim()) {
      const r = `${c}_${o.replace(/[^\dA-Za-z]/g, '_')}`;
      if (!document.getElementById(r)) {
        const e = document.getElementById(c);
        if (e) {
          const t = e.cloneNode(!0);
          t.id = r;
          (t.querySelectorAll('path, circle, line').forEach((e) => {
            (e.setAttribute('stroke', o), l.fill && e.setAttribute('fill', o));
          }),
            null == (s = e.parentNode) || s.appendChild(t));
        }
      }
      e.attr(`marker-${t}`, `url(${n}#${r})`);
    } else e.attr(`marker-${t}`, `url(${n}#${c})`);
  }, 'addEdgeMarker'),
  mx = new Map(),
  bx = new Map(),
  yx = ii(() => {
    (mx.clear(), bx.clear());
  }, 'clear'),
  xx = ii((e) => (e ? e.reduce((e, t) => e + ';' + t, '') : ''), 'getLabelStyles'),
  kx = ii(async (e, t) => {
    let r = Go(As().flowchart.htmlLabels);
    const { labelStyles: n } = Hh(t);
    t.labelStyle = n;
    const i = await Zf(e, t.label, {
      style: t.labelStyle,
      useHtmlLabels: r,
      addSvgBackground: !0,
      isNode: !1,
    });
    si.info('abc82', t, t.labelType);
    const a = e.insert('g').attr('class', 'edgeLabel'),
      o = a.insert('g').attr('class', 'label').attr('data-id', t.id);
    o.node().appendChild(i);
    let s,
      l = i.getBBox();
    if (r) {
      const e = i.children[0],
        t = S(i);
      ((l = e.getBoundingClientRect()), t.attr('width', l.width), t.attr('height', l.height));
    }
    if (
      (o.attr('transform', 'translate(' + -l.width / 2 + ', ' + -l.height / 2 + ')'),
      mx.set(t.id, a),
      (t.width = l.width),
      (t.height = l.height),
      t.startLabelLeft)
    ) {
      const r = await ab(t.startLabelLeft, xx(t.labelStyle)),
        n = e.insert('g').attr('class', 'edgeTerminals'),
        i = n.insert('g').attr('class', 'inner');
      s = i.node().appendChild(r);
      const a = r.getBBox();
      (i.attr('transform', 'translate(' + -a.width / 2 + ', ' + -a.height / 2 + ')'),
        bx.get(t.id) || bx.set(t.id, {}),
        (bx.get(t.id).startLeft = n),
        Cx(s, t.startLabelLeft));
    }
    if (t.startLabelRight) {
      const r = await ab(t.startLabelRight, xx(t.labelStyle)),
        n = e.insert('g').attr('class', 'edgeTerminals'),
        i = n.insert('g').attr('class', 'inner');
      ((s = n.node().appendChild(r)), i.node().appendChild(r));
      const a = r.getBBox();
      (i.attr('transform', 'translate(' + -a.width / 2 + ', ' + -a.height / 2 + ')'),
        bx.get(t.id) || bx.set(t.id, {}),
        (bx.get(t.id).startRight = n),
        Cx(s, t.startLabelRight));
    }
    if (t.endLabelLeft) {
      const r = await ab(t.endLabelLeft, xx(t.labelStyle)),
        n = e.insert('g').attr('class', 'edgeTerminals'),
        i = n.insert('g').attr('class', 'inner');
      s = i.node().appendChild(r);
      const a = r.getBBox();
      (i.attr('transform', 'translate(' + -a.width / 2 + ', ' + -a.height / 2 + ')'),
        n.node().appendChild(r),
        bx.get(t.id) || bx.set(t.id, {}),
        (bx.get(t.id).endLeft = n),
        Cx(s, t.endLabelLeft));
    }
    if (t.endLabelRight) {
      const r = await ab(t.endLabelRight, xx(t.labelStyle)),
        n = e.insert('g').attr('class', 'edgeTerminals'),
        i = n.insert('g').attr('class', 'inner');
      s = i.node().appendChild(r);
      const a = r.getBBox();
      (i.attr('transform', 'translate(' + -a.width / 2 + ', ' + -a.height / 2 + ')'),
        n.node().appendChild(r),
        bx.get(t.id) || bx.set(t.id, {}),
        (bx.get(t.id).endRight = n),
        Cx(s, t.endLabelRight));
    }
    return i;
  }, 'insertEdgeLabel');
function Cx(e, t) {
  As().flowchart.htmlLabels &&
    e &&
    ((e.style.width = 9 * t.length + 'px'), (e.style.height = '12px'));
}
ii(Cx, 'setTerminalWidth');
var wx = ii((e, t) => {
    si.debug('Moving label abc88 ', e.id, e.label, mx.get(e.id), t);
    let r = t.updatedPath ? t.updatedPath : t.originalPath;
    const n = As(),
      { subGraphTitleTotalMargin: i } = Ph(n);
    if (e.label) {
      const n = mx.get(e.id);
      let a = e.x,
        o = e.y;
      if (r) {
        const n = jp.calcLabelPosition(r);
        (si.debug(
          'Moving label ' + e.label + ' from (',
          a,
          ',',
          o,
          ') to (',
          n.x,
          ',',
          n.y,
          ') abc88'
        ),
          t.updatedPath && ((a = n.x), (o = n.y)));
      }
      n.attr('transform', `translate(${a}, ${o + i / 2})`);
    }
    if (e.startLabelLeft) {
      const t = bx.get(e.id).startLeft;
      let n = e.x,
        i = e.y;
      if (r) {
        const t = jp.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_left', r);
        ((n = t.x), (i = t.y));
      }
      t.attr('transform', `translate(${n}, ${i})`);
    }
    if (e.startLabelRight) {
      const t = bx.get(e.id).startRight;
      let n = e.x,
        i = e.y;
      if (r) {
        const t = jp.calcTerminalLabelPosition(e.arrowTypeStart ? 10 : 0, 'start_right', r);
        ((n = t.x), (i = t.y));
      }
      t.attr('transform', `translate(${n}, ${i})`);
    }
    if (e.endLabelLeft) {
      const t = bx.get(e.id).endLeft;
      let n = e.x,
        i = e.y;
      if (r) {
        const t = jp.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_left', r);
        ((n = t.x), (i = t.y));
      }
      t.attr('transform', `translate(${n}, ${i})`);
    }
    if (e.endLabelRight) {
      const t = bx.get(e.id).endRight;
      let n = e.x,
        i = e.y;
      if (r) {
        const t = jp.calcTerminalLabelPosition(e.arrowTypeEnd ? 10 : 0, 'end_right', r);
        ((n = t.x), (i = t.y));
      }
      t.attr('transform', `translate(${n}, ${i})`);
    }
  }, 'positionEdgeLabel'),
  vx = ii((e, t) => {
    const r = e.x,
      n = e.y,
      i = Math.abs(t.x - r),
      a = Math.abs(t.y - n),
      o = e.width / 2,
      s = e.height / 2;
    return i >= o || a >= s;
  }, 'outsideNode'),
  _x = ii((e, t, r) => {
    si.debug(
      `intersection calc abc89:\n  outsidePoint: ${JSON.stringify(t)}\n  insidePoint : ${JSON.stringify(r)}\n  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`
    );
    const n = e.x,
      i = e.y,
      a = Math.abs(n - r.x),
      o = e.width / 2;
    let s = r.x < t.x ? o - a : o + a;
    const l = e.height / 2,
      c = Math.abs(t.y - r.y),
      h = Math.abs(t.x - r.x);
    if (Math.abs(i - t.y) * o > Math.abs(n - t.x) * l) {
      let e = r.y < t.y ? t.y - l - i : i - l - t.y;
      s = (h * e) / c;
      const n = { x: r.x < t.x ? r.x + s : r.x - h + s, y: r.y < t.y ? r.y + c - e : r.y - c + e };
      return (
        0 === s && ((n.x = t.x), (n.y = t.y)),
        0 === h && (n.x = t.x),
        0 === c && (n.y = t.y),
        si.debug(`abc89 top/bottom calc, Q ${c}, q ${e}, R ${h}, r ${s}`, n),
        n
      );
    }
    {
      s = r.x < t.x ? t.x - o - n : n - o - t.x;
      let e = (c * s) / h,
        i = r.x < t.x ? r.x + h - s : r.x - h + s,
        a = r.y < t.y ? r.y + e : r.y - e;
      return (
        si.debug(`sides calc abc89, Q ${c}, q ${e}, R ${h}, r ${s}`, { _x: i, _y: a }),
        0 === s && ((i = t.x), (a = t.y)),
        0 === h && (i = t.x),
        0 === c && (a = t.y),
        { x: i, y: a }
      );
    }
  }, 'intersection'),
  Sx = ii((e, t) => {
    si.warn('abc88 cutPathAtIntersect', e, t);
    let r = [],
      n = e[0],
      i = !1;
    return (
      e.forEach((e) => {
        if ((si.info('abc88 checking point', e, t), vx(t, e) || i))
          (si.warn('abc88 outside', e, n), (n = e), i || r.push(e));
        else {
          const a = _x(t, n, e);
          (si.debug('abc88 inside', e, n, a), si.debug('abc88 intersection', a, t));
          let o = !1;
          (r.forEach((e) => {
            o = o || (e.x === a.x && e.y === a.y);
          }),
            r.some((e) => e.x === a.x && e.y === a.y)
              ? si.warn('abc88 no intersect', a, r)
              : r.push(a),
            (i = !0));
        }
      }),
      si.debug('returning points', r),
      r
    );
  }, 'cutPathAtIntersect');
function Ex(e) {
  const t = [],
    r = [];
  for (let n = 1; n < e.length - 1; n++) {
    const i = e[n - 1],
      a = e[n],
      o = e[n + 1];
    ((i.x === a.x && a.y === o.y && Math.abs(a.x - o.x) > 5 && Math.abs(a.y - i.y) > 5) ||
      (i.y === a.y && a.x === o.x && Math.abs(a.x - i.x) > 5 && Math.abs(a.y - o.y) > 5)) &&
      (t.push(a), r.push(n));
  }
  return { cornerPoints: t, cornerPointPositions: r };
}
ii(Ex, 'extractCornerPoints');
var Dx = ii(function (e, t, r) {
    const n = t.x - e.x,
      i = t.y - e.y,
      a = r / Math.sqrt(n * n + i * i);
    return { x: t.x - a * n, y: t.y - a * i };
  }, 'findAdjacentPoint'),
  Ax = ii(function (e) {
    const { cornerPointPositions: t } = Ex(e),
      r = [];
    for (let n = 0; n < e.length; n++)
      if (t.includes(n)) {
        const t = e[n - 1],
          i = e[n + 1],
          a = e[n],
          o = Dx(t, a, 5),
          s = Dx(i, a, 5),
          l = s.x - o.x,
          c = s.y - o.y;
        r.push(o);
        const h = 2 * Math.sqrt(2);
        let d = { x: a.x, y: a.y };
        if (Math.abs(i.x - t.x) > 10 && Math.abs(i.y - t.y) >= 10) {
          si.debug('Corner point fixing', Math.abs(i.x - t.x), Math.abs(i.y - t.y));
          const e = 5;
          d =
            a.x === o.x
              ? { x: l < 0 ? o.x - e + h : o.x + e - h, y: c < 0 ? o.y - h : o.y + h }
              : { x: l < 0 ? o.x - h : o.x + h, y: c < 0 ? o.y - e + h : o.y + e - h };
        } else si.debug('Corner point skipping fixing', Math.abs(i.x - t.x), Math.abs(i.y - t.y));
        r.push(d, s);
      } else r.push(e[n]);
    return r;
  }, 'fixCorners'),
  Tx = ii((e, t, r) => {
    const n = e - t - r,
      i = Math.floor(n / 4);
    return `0 ${t} ${Array(i).fill('2 2').join(' ')} ${r}`;
  }, 'generateDashArray'),
  Fx = ii(function (e, t, r, n, i, a, o, s = !1) {
    var l;
    const { handDrawnSeed: c } = As();
    let h = t.points,
      d = !1;
    const u = i;
    var p = a;
    const g = [];
    for (const S in t.cssCompiledStyles) Uh(S) || g.push(t.cssCompiledStyles[S]);
    (si.debug('UIO intersect check', t.points, p.x, u.x),
      p.intersect &&
        u.intersect &&
        !s &&
        ((h = h.slice(1, t.points.length - 1)),
        h.unshift(u.intersect(h[0])),
        si.debug(
          'Last point UIO',
          t.start,
          '--\x3e',
          t.end,
          h[h.length - 1],
          p,
          p.intersect(h[h.length - 1])
        ),
        h.push(p.intersect(h[h.length - 1]))));
    const f = btoa(JSON.stringify(h));
    (t.toCluster &&
      (si.info('to cluster abc88', r.get(t.toCluster)),
      (h = Sx(t.points, r.get(t.toCluster).node)),
      (d = !0)),
      t.fromCluster &&
        (si.debug('from cluster abc88', r.get(t.fromCluster), JSON.stringify(h, null, 2)),
        (h = Sx(h.reverse(), r.get(t.fromCluster).node).reverse()),
        (d = !0)));
    let m = h.filter((e) => !Number.isNaN(e.y));
    m = Ax(m);
    let b = H;
    switch (((b = N), t.curve)) {
      case 'linear':
        b = N;
        break;
      case 'basis':
      default:
        b = H;
        break;
      case 'cardinal':
        b = I;
        break;
      case 'bumpX':
        b = q;
        break;
      case 'bumpY':
        b = j;
        break;
      case 'catmullRom':
        b = L;
        break;
      case 'monotoneX':
        b = B;
        break;
      case 'monotoneY':
        b = F;
        break;
      case 'natural':
        b = T;
        break;
      case 'step':
        b = A;
        break;
      case 'stepAfter':
        b = D;
        break;
      case 'stepBefore':
        b = E;
    }
    const { x: y, y: x } = zh(t),
      k = G().x(y).y(x).curve(b);
    let C, w;
    switch (t.thickness) {
      case 'normal':
      default:
        C = 'edge-thickness-normal';
        break;
      case 'thick':
        C = 'edge-thickness-thick';
        break;
      case 'invisible':
        C = 'edge-thickness-invisible';
    }
    switch (t.pattern) {
      case 'solid':
      default:
        C += ' edge-pattern-solid';
        break;
      case 'dotted':
        C += ' edge-pattern-dotted';
        break;
      case 'dashed':
        C += ' edge-pattern-dashed';
    }
    let v = 'rounded' === t.curve ? Bx(Nx(m, t), 5) : k(m);
    const _ = Array.isArray(t.style) ? t.style : [t.style];
    let M = _.find((e) => (null == e ? void 0 : e.startsWith('stroke:'))),
      O = !1;
    if ('handDrawn' === t.look) {
      const r = Zm(e);
      Object.assign([], m);
      const n = r.path(v, { roughness: 0.3, seed: c });
      ((C += ' transition'),
        (w = S(n)
          .select('path')
          .attr('id', t.id)
          .attr('class', ' ' + C + (t.classes ? ' ' + t.classes : ''))
          .attr('style', _ ? _.reduce((e, t) => e + ';' + t, '') : '')));
      let i = w.attr('d');
      (w.attr('d', i), e.node().appendChild(w.node()));
    } else {
      const r = g.join(';'),
        n = _ ? _.reduce((e, t) => e + t + ';', '') : '';
      let i = '';
      (t.animate && (i = ' edge-animation-fast'),
        t.animation && (i = ' edge-animation-' + t.animation));
      const a = (r ? r + ';' + n + ';' : n) + ';' + (_ ? _.reduce((e, t) => e + ';' + t, '') : '');
      ((w = e
        .append('path')
        .attr('d', v)
        .attr('id', t.id)
        .attr('class', ' ' + C + (t.classes ? ' ' + t.classes : '') + (i ?? ''))
        .attr('style', a)),
        (M = null == (l = a.match(/stroke:([^;]+)/)) ? void 0 : l[1]),
        (O = !0 === t.animate || !!t.animation || r.includes('animation')));
      const o = w.node(),
        s = 'function' == typeof o.getTotalLength ? o.getTotalLength() : 0,
        c = $h[t.arrowTypeStart] || 0,
        h = $h[t.arrowTypeEnd] || 0;
      if ('neo' === t.look && !O) {
        const e = `stroke-dasharray: ${'dotted' === t.pattern || 'dashed' === t.pattern ? Tx(s, c, h) : `0 ${c} ${s - c - h} ${h}`}; stroke-dashoffset: 0;`;
        w.attr('style', e + w.attr('style'));
      }
    }
    (w.attr('data-edge', !0),
      w.attr('data-et', 'edge'),
      w.attr('data-id', t.id),
      w.attr('data-points', f),
      t.showPoints &&
        m.forEach((t) => {
          e.append('circle')
            .style('stroke', 'red')
            .style('fill', 'red')
            .attr('r', 1)
            .attr('cx', t.x)
            .attr('cy', t.y);
        }));
    let $ = '';
    ((As().flowchart.arrowMarkerAbsolute || As().state.arrowMarkerAbsolute) &&
      (($ =
        window.location.protocol +
        '//' +
        window.location.host +
        window.location.pathname +
        window.location.search),
      ($ = $.replace(/\(/g, '\\(').replace(/\)/g, '\\)'))),
      si.info('arrowTypeStart', t.arrowTypeStart),
      si.info('arrowTypeEnd', t.arrowTypeEnd),
      px(w, t, $, o, n, M));
    const R = h[Math.floor(h.length / 2)];
    jp.isLabelCoordinateInPath(R, w.attr('d')) || (d = !0);
    let z = {};
    return (d && (z.updatedPath = h), (z.originalPath = t.points), z);
  }, 'insertEdge');
function Bx(e, t) {
  if (e.length < 2) return '';
  let r = '';
  const n = e.length,
    i = 1e-5;
  for (let a = 0; a < n; a++) {
    const o = e[a],
      s = e[a - 1],
      l = e[a + 1];
    if (0 === a) r += `M${o.x},${o.y}`;
    else if (a === n - 1) r += `L${o.x},${o.y}`;
    else {
      const e = o.x - s.x,
        n = o.y - s.y,
        a = l.x - o.x,
        c = l.y - o.y,
        h = Math.hypot(e, n),
        d = Math.hypot(a, c);
      if (h < i || d < i) {
        r += `L${o.x},${o.y}`;
        continue;
      }
      const u = e / h,
        p = n / h,
        g = a / d,
        f = c / d,
        m = u * g + p * f,
        b = Math.max(-1, Math.min(1, m)),
        y = Math.acos(b);
      if (y < i || Math.abs(Math.PI - y) < i) {
        r += `L${o.x},${o.y}`;
        continue;
      }
      const x = Math.min(t / Math.sin(y / 2), h / 2, d / 2),
        k = o.x - u * x,
        C = o.y - p * x,
        w = o.x + g * x,
        v = o.y + f * x;
      ((r += `L${k},${C}`), (r += `Q${o.x},${o.y} ${w},${v}`));
    }
  }
  return r;
}
function Mx(e, t) {
  if (!e || !t) return { angle: 0, deltaX: 0, deltaY: 0 };
  const r = t.x - e.x,
    n = t.y - e.y;
  return { angle: Math.atan2(n, r), deltaX: r, deltaY: n };
}
function Nx(e, t) {
  const r = e.map((e) => ({ ...e }));
  if (e.length >= 2 && Oh[t.arrowTypeStart]) {
    const n = Oh[t.arrowTypeStart],
      i = e[0],
      a = e[1],
      { angle: o } = Mx(i, a),
      s = n * Math.cos(o),
      l = n * Math.sin(o);
    ((r[0].x = i.x + s), (r[0].y = i.y + l));
  }
  const n = e.length;
  if (n >= 2 && Oh[t.arrowTypeEnd]) {
    const i = Oh[t.arrowTypeEnd],
      a = e[n - 1],
      o = e[n - 2],
      { angle: s } = Mx(o, a),
      l = i * Math.cos(s),
      c = i * Math.sin(s);
    ((r[n - 1].x = a.x - l), (r[n - 1].y = a.y - c));
  }
  return r;
}
(ii(Bx, 'generateRoundedPath'),
  ii(Mx, 'calculateDeltaAndAngle'),
  ii(Nx, 'applyMarkerOffsetsToPoints'));
var Lx = ii((e, t, r, n) => {
    t.forEach((t) => {
      Ox[t](e, r, n);
    });
  }, 'insertMarkers'),
  Ox = {
    extension: ii((e, t, r) => {
      (si.trace('Making markers for ', r),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-extensionStart')
          .attr('class', 'marker extension ' + t)
          .attr('refX', 18)
          .attr('refY', 7)
          .attr('markerWidth', 190)
          .attr('markerHeight', 240)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 1,7 L18,13 V 1 Z'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-extensionEnd')
          .attr('class', 'marker extension ' + t)
          .attr('refX', 1)
          .attr('refY', 7)
          .attr('markerWidth', 20)
          .attr('markerHeight', 28)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 1,1 V 13 L18,7 Z'));
    }, 'extension'),
    composition: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-compositionStart')
        .attr('class', 'marker composition ' + t)
        .attr('refX', 18)
        .attr('refY', 7)
        .attr('markerWidth', 190)
        .attr('markerHeight', 240)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-compositionEnd')
          .attr('class', 'marker composition ' + t)
          .attr('refX', 1)
          .attr('refY', 7)
          .attr('markerWidth', 20)
          .attr('markerHeight', 28)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'));
    }, 'composition'),
    aggregation: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-aggregationStart')
        .attr('class', 'marker aggregation ' + t)
        .attr('refX', 18)
        .attr('refY', 7)
        .attr('markerWidth', 190)
        .attr('markerHeight', 240)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-aggregationEnd')
          .attr('class', 'marker aggregation ' + t)
          .attr('refX', 1)
          .attr('refY', 7)
          .attr('markerWidth', 20)
          .attr('markerHeight', 28)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 18,7 L9,13 L1,7 L9,1 Z'));
    }, 'aggregation'),
    dependency: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-dependencyStart')
        .attr('class', 'marker dependency ' + t)
        .attr('refX', 6)
        .attr('refY', 7)
        .attr('markerWidth', 190)
        .attr('markerHeight', 240)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 5,7 L9,13 L1,7 L9,1 Z'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-dependencyEnd')
          .attr('class', 'marker dependency ' + t)
          .attr('refX', 13)
          .attr('refY', 7)
          .attr('markerWidth', 20)
          .attr('markerHeight', 28)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 18,7 L9,13 L14,7 L9,1 Z'));
    }, 'dependency'),
    lollipop: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-lollipopStart')
        .attr('class', 'marker lollipop ' + t)
        .attr('refX', 13)
        .attr('refY', 7)
        .attr('markerWidth', 190)
        .attr('markerHeight', 240)
        .attr('orient', 'auto')
        .append('circle')
        .attr('stroke', 'black')
        .attr('fill', 'transparent')
        .attr('cx', 7)
        .attr('cy', 7)
        .attr('r', 6),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-lollipopEnd')
          .attr('class', 'marker lollipop ' + t)
          .attr('refX', 1)
          .attr('refY', 7)
          .attr('markerWidth', 190)
          .attr('markerHeight', 240)
          .attr('orient', 'auto')
          .append('circle')
          .attr('stroke', 'black')
          .attr('fill', 'transparent')
          .attr('cx', 7)
          .attr('cy', 7)
          .attr('r', 6));
    }, 'lollipop'),
    point: ii((e, t, r) => {
      (e
        .append('marker')
        .attr('id', r + '_' + t + '-pointEnd')
        .attr('class', 'marker ' + t)
        .attr('viewBox', '0 0 10 10')
        .attr('refX', 5)
        .attr('refY', 5)
        .attr('markerUnits', 'userSpaceOnUse')
        .attr('markerWidth', 8)
        .attr('markerHeight', 8)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 0 0 L 10 5 L 0 10 z')
        .attr('class', 'arrowMarkerPath')
        .style('stroke-width', 1)
        .style('stroke-dasharray', '1,0'),
        e
          .append('marker')
          .attr('id', r + '_' + t + '-pointStart')
          .attr('class', 'marker ' + t)
          .attr('viewBox', '0 0 10 10')
          .attr('refX', 4.5)
          .attr('refY', 5)
          .attr('markerUnits', 'userSpaceOnUse')
          .attr('markerWidth', 8)
          .attr('markerHeight', 8)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 0 5 L 10 10 L 10 0 z')
          .attr('class', 'arrowMarkerPath')
          .style('stroke-width', 1)
          .style('stroke-dasharray', '1,0'));
    }, 'point'),
    circle: ii((e, t, r) => {
      (e
        .append('marker')
        .attr('id', r + '_' + t + '-circleEnd')
        .attr('class', 'marker ' + t)
        .attr('viewBox', '0 0 10 10')
        .attr('refX', 11)
        .attr('refY', 5)
        .attr('markerUnits', 'userSpaceOnUse')
        .attr('markerWidth', 11)
        .attr('markerHeight', 11)
        .attr('orient', 'auto')
        .append('circle')
        .attr('cx', '5')
        .attr('cy', '5')
        .attr('r', '5')
        .attr('class', 'arrowMarkerPath')
        .style('stroke-width', 1)
        .style('stroke-dasharray', '1,0'),
        e
          .append('marker')
          .attr('id', r + '_' + t + '-circleStart')
          .attr('class', 'marker ' + t)
          .attr('viewBox', '0 0 10 10')
          .attr('refX', -1)
          .attr('refY', 5)
          .attr('markerUnits', 'userSpaceOnUse')
          .attr('markerWidth', 11)
          .attr('markerHeight', 11)
          .attr('orient', 'auto')
          .append('circle')
          .attr('cx', '5')
          .attr('cy', '5')
          .attr('r', '5')
          .attr('class', 'arrowMarkerPath')
          .style('stroke-width', 1)
          .style('stroke-dasharray', '1,0'));
    }, 'circle'),
    cross: ii((e, t, r) => {
      (e
        .append('marker')
        .attr('id', r + '_' + t + '-crossEnd')
        .attr('class', 'marker cross ' + t)
        .attr('viewBox', '0 0 11 11')
        .attr('refX', 12)
        .attr('refY', 5.2)
        .attr('markerUnits', 'userSpaceOnUse')
        .attr('markerWidth', 11)
        .attr('markerHeight', 11)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
        .attr('class', 'arrowMarkerPath')
        .style('stroke-width', 2)
        .style('stroke-dasharray', '1,0'),
        e
          .append('marker')
          .attr('id', r + '_' + t + '-crossStart')
          .attr('class', 'marker cross ' + t)
          .attr('viewBox', '0 0 11 11')
          .attr('refX', -1)
          .attr('refY', 5.2)
          .attr('markerUnits', 'userSpaceOnUse')
          .attr('markerWidth', 11)
          .attr('markerHeight', 11)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M 1,1 l 9,9 M 10,1 l -9,9')
          .attr('class', 'arrowMarkerPath')
          .style('stroke-width', 2)
          .style('stroke-dasharray', '1,0'));
    }, 'cross'),
    barb: ii((e, t, r) => {
      e.append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-barbEnd')
        .attr('refX', 19)
        .attr('refY', 7)
        .attr('markerWidth', 20)
        .attr('markerHeight', 14)
        .attr('markerUnits', 'userSpaceOnUse')
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M 19,7 L9,13 L14,7 L9,1 Z');
    }, 'barb'),
    only_one: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-onlyOneStart')
        .attr('class', 'marker onlyOne ' + t)
        .attr('refX', 0)
        .attr('refY', 9)
        .attr('markerWidth', 18)
        .attr('markerHeight', 18)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M9,0 L9,18 M15,0 L15,18'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-onlyOneEnd')
          .attr('class', 'marker onlyOne ' + t)
          .attr('refX', 18)
          .attr('refY', 9)
          .attr('markerWidth', 18)
          .attr('markerHeight', 18)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M3,0 L3,18 M9,0 L9,18'));
    }, 'only_one'),
    zero_or_one: ii((e, t, r) => {
      const n = e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-zeroOrOneStart')
        .attr('class', 'marker zeroOrOne ' + t)
        .attr('refX', 0)
        .attr('refY', 9)
        .attr('markerWidth', 30)
        .attr('markerHeight', 18)
        .attr('orient', 'auto');
      (n.append('circle').attr('fill', 'white').attr('cx', 21).attr('cy', 9).attr('r', 6),
        n.append('path').attr('d', 'M9,0 L9,18'));
      const i = e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-zeroOrOneEnd')
        .attr('class', 'marker zeroOrOne ' + t)
        .attr('refX', 30)
        .attr('refY', 9)
        .attr('markerWidth', 30)
        .attr('markerHeight', 18)
        .attr('orient', 'auto');
      (i.append('circle').attr('fill', 'white').attr('cx', 9).attr('cy', 9).attr('r', 6),
        i.append('path').attr('d', 'M21,0 L21,18'));
    }, 'zero_or_one'),
    one_or_more: ii((e, t, r) => {
      (e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-oneOrMoreStart')
        .attr('class', 'marker oneOrMore ' + t)
        .attr('refX', 18)
        .attr('refY', 18)
        .attr('markerWidth', 45)
        .attr('markerHeight', 36)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27'),
        e
          .append('defs')
          .append('marker')
          .attr('id', r + '_' + t + '-oneOrMoreEnd')
          .attr('class', 'marker oneOrMore ' + t)
          .attr('refX', 27)
          .attr('refY', 18)
          .attr('markerWidth', 45)
          .attr('markerHeight', 36)
          .attr('orient', 'auto')
          .append('path')
          .attr('d', 'M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18'));
    }, 'one_or_more'),
    zero_or_more: ii((e, t, r) => {
      const n = e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-zeroOrMoreStart')
        .attr('class', 'marker zeroOrMore ' + t)
        .attr('refX', 18)
        .attr('refY', 18)
        .attr('markerWidth', 57)
        .attr('markerHeight', 36)
        .attr('orient', 'auto');
      (n.append('circle').attr('fill', 'white').attr('cx', 48).attr('cy', 18).attr('r', 6),
        n.append('path').attr('d', 'M0,18 Q18,0 36,18 Q18,36 0,18'));
      const i = e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-zeroOrMoreEnd')
        .attr('class', 'marker zeroOrMore ' + t)
        .attr('refX', 39)
        .attr('refY', 18)
        .attr('markerWidth', 57)
        .attr('markerHeight', 36)
        .attr('orient', 'auto');
      (i.append('circle').attr('fill', 'white').attr('cx', 9).attr('cy', 18).attr('r', 6),
        i.append('path').attr('d', 'M21,18 Q39,0 57,18 Q39,36 21,18'));
    }, 'zero_or_more'),
    requirement_arrow: ii((e, t, r) => {
      e.append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-requirement_arrowEnd')
        .attr('refX', 20)
        .attr('refY', 10)
        .attr('markerWidth', 20)
        .attr('markerHeight', 20)
        .attr('orient', 'auto')
        .append('path')
        .attr('d', 'M0,0\n      L20,10\n      M20,10\n      L0,20');
    }, 'requirement_arrow'),
    requirement_contains: ii((e, t, r) => {
      const n = e
        .append('defs')
        .append('marker')
        .attr('id', r + '_' + t + '-requirement_containsStart')
        .attr('refX', 0)
        .attr('refY', 10)
        .attr('markerWidth', 20)
        .attr('markerHeight', 20)
        .attr('orient', 'auto')
        .append('g');
      (n.append('circle').attr('cx', 10).attr('cy', 10).attr('r', 9).attr('fill', 'none'),
        n.append('line').attr('x1', 1).attr('x2', 19).attr('y1', 10).attr('y2', 10),
        n.append('line').attr('y1', 1).attr('y2', 19).attr('x1', 10).attr('x2', 10));
    }, 'requirement_contains'),
  },
  $x = Lx,
  Ix = {
    common: as,
    getConfig: _o,
    insertCluster: pb,
    insertEdge: Fx,
    insertEdgeLabel: kx,
    insertMarkers: $x,
    insertNode: cx,
    interpolateToCurve: up,
    labelHelper: Km,
    log: si,
    positionEdgeLabel: wx,
  },
  Rx = {},
  zx = ii((e) => {
    for (const t of e) Rx[t.name] = t;
  }, 'registerLayoutLoaders');
ii(() => {
  zx([
    {
      name: 'dagre',
      loader: ii(
        async () =>
          await v(
            () => import('./dagre-6UL2VRFP-DnnxFcWZ.js'),
            __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
          ),
        'loader'
      ),
    },
    {
      name: 'cose-bilkent',
      loader: ii(
        async () =>
          await v(
            () => import('./cose-bilkent-S5V4N54A-D0_Goe5Y.js'),
            __vite__mapDeps([12, 13, 7, 10, 6, 8, 9, 11])
          ),
        'loader'
      ),
    },
  ]);
}, 'registerDefaultLayoutLoaders')();
var Px = ii(async (e, t) => {
    if (!(e.layoutAlgorithm in Rx))
      throw new Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`);
    const r = Rx[e.layoutAlgorithm];
    return (await r.loader()).render(e, t, Ix, { algorithm: r.algorithm });
  }, 'render'),
  jx = ii((e = '', { fallback: t = 'dagre' } = {}) => {
    if (e in Rx) return e;
    if (t in Rx)
      return (si.warn(`Layout algorithm ${e} is not registered. Using ${t} as fallback.`), t);
    throw new Error(`Both layout algorithms ${e} and ${t} are not registered.`);
  }, 'getRegisteredLayoutAlgorithm'),
  qx = 'comm',
  Wx = 'rule',
  Ux = 'decl',
  Hx = Math.abs,
  Gx = String.fromCharCode;
function Vx(e) {
  return e.trim();
}
function Zx(e, t, r) {
  return e.replace(t, r);
}
function Kx(e, t, r) {
  return e.indexOf(t, r);
}
function Yx(e, t) {
  return 0 | e.charCodeAt(t);
}
function Xx(e, t, r) {
  return e.slice(t, r);
}
function Qx(e) {
  return e.length;
}
function Jx(e, t) {
  return (t.push(e), e);
}
var ek = 1,
  tk = 1,
  rk = 0,
  nk = 0,
  ik = 0,
  ak = '';
function ok(e, t, r, n, i, a, o, s) {
  return {
    value: e,
    root: t,
    parent: r,
    type: n,
    props: i,
    children: a,
    line: ek,
    column: tk,
    length: o,
    return: '',
    siblings: s,
  };
}
function sk() {
  return ((ik = nk > 0 ? Yx(ak, --nk) : 0), tk--, 10 === ik && ((tk = 1), ek--), ik);
}
function lk() {
  return ((ik = nk < rk ? Yx(ak, nk++) : 0), tk++, 10 === ik && ((tk = 1), ek++), ik);
}
function ck() {
  return Yx(ak, nk);
}
function hk() {
  return nk;
}
function dk(e, t) {
  return Xx(ak, e, t);
}
function uk(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function pk(e) {
  return Vx(dk(nk - 1, mk(91 === e ? e + 2 : 40 === e ? e + 1 : e)));
}
function gk(e) {
  for (; (ik = ck()) && ik < 33; ) lk();
  return uk(e) > 2 || uk(ik) > 3 ? '' : ' ';
}
function fk(e, t) {
  for (; --t && lk() && !(ik < 48 || ik > 102 || (ik > 57 && ik < 65) || (ik > 70 && ik < 97)); );
  return dk(e, hk() + (t < 6 && 32 == ck() && 32 == lk()));
}
function mk(e) {
  for (; lk(); )
    switch (ik) {
      case e:
        return nk;
      case 34:
      case 39:
        34 !== e && 39 !== e && mk(ik);
        break;
      case 40:
        41 === e && mk(e);
        break;
      case 92:
        lk();
    }
  return nk;
}
function bk(e, t) {
  for (; lk() && e + ik !== 57 && (e + ik !== 84 || 47 !== ck()); );
  return '/*' + dk(t, nk - 1) + '*' + Gx(47 === e ? e : lk());
}
function yk(e) {
  for (; !uk(ck()); ) lk();
  return dk(e, nk);
}
function xk(e) {
  return (function (e) {
    return ((ak = ''), e);
  })(
    kk(
      '',
      null,
      null,
      null,
      [''],
      (e = (function (e) {
        return ((ek = tk = 1), (rk = Qx((ak = e))), (nk = 0), []);
      })(e)),
      0,
      [0],
      e
    )
  );
}
function kk(e, t, r, n, i, a, o, s, l) {
  for (
    var c = 0,
      h = 0,
      d = o,
      u = 0,
      p = 0,
      g = 0,
      f = 1,
      m = 1,
      b = 1,
      y = 0,
      x = '',
      k = i,
      C = a,
      w = n,
      v = x;
    m;
  )
    switch (((g = y), (y = lk()))) {
      case 40:
        if (108 != g && 58 == Yx(v, d - 1)) {
          -1 != Kx((v += Zx(pk(y), '&', '&\f')), '&\f', Hx(c ? s[c - 1] : 0)) && (b = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        v += pk(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        v += gk(g);
        break;
      case 92:
        v += fk(hk() - 1, 7);
        continue;
      case 47:
        switch (ck()) {
          case 42:
          case 47:
            (Jx(wk(bk(lk(), hk()), t, r, l), l),
              (5 != uk(g || 1) && 5 != uk(ck() || 1)) ||
                !Qx(v) ||
                ' ' === Xx(v, -1, void 0) ||
                (v += ' '));
            break;
          default:
            v += '/';
        }
        break;
      case 123 * f:
        s[c++] = Qx(v) * b;
      case 125 * f:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            m = 0;
          case 59 + h:
            (-1 == b && (v = Zx(v, /\f/g, '')),
              p > 0 &&
                (Qx(v) - d || (0 === f && 47 === g)) &&
                Jx(
                  p > 32 ? vk(v + ';', n, r, d - 1, l) : vk(Zx(v, ' ', '') + ';', n, r, d - 2, l),
                  l
                ));
            break;
          case 59:
            v += ';';
          default:
            if ((Jx((w = Ck(v, t, r, c, h, i, s, x, (k = []), (C = []), d, a)), a), 123 === y))
              if (0 === h) kk(v, t, w, w, k, a, d, s, C);
              else {
                switch (u) {
                  case 99:
                    if (110 === Yx(v, 3)) break;
                  case 108:
                    if (97 === Yx(v, 2)) break;
                  default:
                    h = 0;
                  case 100:
                  case 109:
                  case 115:
                }
                h
                  ? kk(
                      e,
                      w,
                      w,
                      n && Jx(Ck(e, w, w, 0, 0, i, s, x, i, (k = []), d, C), C),
                      i,
                      C,
                      d,
                      s,
                      n ? k : C
                    )
                  : kk(v, w, w, w, [''], C, 0, s, C);
              }
        }
        ((c = h = p = 0), (f = b = 1), (x = v = ''), (d = o));
        break;
      case 58:
        ((d = 1 + Qx(v)), (p = g));
      default:
        if (f < 1)
          if (123 == y) --f;
          else if (125 == y && 0 == f++ && 125 == sk()) continue;
        switch (((v += Gx(y)), y * f)) {
          case 38:
            b = h > 0 ? 1 : ((v += '\f'), -1);
            break;
          case 44:
            ((s[c++] = (Qx(v) - 1) * b), (b = 1));
            break;
          case 64:
            (45 === ck() && (v += pk(lk())), (u = ck()), (h = d = Qx((x = v += yk(hk())))), y++);
            break;
          case 45:
            45 === g && 2 == Qx(v) && (f = 0);
        }
    }
  return a;
}
function Ck(e, t, r, n, i, a, o, s, l, c, h, d) {
  for (
    var u = i - 1,
      p = 0 === i ? a : [''],
      g = (function (e) {
        return e.length;
      })(p),
      f = 0,
      m = 0,
      b = 0;
    f < n;
    ++f
  )
    for (var y = 0, x = Xx(e, u + 1, (u = Hx((m = o[f])))), k = e; y < g; ++y)
      (k = Vx(m > 0 ? p[y] + ' ' + x : Zx(x, /&\f/g, p[y]))) && (l[b++] = k);
  return ok(e, t, r, 0 === i ? Wx : s, l, c, h, d);
}
function wk(e, t, r, n) {
  return ok(e, t, r, qx, Gx(ik), Xx(e, 2, -2), 0, n);
}
function vk(e, t, r, n, i) {
  return ok(e, t, r, Ux, Xx(e, 0, n), Xx(e, n + 1, -1), n, i);
}
function _k(e, t) {
  for (var r = '', n = 0; n < e.length; n++) r += t(e[n], n, e, t) || '';
  return r;
}
function Sk(e, t, r, n) {
  switch (e.type) {
    case '@layer':
      if (e.children.length) break;
    case '@import':
    case '@namespace':
    case Ux:
      return (e.return = e.return || e.value);
    case qx:
      return '';
    case '@keyframes':
      return (e.return = e.value + '{' + _k(e.children, n) + '}');
    case Wx:
      if (!Qx((e.value = e.props.join(',')))) return '';
  }
  return Qx((r = _k(e.children, n))) ? (e.return = e.value + '{' + r + '}') : '';
}
var Ek = eu(Object.keys, Object),
  Dk = Object.prototype.hasOwnProperty;
function Ak(e) {
  if (!nu(e)) return Ek(e);
  var t = [];
  for (var r in Object(e)) Dk.call(e, r) && 'constructor' != r && t.push(r);
  return t;
}
var Tk = Sd(rd, 'DataView'),
  Fk = Sd(rd, 'Promise'),
  Bk = Sd(rd, 'Set'),
  Mk = Sd(rd, 'WeakMap'),
  Nk = '[object Map]',
  Lk = '[object Promise]',
  Ok = '[object Set]',
  $k = '[object WeakMap]',
  Ik = '[object DataView]',
  Rk = bd(Tk),
  zk = bd(Ld),
  Pk = bd(Fk),
  jk = bd(Bk),
  qk = bd(Mk),
  Wk = hd;
((Tk && Wk(new Tk(new ArrayBuffer(1))) != Ik) ||
  (Ld && Wk(new Ld()) != Nk) ||
  (Fk && Wk(Fk.resolve()) != Lk) ||
  (Bk && Wk(new Bk()) != Ok) ||
  (Mk && Wk(new Mk()) != $k)) &&
  (Wk = function (e) {
    var t = hd(e),
      r = '[object Object]' == t ? e.constructor : void 0,
      n = r ? bd(r) : '';
    if (n)
      switch (n) {
        case Rk:
          return Ik;
        case zk:
          return Nk;
        case Pk:
          return Lk;
        case jk:
          return Ok;
        case qk:
          return $k;
      }
    return t;
  });
var Uk = Object.prototype.hasOwnProperty;
function Hk(e) {
  if (null == e) return !0;
  if (
    pu(e) &&
    (du(e) || 'string' == typeof e || 'function' == typeof e.splice || yu(e) || Bu(e) || hu(e))
  )
    return !e.length;
  var t = Wk(e);
  if ('[object Map]' == t || '[object Set]' == t) return !e.size;
  if (nu(e)) return !Ak(e).length;
  for (var r in e) if (Uk.call(e, r)) return !1;
  return !0;
}
var Gk = {
    id: 'c4',
    detector: ii(
      (e) => /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e),
      'detector'
    ),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./c4Diagram-YG6GDRKO-DPaNDk9m.js');
          return { diagram: e };
        },
        __vite__mapDeps([14, 15, 10, 7, 6, 8, 9, 11])
      );
      return { id: 'c4', diagram: e };
    }, 'loader'),
  },
  Vk = 'flowchart',
  Zk = {
    id: Vk,
    detector: ii((e, t) => {
      var r, n;
      return (
        'dagre-wrapper' !==
          (null == (r = null == t ? void 0 : t.flowchart) ? void 0 : r.defaultRenderer) &&
        'elk' !== (null == (n = null == t ? void 0 : t.flowchart) ? void 0 : n.defaultRenderer) &&
        /^\s*graph/.test(e)
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./flowDiagram-NV44I4VS-CAsIbosh.js');
          return { diagram: e };
        },
        __vite__mapDeps([16, 17, 18, 10, 7, 6, 19, 20, 8, 9, 11])
      );
      return { id: Vk, diagram: e };
    }, 'loader'),
  },
  Kk = 'flowchart-v2',
  Yk = {
    id: Kk,
    detector: ii((e, t) => {
      var r, n, i;
      return (
        'dagre-d3' !==
          (null == (r = null == t ? void 0 : t.flowchart) ? void 0 : r.defaultRenderer) &&
        ('elk' === (null == (n = null == t ? void 0 : t.flowchart) ? void 0 : n.defaultRenderer) &&
          (t.layout = 'elk'),
        !(
          !/^\s*graph/.test(e) ||
          'dagre-wrapper' !==
            (null == (i = null == t ? void 0 : t.flowchart) ? void 0 : i.defaultRenderer)
        ) || /^\s*flowchart/.test(e))
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./flowDiagram-NV44I4VS-CAsIbosh.js');
          return { diagram: e };
        },
        __vite__mapDeps([16, 17, 18, 10, 7, 6, 19, 20, 8, 9, 11])
      );
      return { id: Kk, diagram: e };
    }, 'loader'),
  },
  Xk = {
    id: 'er',
    detector: ii((e) => /^\s*erDiagram/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./erDiagram-Q2GNP2WA-C1DitjC6.js');
          return { diagram: e };
        },
        __vite__mapDeps([21, 18, 10, 7, 6, 19, 20, 8, 9, 11])
      );
      return { id: 'er', diagram: e };
    }, 'loader'),
  },
  Qk = 'gitGraph',
  Jk = {
    id: Qk,
    detector: ii((e) => /^\s*gitGraph/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./gitGraphDiagram-NY62KEGX-lP50St_b.js');
          return { diagram: e };
        },
        __vite__mapDeps([22, 23, 24, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: Qk, diagram: e };
    }, 'loader'),
  },
  eC = 'gantt',
  tC = {
    id: eC,
    detector: ii((e) => /^\s*gantt/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./ganttDiagram-JELNMOA3-BYzjaFvD.js');
          return { diagram: e };
        },
        __vite__mapDeps([26, 7, 10, 6, 8, 9, 11])
      );
      return { id: eC, diagram: e };
    }, 'loader'),
  },
  rC = 'info',
  nC = {
    id: rC,
    detector: ii((e) => /^\s*info/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./infoDiagram-WHAUD3N6-CefxpB2b.js');
          return { diagram: e };
        },
        __vite__mapDeps([27, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: rC, diagram: e };
    }, 'loader'),
  },
  iC = {
    id: 'pie',
    detector: ii((e) => /^\s*pie/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./pieDiagram-ADFJNKIX-242Nj-Xj.js');
          return { diagram: e };
        },
        __vite__mapDeps([28, 23, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: 'pie', diagram: e };
    }, 'loader'),
  },
  aC = 'quadrantChart',
  oC = {
    id: aC,
    detector: ii((e) => /^\s*quadrantChart/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./quadrantDiagram-AYHSOK5B-D3JtUApC.js');
          return { diagram: e };
        },
        __vite__mapDeps([29, 10, 7, 6, 8, 9, 11])
      );
      return { id: aC, diagram: e };
    }, 'loader'),
  },
  sC = 'xychart',
  lC = {
    id: sC,
    detector: ii((e) => /^\s*xychart(-beta)?/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./xychartDiagram-PRI3JC2R-c2uxP9ZU.js');
          return { diagram: e };
        },
        __vite__mapDeps([30, 10, 7, 6, 8, 9, 11])
      );
      return { id: sC, diagram: e };
    }, 'loader'),
  },
  cC = 'requirement',
  hC = {
    id: cC,
    detector: ii((e) => /^\s*requirement(Diagram)?/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./requirementDiagram-UZGBJVZJ-guiN45tV.js');
          return { diagram: e };
        },
        __vite__mapDeps([31, 18, 10, 7, 6, 19, 8, 9, 11])
      );
      return { id: cC, diagram: e };
    }, 'loader'),
  },
  dC = 'sequence',
  uC = {
    id: dC,
    detector: ii((e) => /^\s*sequenceDiagram/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./sequenceDiagram-WL72ISMW-hXFpyQEg.js');
          return { diagram: e };
        },
        __vite__mapDeps([32, 15, 24, 10, 7, 6, 8, 9, 11])
      );
      return { id: dC, diagram: e };
    }, 'loader'),
  },
  pC = 'class',
  gC = {
    id: pC,
    detector: ii((e, t) => {
      var r;
      return (
        'dagre-wrapper' !==
          (null == (r = null == t ? void 0 : t.class) ? void 0 : r.defaultRenderer) &&
        /^\s*classDiagram/.test(e)
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./classDiagram-2ON5EDUG-CB9dv5mA.js');
          return { diagram: e };
        },
        __vite__mapDeps([33, 34, 17, 18, 10, 7, 6, 19, 8, 9, 11])
      );
      return { id: pC, diagram: e };
    }, 'loader'),
  },
  fC = 'classDiagram',
  mC = {
    id: fC,
    detector: ii((e, t) => {
      var r;
      return (
        !(
          !/^\s*classDiagram/.test(e) ||
          'dagre-wrapper' !==
            (null == (r = null == t ? void 0 : t.class) ? void 0 : r.defaultRenderer)
        ) || /^\s*classDiagram-v2/.test(e)
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./classDiagram-v2-WZHVMYZB-CB9dv5mA.js');
          return { diagram: e };
        },
        __vite__mapDeps([35, 34, 17, 18, 10, 7, 6, 19, 8, 9, 11])
      );
      return { id: fC, diagram: e };
    }, 'loader'),
  },
  bC = 'state',
  yC = {
    id: bC,
    detector: ii((e, t) => {
      var r;
      return (
        'dagre-wrapper' !==
          (null == (r = null == t ? void 0 : t.state) ? void 0 : r.defaultRenderer) &&
        /^\s*stateDiagram/.test(e)
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./stateDiagram-FKZM4ZOC-D0MynZ2i.js');
          return { diagram: e };
        },
        __vite__mapDeps([36, 37, 18, 10, 7, 6, 19, 1, 2, 3, 4, 8, 9, 11])
      );
      return { id: bC, diagram: e };
    }, 'loader'),
  },
  xC = 'stateDiagram',
  kC = {
    id: xC,
    detector: ii((e, t) => {
      var r;
      return (
        !!/^\s*stateDiagram-v2/.test(e) ||
        !(
          !/^\s*stateDiagram/.test(e) ||
          'dagre-wrapper' !==
            (null == (r = null == t ? void 0 : t.state) ? void 0 : r.defaultRenderer)
        )
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./stateDiagram-v2-4FDKWEC3-CPSN-VYh.js');
          return { diagram: e };
        },
        __vite__mapDeps([38, 37, 18, 10, 7, 6, 19, 8, 9, 11])
      );
      return { id: xC, diagram: e };
    }, 'loader'),
  },
  CC = 'journey',
  wC = {
    id: CC,
    detector: ii((e) => /^\s*journey/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./journeyDiagram-XKPGCS4Q-jxYV86WG.js');
          return { diagram: e };
        },
        __vite__mapDeps([39, 15, 17, 10, 7, 6, 8, 9, 11])
      );
      return { id: CC, diagram: e };
    }, 'loader'),
  },
  vC = {
    draw: ii((e, t, r) => {
      si.debug('rendering svg for syntax error\n');
      const n = Rs(t),
        i = n.append('g');
      (n.attr('viewBox', '0 0 2412 512'),
        ls(n, 100, 512, !0),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z'
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z'
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z'
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z'
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z'
          ),
        i
          .append('path')
          .attr('class', 'error-icon')
          .attr(
            'd',
            'm436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z'
          ),
        i
          .append('text')
          .attr('class', 'error-text')
          .attr('x', 1440)
          .attr('y', 250)
          .attr('font-size', '150px')
          .style('text-anchor', 'middle')
          .text('Syntax error in text'),
        i
          .append('text')
          .attr('class', 'error-text')
          .attr('x', 1250)
          .attr('y', 400)
          .attr('font-size', '100px')
          .style('text-anchor', 'middle')
          .text(`mermaid version ${r}`));
    }, 'draw'),
  },
  _C = vC,
  SC = { db: {}, renderer: vC, parser: { parse: ii(() => {}, 'parse') } },
  EC = 'flowchart-elk',
  DC = {
    id: EC,
    detector: ii((e, t = {}) => {
      var r;
      return (
        !!(
          /^\s*flowchart-elk/.test(e) ||
          (/^\s*(flowchart|graph)/.test(e) &&
            'elk' === (null == (r = null == t ? void 0 : t.flowchart) ? void 0 : r.defaultRenderer))
        ) && ((t.layout = 'elk'), !0)
      );
    }, 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./flowDiagram-NV44I4VS-CAsIbosh.js');
          return { diagram: e };
        },
        __vite__mapDeps([16, 17, 18, 10, 7, 6, 19, 20, 8, 9, 11])
      );
      return { id: EC, diagram: e };
    }, 'loader'),
  },
  AC = 'timeline',
  TC = {
    id: AC,
    detector: ii((e) => /^\s*timeline/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./timeline-definition-IT6M3QCI-BS2lZn0_.js');
          return { diagram: e };
        },
        __vite__mapDeps([40, 10, 7, 6, 8, 9, 11])
      );
      return { id: AC, diagram: e };
    }, 'loader'),
  },
  FC = 'mindmap',
  BC = {
    id: FC,
    detector: ii((e) => /^\s*mindmap/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./mindmap-definition-VGOIOE7T-CyMgk9Ca.js');
          return { diagram: e };
        },
        __vite__mapDeps([41, 18, 10, 7, 6, 19, 8, 9, 11])
      );
      return { id: FC, diagram: e };
    }, 'loader'),
  },
  MC = 'kanban',
  NC = {
    id: MC,
    detector: ii((e) => /^\s*kanban/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./kanban-definition-3W4ZIXB7-BAvfGnhN.js');
          return { diagram: e };
        },
        __vite__mapDeps([42, 17, 6, 7, 8, 9, 10, 11])
      );
      return { id: MC, diagram: e };
    }, 'loader'),
  },
  LC = 'sankey',
  OC = {
    id: LC,
    detector: ii((e) => /^\s*sankey(-beta)?/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./sankeyDiagram-TZEHDZUN-CYgebI4c.js');
          return { diagram: e };
        },
        __vite__mapDeps([43, 10, 7, 6, 8, 9, 11])
      );
      return { id: LC, diagram: e };
    }, 'loader'),
  },
  $C = 'packet',
  IC = {
    id: $C,
    detector: ii((e) => /^\s*packet(-beta)?/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./diagram-S2PKOQOG-Vh_aATIf.js');
          return { diagram: e };
        },
        __vite__mapDeps([44, 23, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: $C, diagram: e };
    }, 'loader'),
  },
  RC = 'radar',
  zC = {
    id: RC,
    detector: ii((e) => /^\s*radar-beta/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./diagram-QEK2KX5R-yi2SO2dh.js');
          return { diagram: e };
        },
        __vite__mapDeps([45, 23, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: RC, diagram: e };
    }, 'loader'),
  },
  PC = 'block',
  jC = {
    id: PC,
    detector: ii((e) => /^\s*block(-beta)?/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./blockDiagram-VD42YOAC-BL-PoLRm.js');
          return { diagram: e };
        },
        __vite__mapDeps([46, 17, 5, 2, 10, 7, 6, 1, 20, 8, 9, 11])
      );
      return { id: PC, diagram: e };
    }, 'loader'),
  },
  qC = 'architecture',
  WC = {
    id: qC,
    detector: ii((e) => /^\s*architecture/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./architectureDiagram-VXUJARFQ-BNglibIs.js');
          return { diagram: e };
        },
        __vite__mapDeps([47, 23, 25, 8, 6, 7, 9, 2, 4, 5, 13, 10, 11])
      );
      return { id: qC, diagram: e };
    }, 'loader'),
  },
  UC = 'treemap',
  HC = {
    id: UC,
    detector: ii((e) => /^\s*treemap/.test(e), 'detector'),
    loader: ii(async () => {
      const { diagram: e } = await v(
        async () => {
          const { diagram: e } = await import('./diagram-PSM6KHXK-B1Y5e2Qd.js');
          return { diagram: e };
        },
        __vite__mapDeps([48, 19, 23, 25, 8, 6, 7, 9, 2, 4, 5, 10, 11])
      );
      return { id: UC, diagram: e };
    }, 'loader'),
  },
  GC = !1,
  VC = ii(() => {
    GC ||
      ((GC = !0),
      Os('error', SC, (e) => 'error' === e.toLowerCase().trim()),
      Os(
        '---',
        {
          db: { clear: ii(() => {}, 'clear') },
          styles: {},
          renderer: { draw: ii(() => {}, 'draw') },
          parser: {
            parse: ii(() => {
              throw new Error(
                "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
              );
            }, 'parse'),
          },
          init: ii(() => null, 'init'),
        },
        (e) => e.toLowerCase().trimStart().startsWith('---')
      ),
      qa(DC, BC, WC),
      qa(
        Gk,
        NC,
        mC,
        gC,
        Xk,
        tC,
        nC,
        iC,
        hC,
        uC,
        Yk,
        Zk,
        TC,
        Jk,
        kC,
        yC,
        wC,
        oC,
        OC,
        IC,
        lC,
        jC,
        zC,
        HC
      ));
  }, 'addDiagrams'),
  ZC = ii(async () => {
    si.debug('Loading registered diagrams');
    const e = (
      await Promise.allSettled(
        Object.entries(Pa).map(async ([e, { detector: t, loader: r }]) => {
          if (r)
            try {
              $s(e);
            } catch {
              try {
                const { diagram: e, id: n } = await r();
                Os(n, e, t);
              } catch (n) {
                throw (
                  si.error(
                    `Failed to load external diagram with key ${e}. Removing from detectors.`
                  ),
                  delete Pa[e],
                  n
                );
              }
            }
        })
      )
    ).filter((e) => 'rejected' === e.status);
    if (e.length > 0) {
      si.error(`Failed to load ${e.length} external diagrams`);
      for (const t of e) si.error(t);
      throw new Error(`Failed to load ${e.length} external diagrams`);
    }
  }, 'loadRegisteredDiagrams');
function KC(e, t) {
  (e.attr('role', 'graphics-document document'), '' !== t && e.attr('aria-roledescription', t));
}
function YC(e, t, r, n) {
  if (void 0 !== e.insert) {
    if (r) {
      const t = `chart-desc-${n}`;
      (e.attr('aria-describedby', t), e.insert('desc', ':first-child').attr('id', t).text(r));
    }
    if (t) {
      const r = `chart-title-${n}`;
      (e.attr('aria-labelledby', r), e.insert('title', ':first-child').attr('id', r).text(t));
    }
  }
}
(ii(KC, 'setA11yDiagramInfo'), ii(YC, 'addSVGa11yTitleDescription'));
var XC =
    (ii(
      (c = class {
        constructor(e, t, r, n, i) {
          ((this.type = e), (this.text = t), (this.db = r), (this.parser = n), (this.renderer = i));
        }
        static async fromText(e, t = {}) {
          var r, n;
          const i = _o(),
            a = ja(e, i);
          e = qp(e) + '\n';
          try {
            $s(a);
          } catch {
            const e = Ua(a);
            if (!e) throw new za(`Diagram ${a} not found.`);
            const { id: t, diagram: r } = await e();
            Os(t, r);
          }
          const { db: o, parser: s, renderer: l, init: h } = $s(a);
          return (
            s.parser && (s.parser.yy = o),
            null == (r = o.clear) || r.call(o),
            null == h || h(i),
            t.title && (null == (n = o.setDiagramTitle) || n.call(o, t.title)),
            await s.parse(e),
            new c(a, e, o, s, l)
          );
        }
        async render(e, t) {
          await this.renderer.draw(this.text, e, t, this);
        }
        getParser() {
          return this.parser;
        }
        getType() {
          return this.type;
        }
      }),
      'Diagram'
    ),
    c),
  QC = [],
  JC = ii(() => {
    (QC.forEach((e) => {
      e();
    }),
      (QC = []));
  }, 'attachFunctions'),
  ew = ii((e) => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, '').trimStart(), 'cleanupComments');
function tw(e) {
  const t = e.match($a);
  if (!t) return { text: e, metadata: {} };
  let r = Lh(t[1], { schema: Nh }) ?? {};
  r = 'object' != typeof r || Array.isArray(r) ? {} : r;
  const n = {};
  return (
    r.displayMode && (n.displayMode = r.displayMode.toString()),
    r.title && (n.title = r.title.toString()),
    r.config && (n.config = r.config),
    { text: e.slice(t[0].length), metadata: n }
  );
}
ii(tw, 'extractFrontMatter');
var rw = ii(
    (e) =>
      e
        .replace(/\r\n?/g, '\n')
        .replace(/<(\w+)([^>]*)>/g, (e, t, r) => '<' + t + r.replace(/="([^"]*)"/g, "='$1'") + '>'),
    'cleanupText'
  ),
  nw = ii((e) => {
    const { text: t, metadata: r } = tw(e),
      { displayMode: n, title: i, config: a = {} } = r;
    return (
      n && (a.gantt || (a.gantt = {}), (a.gantt.displayMode = n)),
      { title: i, config: a, text: t }
    );
  }, 'processFrontmatter'),
  iw = ii((e) => {
    const t = jp.detectInit(e) ?? {},
      r = jp.detectDirective(e, 'wrap');
    return (
      Array.isArray(r)
        ? (t.wrap = r.some(({ type: e }) => 'wrap' === e))
        : 'wrap' === (null == r ? void 0 : r.type) && (t.wrap = !0),
      { text: hp(e), directive: t }
    );
  }, 'processDirectives');
function aw(e) {
  const t = rw(e),
    r = nw(t),
    n = iw(r.text),
    i = Pp(r.config, n.directive);
  return { code: (e = ew(n.text)), title: r.title, config: i };
}
function ow(e) {
  const t = new TextEncoder().encode(e),
    r = Array.from(t, (e) => String.fromCodePoint(e)).join('');
  return btoa(r);
}
(ii(aw, 'preprocessDiagram'), ii(ow, 'toBase64'));
var sw = ['foreignobject'],
  lw = ['dominant-baseline'];
function cw(e) {
  const t = aw(e);
  return (Do(), Eo(t.config ?? {}), t);
}
async function hw(e, t) {
  VC();
  try {
    const { code: t, config: r } = cw(e);
    return { diagramType: (await Cw(t)).type, config: r };
  } catch (r) {
    if (null == t ? void 0 : t.suppressErrors) return !1;
    throw r;
  }
}
(ii(cw, 'processAndSetConfigs'), ii(hw, 'parse'));
var dw = ii(
    (e, t, r = []) => `\n.${e} ${t} { ${r.join(' !important; ')} !important; }`,
    'cssImportantStyles'
  ),
  uw = ii((e, t = new Map()) => {
    var r;
    let n = '';
    if (
      (void 0 !== e.themeCSS && (n += `\n${e.themeCSS}`),
      void 0 !== e.fontFamily && (n += `\n:root { --mermaid-font-family: ${e.fontFamily}}`),
      void 0 !== e.altFontFamily &&
        (n += `\n:root { --mermaid-alt-font-family: ${e.altFontFamily}}`),
      t instanceof Map)
    ) {
      const i =
        (e.htmlLabels ?? (null == (r = e.flowchart) ? void 0 : r.htmlLabels))
          ? ['> *', 'span']
          : ['rect', 'polygon', 'ellipse', 'circle', 'path'];
      t.forEach((e) => {
        (Hk(e.styles) ||
          i.forEach((t) => {
            n += dw(e.id, t, e.styles);
          }),
          Hk(e.textStyles) ||
            (n += dw(
              e.id,
              'tspan',
              ((null == e ? void 0 : e.textStyles) || []).map((e) => e.replace('color', 'fill'))
            )));
      });
    }
    return n;
  }, 'createCssStyles'),
  pw = ii((e, t, r, n) => {
    const i = uw(e, r);
    return _k(xk(`${n}{${ps(t, i, e.themeVariables)}}`), Sk);
  }, 'createUserStyles'),
  gw = ii((e = '', t, r) => {
    let n = e;
    return (
      r || t || (n = n.replace(/marker-end="url\([\d+./:=?A-Za-z-]*?#/g, 'marker-end="url(#')),
      (n = Wp(n)),
      (n = n.replace(/<br>/g, '<br/>')),
      n
    );
  }, 'cleanUpSvgCode'),
  fw = ii((e = '', t) => {
    var r, n;
    return `<iframe style="width:100%;height:${(null == (n = null == (r = null == t ? void 0 : t.viewBox) ? void 0 : r.baseVal) ? void 0 : n.height) ? t.viewBox.baseVal.height + 'px' : '100%'};border:0;margin:0;" src="data:text/html;charset=UTF-8;base64,${ow(`<body style="margin:0">${e}</body>`)}" sandbox="allow-top-navigation-by-user-activation allow-popups">\n  The "iframe" tag is not supported by your browser.\n</iframe>`;
  }, 'putIntoIFrame'),
  mw = ii((e, t, r, n, i) => {
    const a = e.append('div');
    (a.attr('id', r), n && a.attr('style', n));
    const o = a
      .append('svg')
      .attr('id', t)
      .attr('width', '100%')
      .attr('xmlns', 'http://www.w3.org/2000/svg');
    return (i && o.attr('xmlns:xlink', i), o.append('g'), e);
  }, 'appendDivSvgG');
function bw(e, t) {
  return e
    .append('iframe')
    .attr('id', t)
    .attr('style', 'width: 100%; height: 100%;')
    .attr('sandbox', '');
}
ii(bw, 'sandboxedIframe');
var yw = ii((e, t, r, n) => {
    var i, a, o;
    (null == (i = e.getElementById(t)) || i.remove(),
      null == (a = e.getElementById(r)) || a.remove(),
      null == (o = e.getElementById(n)) || o.remove());
  }, 'removeExistingElements'),
  xw = ii(async function (e, t, r) {
    var n, i, a, o, s, l;
    VC();
    const c = cw(t);
    t = c.code;
    const h = _o();
    (si.debug(h),
      t.length > ((null == h ? void 0 : h.maxTextSize) ?? 5e4) &&
        (t = 'graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa'));
    const d = '#' + e,
      u = 'i' + e,
      p = '#' + u,
      g = 'd' + e,
      f = '#' + g,
      m = ii(() => {
        const e = S(y ? p : f).node();
        e && 'remove' in e && e.remove();
      }, 'removeTempElements');
    let b = S('body');
    const y = 'sandbox' === h.securityLevel,
      x = 'loose' === h.securityLevel,
      k = h.fontFamily;
    if (void 0 !== r) {
      if ((r && (r.innerHTML = ''), y)) {
        const e = bw(S(r), u);
        ((b = S(e.nodes()[0].contentDocument.body)), (b.node().style.margin = 0));
      } else b = S(r);
      mw(b, e, g, `font-family: ${k}`, 'http://www.w3.org/1999/xlink');
    } else {
      if ((yw(document, e, g, u), y)) {
        const e = bw(S('body'), u);
        ((b = S(e.nodes()[0].contentDocument.body)), (b.node().style.margin = 0));
      } else b = S('body');
      mw(b, e, g);
    }
    let C, w;
    try {
      C = await XC.fromText(t, { title: c.title });
    } catch (M) {
      if (h.suppressErrorRendering) throw (m(), M);
      ((C = await XC.fromText('error')), (w = M));
    }
    const v = b.select(f).node(),
      _ = C.type,
      E = v.firstChild,
      D = E.firstChild,
      A = null == (i = (n = C.renderer).getClasses) ? void 0 : i.call(n, t, C),
      T = pw(h, _, A, d),
      F = document.createElement('style');
    ((F.innerHTML = T), E.insertBefore(F, D));
    try {
      await C.renderer.draw(t, e, ei.version, C);
    } catch (N) {
      throw (h.suppressErrorRendering ? m() : _C.draw(t, e, ei.version), N);
    }
    (ww(
      _,
      b.select(`${f} svg`),
      null == (o = (a = C.db).getAccTitle) ? void 0 : o.call(a),
      null == (l = (s = C.db).getAccDescription) ? void 0 : l.call(s)
    ),
      b
        .select(`[id="${e}"]`)
        .selectAll('foreignobject > *')
        .attr('xmlns', 'http://www.w3.org/1999/xhtml'));
    let B = b.select(f).node().innerHTML;
    if (
      (si.debug('config.arrowMarkerAbsolute', h.arrowMarkerAbsolute),
      (B = gw(B, y, Go(h.arrowMarkerAbsolute))),
      y)
    ) {
      const e = b.select(f + ' svg').node();
      B = fw(B, e);
    } else
      x ||
        (B = Oa.sanitize(B, {
          ADD_TAGS: sw,
          ADD_ATTR: lw,
          HTML_INTEGRATION_POINTS: { foreignobject: !0 },
        }));
    if ((JC(), w)) throw w;
    return (m(), { diagramType: _, svg: B, bindFunctions: C.db.bindFunctions });
  }, 'render');
function kw(e = {}) {
  var t;
  const r = Ga({}, e);
  ((null == r ? void 0 : r.fontFamily) &&
    !(null == (t = r.themeVariables) ? void 0 : t.fontFamily) &&
    (r.themeVariables || (r.themeVariables = {}), (r.themeVariables.fontFamily = r.fontFamily)),
    ko(r),
    (null == r ? void 0 : r.theme) && r.theme in ao
      ? (r.themeVariables = ao[r.theme].getThemeVariables(r.themeVariables))
      : r && (r.themeVariables = ao.default.getThemeVariables(r.themeVariables)));
  const n = 'object' == typeof r ? xo(r) : wo();
  (li(n.logLevel), VC());
}
ii(kw, 'initialize');
var Cw = ii((e, t = {}) => {
  const { code: r } = aw(e);
  return XC.fromText(r, t);
}, 'getDiagramFromText');
function ww(e, t, r, n) {
  (KC(t, e), YC(t, r, n, t.attr('id')));
}
ii(ww, 'addA11yInfo');
var vw = Object.freeze({
  render: xw,
  parse: hw,
  getDiagramFromText: Cw,
  initialize: kw,
  getConfig: _o,
  setConfig: vo,
  getSiteConfig: wo,
  updateSiteConfig: Co,
  reset: ii(() => {
    Do();
  }, 'reset'),
  globalReset: ii(() => {
    Do(go);
  }, 'globalReset'),
  defaultConfig: go,
});
(li(_o().logLevel), Do(_o()));
var _w = ii((e, t, r) => {
    (si.warn(e),
      Ip(e)
        ? (r && r(e.str, e.hash), t.push({ ...e, message: e.str, error: e }))
        : (r && r(e),
          e instanceof Error &&
            t.push({ str: e.message, message: e.message, hash: e.name, error: e })));
  }, 'handleError'),
  Sw = ii(async function (e = { querySelector: '.mermaid' }) {
    try {
      await Ew(e);
    } catch (t) {
      if ((Ip(t) && si.error(t.str), Iw.parseError && Iw.parseError(t), !e.suppressErrors))
        throw (si.error('Use the suppressErrors option to suppress these errors'), t);
    }
  }, 'run'),
  Ew = ii(async function (
    { postRenderCallback: e, querySelector: t, nodes: r } = { querySelector: '.mermaid' }
  ) {
    const n = vw.getConfig();
    let i;
    if ((si.debug((e ? '' : 'No ') + 'Callback function found'), r)) i = r;
    else {
      if (!t) throw new Error('Nodes and querySelector are both undefined');
      i = document.querySelectorAll(t);
    }
    (si.debug(`Found ${i.length} diagrams`),
      void 0 !== (null == n ? void 0 : n.startOnLoad) &&
        (si.debug('Start On Load: ' + (null == n ? void 0 : n.startOnLoad)),
        vw.updateSiteConfig({ startOnLoad: null == n ? void 0 : n.startOnLoad })));
    const a = new jp.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed);
    let o;
    const s = [];
    for (const c of Array.from(i)) {
      if ((si.info('Rendering diagram: ' + c.id), c.getAttribute('data-processed'))) continue;
      c.setAttribute('data-processed', 'true');
      const t = `mermaid-${a.next()}`;
      ((o = c.innerHTML),
        (o = _f(jp.entityDecode(o))
          .trim()
          .replace(/<br\s*\/?>/gi, '<br/>')));
      const r = jp.detectInit(o);
      r && si.debug('Detected early reinit: ', r);
      try {
        const { svg: r, bindFunctions: n } = await $w(t, o, c);
        ((c.innerHTML = r), e && (await e(t)), n && n(c));
      } catch (l) {
        _w(l, s, Iw.parseError);
      }
    }
    if (s.length > 0) throw s[0];
  }, 'runThrowsErrors'),
  Dw = ii(function (e) {
    vw.initialize(e);
  }, 'initialize'),
  Aw = ii(async function (e, t, r) {
    (si.warn('mermaid.init is deprecated. Please use run instead.'), e && Dw(e));
    const n = { postRenderCallback: r, querySelector: '.mermaid' };
    ('string' == typeof t
      ? (n.querySelector = t)
      : t && (t instanceof HTMLElement ? (n.nodes = [t]) : (n.nodes = t)),
      await Sw(n));
  }, 'init'),
  Tw = ii(async (e, { lazyLoad: t = !0 } = {}) => {
    (VC(), qa(...e), !1 === t && (await ZC()));
  }, 'registerExternalDiagrams'),
  Fw = ii(function () {
    if (Iw.startOnLoad) {
      const { startOnLoad: e } = vw.getConfig();
      e && Iw.run().catch((e) => si.error('Mermaid failed to initialize', e));
    }
  }, 'contentLoaded');
'undefined' != typeof document && window.addEventListener('load', Fw, !1);
var Bw = ii(function (e) {
    Iw.parseError = e;
  }, 'setParseErrorHandler'),
  Mw = [],
  Nw = !1,
  Lw = ii(async () => {
    if (!Nw) {
      for (Nw = !0; Mw.length > 0; ) {
        const t = Mw.shift();
        if (t)
          try {
            await t();
          } catch (e) {
            si.error('Error executing queue', e);
          }
      }
      Nw = !1;
    }
  }, 'executeQueue'),
  Ow = ii(
    async (e, t) =>
      new Promise((r, n) => {
        const i = ii(
          () =>
            new Promise((i, a) => {
              vw.parse(e, t).then(
                (e) => {
                  (i(e), r(e));
                },
                (e) => {
                  var t;
                  (si.error('Error parsing', e),
                    null == (t = Iw.parseError) || t.call(Iw, e),
                    a(e),
                    n(e));
                }
              );
            }),
          'performCall'
        );
        (Mw.push(i), Lw().catch(n));
      }),
    'parse'
  ),
  $w = ii(
    (e, t, r) =>
      new Promise((n, i) => {
        const a = ii(
          () =>
            new Promise((a, o) => {
              vw.render(e, t, r).then(
                (e) => {
                  (a(e), n(e));
                },
                (e) => {
                  var t;
                  (si.error('Error parsing', e),
                    null == (t = Iw.parseError) || t.call(Iw, e),
                    o(e),
                    i(e));
                }
              );
            }),
          'performCall'
        );
        (Mw.push(a), Lw().catch(i));
      }),
    'render'
  ),
  Iw = {
    startOnLoad: !0,
    mermaidAPI: vw,
    parse: Ow,
    render: $w,
    init: Aw,
    run: Sw,
    registerExternalDiagrams: Tw,
    registerLayoutLoaders: zx,
    initialize: Dw,
    parseError: void 0,
    contentLoaded: Fw,
    setParseErrorHandler: Bw,
    detectType: ja,
    registerIconPacks: Af,
    getRegisteredDiagramsMetadata: ii(
      () => Object.keys(Pa).map((e) => ({ id: e })),
      'getRegisteredDiagramsMetadata'
    ),
  },
  Rw = Iw;
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
const zw = ({ chart: e, className: t = '' }) => {
    const [r, n] = C.useState(''),
      [i, a] = C.useState(''),
      { theme: o } = _();
    return (
      C.useEffect(() => {
        (async () => {
          if (e)
            try {
              const t = (e, t) => {
                const r = getComputedStyle(document.documentElement).getPropertyValue(e).trim();
                if (!r) return t;
                if (r.startsWith('#')) return r;
                if (/^[\d.]+\s+[\d.]+%\s+[\d.]+%$/.test(r)) {
                  const [e, t, n] = r.split(/\s+/);
                  return `hsl(${e}, ${t}, ${n})`;
                }
                return t;
              };
              Rw.initialize({
                startOnLoad: !1,
                theme: 'dark' === o.mode ? 'dark' : 'default',
                themeVariables: {
                  primaryColor: t('--primary', '#3b82f6'),
                  primaryTextColor: t('--primary-foreground', '#ffffff'),
                  primaryBorderColor: t('--border', '#e5e7eb'),
                  lineColor: t('--muted-foreground', '#6b7280'),
                  secondaryColor: t('--secondary', '#f3f4f6'),
                  tertiaryColor: t('--accent', '#fef3c7'),
                },
                fontFamily:
                  getComputedStyle(document.documentElement)
                    .getPropertyValue('font-family')
                    .trim() || 'system-ui, -apple-system, sans-serif',
                securityLevel: 'strict',
                logLevel: 'error',
              });
              const r = `mermaid-${Math.random().toString(36).substring(2, 11)}`,
                { svg: i } = await Rw.render(r, e);
              (n(i), a(''));
            } catch (t) {
              (a(t instanceof Error ? t.message : 'Failed to render diagram'), n(''));
            }
        })();
      }, [e, o]),
      i
        ? u.jsx('div', {
            className: `border border-destructive/50 bg-destructive/10 rounded-lg p-4 my-4 ${t}`,
            children: u.jsxs('div', {
              className: 'flex items-start gap-2',
              children: [
                u.jsx('svg', {
                  xmlns: 'http://www.w3.org/2000/svg',
                  className: 'h-5 w-5 text-destructive flex-shrink-0 mt-0.5',
                  viewBox: '0 0 20 20',
                  fill: 'currentColor',
                  children: u.jsx('path', {
                    fillRule: 'evenodd',
                    d: 'M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z',
                    clipRule: 'evenodd',
                  }),
                }),
                u.jsxs('div', {
                  children: [
                    u.jsx('div', {
                      className: 'font-semibold text-destructive',
                      children: 'Mermaid Diagram Error',
                    }),
                    u.jsx('div', { className: 'text-sm text-muted-foreground mt-1', children: i }),
                  ],
                }),
              ],
            }),
          })
        : r
          ? u.jsx('div', {
              className: `mermaid-diagram my-6 flex items-center justify-center overflow-x-auto ${t}`,
              dangerouslySetInnerHTML: { __html: r },
            })
          : u.jsx('div', {
              className: `flex items-center justify-center p-8 my-4 border border-border rounded-lg bg-muted/30 ${t}`,
              children: u.jsxs('div', {
                className: 'flex items-center gap-2 text-muted-foreground',
                children: [
                  u.jsxs('svg', {
                    className: 'animate-spin h-5 w-5',
                    xmlns: 'http://www.w3.org/2000/svg',
                    fill: 'none',
                    viewBox: '0 0 24 24',
                    children: [
                      u.jsx('circle', {
                        className: 'opacity-25',
                        cx: '12',
                        cy: '12',
                        r: '10',
                        stroke: 'currentColor',
                        strokeWidth: '4',
                      }),
                      u.jsx('path', {
                        className: 'opacity-75',
                        fill: 'currentColor',
                        d: 'M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z',
                      }),
                    ],
                  }),
                  u.jsx('span', { className: 'text-sm', children: 'Rendering diagram...' }),
                ],
              }),
            })
    );
  },
  Pw = {
    info: {
      icon: x,
      bgColor: 'bg-blue-50 dark:bg-blue-950/30',
      borderColor: 'border-blue-200 dark:border-blue-800',
      iconColor: 'text-blue-600 dark:text-blue-400',
      textColor: 'text-blue-900 dark:text-blue-100',
      title: 'Info',
    },
    warning: {
      icon: y,
      bgColor: 'bg-yellow-50 dark:bg-yellow-950/30',
      borderColor: 'border-yellow-200 dark:border-yellow-800',
      iconColor: 'text-yellow-600 dark:text-yellow-400',
      textColor: 'text-yellow-900 dark:text-yellow-100',
      title: 'Warning',
    },
    tip: {
      icon: b,
      bgColor: 'bg-green-50 dark:bg-green-950/30',
      borderColor: 'border-green-200 dark:border-green-800',
      iconColor: 'text-green-600 dark:text-green-400',
      textColor: 'text-green-900 dark:text-green-100',
      title: 'Tip',
    },
    danger: {
      icon: m,
      bgColor: 'bg-red-50 dark:bg-red-950/30',
      borderColor: 'border-red-200 dark:border-red-800',
      iconColor: 'text-red-600 dark:text-red-400',
      textColor: 'text-red-900 dark:text-red-100',
      title: 'Danger',
    },
  },
  jw = ({ type: e, children: t, className: r = '' }) => {
    const n = Pw[e],
      i = n.icon;
    return u.jsx('div', {
      className: `${n.bgColor} ${n.borderColor} ${n.textColor} border-l-4 rounded-r-lg p-4 my-4 ${r}`,
      children: u.jsxs('div', {
        className: 'flex items-start gap-3',
        children: [
          u.jsx(i, { className: `${n.iconColor} h-5 w-5 flex-shrink-0 mt-0.5` }),
          u.jsxs('div', {
            className: 'flex-1',
            children: [
              u.jsx('div', { className: 'font-semibold mb-1', children: n.title }),
              u.jsx('div', {
                className: 'text-sm leading-relaxed prose-sm max-w-none',
                children: t,
              }),
            ],
          }),
        ],
      }),
    });
  };
function qw() {
  return (e) => {
    ae(e, (e) => {
      if (
        'containerDirective' === e.type &&
        ['info', 'warning', 'tip', 'danger'].includes(e.name)
      ) {
        const t = e.data || (e.data = {}),
          r = 'div';
        ((t.hName = r),
          (t.hProperties = {
            className: `callout callout-${e.name}`,
            'data-callout-type': e.name,
          }));
      }
    });
  };
}
const Ww = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      MarkdownPage: function ({ path: e }) {
        const [t, r] = C.useState(''),
          [n, i] = C.useState(!0),
          [a, o] = C.useState([]);
        C.useEffect(() => {
          fetch(`/content/${e}.md`)
            .then((e) => {
              if (!e.ok) throw new Error('Not found');
              return e.text();
            })
            .then((e) => {
              const t = s(e);
              r(t);
              const n = l(t);
              (o(n), i(!1));
            })
            .catch((e) => {
              (r('# Document Not Found\n\nThe requested document could not be loaded.'), i(!1));
            });
        }, [e]);
        const s = (e) => e.replace(/^---\n[\s\S]*?\n---\n*/, ''),
          l = (e) => {
            const t = /^(#{1,6})\s+(.+)$/gm,
              r = [];
            let n;
            for (; null !== (n = t.exec(e)); ) {
              const e = n[1].length,
                t = n[2].trim(),
                i = t
                  .toLowerCase()
                  .replace(/[^\w\s-]/g, '')
                  .replace(/\s+/g, '-');
              r.push({ level: e, text: t, id: i });
            }
            return r;
          },
          c = a.length > 3;
        return n
          ? u.jsx('div', {
              className: 'flex items-center justify-center h-96',
              children: u.jsx('div', {
                className: 'text-muted-foreground',
                children: 'Loading document...',
              }),
            })
          : u.jsxs('div', {
              className: 'flex gap-6',
              children: [
                u.jsx('div', {
                  className: 'flex-1 ' + (c ? 'max-w-4xl' : 'max-w-5xl'),
                  children: u.jsx('article', {
                    className: 'prose prose-slate dark:prose-invert max-w-none',
                    children: u.jsx(oe, {
                      remarkPlugins: [se, it, qw],
                      rehypePlugins: [Un, Xn],
                      components: {
                        div: ({ node: e, className: t, children: r, ...n }) => {
                          if (t && t.startsWith('callout callout-')) {
                            const e = n['data-callout-type'];
                            if (['info', 'warning', 'tip', 'danger'].includes(e))
                              return u.jsx(jw, { type: e, children: r });
                          }
                          return u.jsx('div', { className: t, ...n, children: r });
                        },
                        h1: ({ node: e, children: t, ...r }) =>
                          u.jsx('h1', {
                            className: 'text-4xl font-bold text-foreground mb-4 mt-8 first:mt-0',
                            ...r,
                            children: t,
                          }),
                        h2: ({ node: e, children: t, ...r }) =>
                          u.jsx('h2', {
                            className:
                              'text-3xl font-bold text-foreground mb-3 mt-6 border-b border-border pb-2',
                            ...r,
                            children: t,
                          }),
                        h3: ({ node: e, children: t, ...r }) =>
                          u.jsx('h3', {
                            className: 'text-2xl font-semibold text-foreground mb-2 mt-5',
                            ...r,
                            children: t,
                          }),
                        h4: ({ node: e, children: t, ...r }) =>
                          u.jsx('h4', {
                            className: 'text-xl font-semibold text-foreground mb-2 mt-4',
                            ...r,
                            children: t,
                          }),
                        p: ({ node: e, ...t }) =>
                          u.jsx('p', { className: 'text-foreground mb-4 leading-7', ...t }),
                        a: ({ node: e, ...t }) =>
                          u.jsx('a', {
                            className: 'text-primary hover:underline font-medium',
                            ...t,
                          }),
                        pre: ({ node: e, children: t, ...r }) => {
                          var n;
                          const i = null == t ? void 0 : t.props;
                          if (
                            null == (n = null == i ? void 0 : i.className)
                              ? void 0
                              : n.includes('language-mermaid')
                          ) {
                            const e = (t) => {
                                if (!t) return '';
                                if ('string' == typeof t) return t;
                                if ('number' == typeof t) return String(t);
                                if (Array.isArray(t)) return t.map((t) => e(t)).join('');
                                if ('object' == typeof t && 'props' in t && t.props) {
                                  if ('string' == typeof t.props.children) return t.props.children;
                                  if (Array.isArray(t.props.children))
                                    return t.props.children.map((t) => e(t)).join('');
                                  if (t.props.children) return e(t.props.children);
                                }
                                return '';
                              },
                              t = e(i.children).replace(/\n$/, '');
                            return u.jsx(zw, { chart: t });
                          }
                          return u.jsx(u.Fragment, { children: t });
                        },
                        code: ({ node: e, inline: t, className: r, children: n, ...i }) => {
                          const a = (e) => {
                              if (!e) return '';
                              if ('string' == typeof e) return e;
                              if ('number' == typeof e) return String(e);
                              if (Array.isArray(e)) return e.map((e) => a(e)).join('');
                              if ('object' == typeof e && 'props' in e && e.props) {
                                if ('string' == typeof e.props.children) return e.props.children;
                                if (Array.isArray(e.props.children))
                                  return e.props.children.map((e) => a(e)).join('');
                                if (e.props.children) return a(e.props.children);
                              }
                              return '';
                            },
                            o = a(n).replace(/\n$/, ''),
                            s = (null == r ? void 0 : r.replace(/language-/, '')) || '';
                          return u.jsx(Jn, { inline: t, className: r, language: s, children: o });
                        },
                        blockquote: ({ node: e, ...t }) =>
                          u.jsx('blockquote', {
                            className:
                              'border-l-4 border-primary pl-4 italic text-muted-foreground my-4',
                            ...t,
                          }),
                        ul: ({ node: e, ...t }) =>
                          u.jsx('ul', { className: 'list-disc list-inside mb-4 space-y-2', ...t }),
                        ol: ({ node: e, ...t }) =>
                          u.jsx('ol', {
                            className: 'list-decimal list-inside mb-4 space-y-2',
                            ...t,
                          }),
                        li: ({ node: e, ...t }) =>
                          u.jsx('li', { className: 'text-foreground', ...t }),
                        table: ({ node: e, ...t }) =>
                          u.jsx('div', {
                            className: 'overflow-x-auto mb-4',
                            children: u.jsx('table', {
                              className: 'min-w-full border-collapse border border-border',
                              ...t,
                            }),
                          }),
                        thead: ({ node: e, ...t }) => u.jsx('thead', { ...t }),
                        th: ({ node: e, ...t }) =>
                          u.jsx('th', {
                            className:
                              'border border-border px-4 py-2 text-left font-semibold text-foreground',
                            ...t,
                          }),
                        td: ({ node: e, children: t, ...r }) => {
                          const n = (e) => {
                              var t, r, i, a;
                              if (!e) return e;
                              if ('string' == typeof e) return e;
                              if ('number' == typeof e) return String(e);
                              if (Array.isArray(e)) return e.map((e) => n(e)).join('');
                              if (
                                'code' === (null == e ? void 0 : e.type) ||
                                ('object' == typeof e &&
                                  (null ==
                                  (r =
                                    null == (t = null == e ? void 0 : e.props)
                                      ? void 0
                                      : t.className)
                                    ? void 0
                                    : r.includes('language-')))
                              ) {
                                const t = null == (i = e.props) ? void 0 : i.children;
                                return 'string' == typeof t
                                  ? t
                                  : Array.isArray(t)
                                    ? t.map((e) => n(e)).join('')
                                    : t && 'object' == typeof t
                                      ? n(t)
                                      : '';
                              }
                              if (
                                'object' == typeof e &&
                                (null == (a = null == e ? void 0 : e.props) ? void 0 : a.children)
                              ) {
                                const t = e.props.children;
                                return 'string' == typeof t
                                  ? t
                                  : Array.isArray(t)
                                    ? t.map((e) => n(e)).join('')
                                    : n(t);
                              }
                              return e;
                            },
                            i = n(t);
                          return u.jsx('td', {
                            className: 'border border-border px-4 py-2 text-foreground',
                            ...r,
                            children: u.jsx('span', {
                              className: 'font-mono text-foreground',
                              children: i,
                            }),
                          });
                        },
                      },
                      children: t,
                    }),
                  }),
                }),
                c &&
                  u.jsx('aside', {
                    className: 'hidden lg:block flex-shrink-0',
                    children: u.jsx(Qn, { content: t, sticky: !0 }),
                  }),
              ],
            });
      },
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
);
export {
  cx as $,
  ai as A,
  Ms as B,
  Pp as C,
  _o as D,
  ho as E,
  Ep as F,
  Rs as G,
  ei as H,
  zp as I,
  Nh as J,
  to as K,
  Uf as L,
  ts as M,
  rs as N,
  Ho as O,
  is as P,
  Ko as Q,
  _p as R,
  No as S,
  cs as T,
  Si as U,
  Di as V,
  Ai as W,
  gs as X,
  pb as Y,
  ap as Z,
  ii as _,
  Cs as a,
  Rd as a$,
  ux as a0,
  zh as a1,
  Go as a2,
  Zf as a3,
  Ph as a4,
  Vf as a5,
  Wp as a6,
  wp as a7,
  hi as a8,
  Ci as a9,
  du as aA,
  Hu as aB,
  Iu as aC,
  Lu as aD,
  ep as aE,
  Vu as aF,
  qd as aG,
  Pd as aH,
  Su as aI,
  ip as aJ,
  au as aK,
  hd as aL,
  nd as aM,
  zu as aN,
  Ak as aO,
  Id as aP,
  hu as aQ,
  Ou as aR,
  tu as aS,
  Kd as aT,
  Yd as aU,
  Wk as aV,
  Tu as aW,
  Xd as aX,
  yu as aY,
  Vd as aZ,
  iu as a_,
  Hh as aa,
  Uh as ab,
  $x as ac,
  dx as ad,
  yx as ae,
  gb as af,
  Xm as ag,
  hx as ah,
  Fx as ai,
  wx as aj,
  kx as ak,
  tp as al,
  gu as am,
  Zu as an,
  ud as ao,
  Hk as ap,
  Mo as aq,
  Bf as ar,
  Af as as,
  Sf as at,
  ri as au,
  dd as av,
  rp as aw,
  qu as ax,
  Fd as ay,
  pu as az,
  ks as b,
  $d as b0,
  Zd as b1,
  Bu as b2,
  uu as b3,
  Bk as b4,
  np as b5,
  nu as b6,
  Ww as b7,
  As as c,
  ls as d,
  Ga as e,
  Mp as f,
  vs as g,
  zo as h,
  Yh as i,
  as as j,
  Bp as k,
  si as l,
  Ts as m,
  jx as n,
  _s as o,
  Ss as p,
  Lh as q,
  Px as r,
  ws as s,
  sx as t,
  jp as u,
  Up as v,
  Tp as w,
  xs as x,
  Fs as y,
  vi as z,
};
